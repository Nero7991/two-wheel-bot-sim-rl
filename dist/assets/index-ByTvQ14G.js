var e=Object.defineProperty,__name=(t,i)=>e(t,"name",{value:i,configurable:!0});__name(function polyfill(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))processPreload(e);new MutationObserver(e=>{for(const t of e)if("childList"===t.type)for(const e of t.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&processPreload(e)}).observe(document,{childList:!0,subtree:!0}),__name(getFetchOpts,"getFetchOpts"),__name(processPreload,"processPreload")}function getFetchOpts(e){const t={};return e.integrity&&(t.integrity=e.integrity),e.referrerPolicy&&(t.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?t.credentials="include":"anonymous"===e.crossOrigin?t.credentials="omit":t.credentials="same-origin",t}function processPreload(e){if(e.ep)return;e.ep=!0;const t=getFetchOpts(e);fetch(e.href,t)}},"polyfill")(),void 0===globalThis.GPUBufferUsage&&(globalThis.GPUBufferUsage={MAP_READ:1,MAP_WRITE:2,COPY_SRC:4,COPY_DST:8,INDEX:16,VERTEX:32,UNIFORM:64,STORAGE:128,INDIRECT:256,QUERY_RESOLVE:512}),void 0===globalThis.GPUMapMode&&(globalThis.GPUMapMode={READ:1,WRITE:2}),void 0===globalThis.GPUShaderStage&&(globalThis.GPUShaderStage={VERTEX:1,FRAGMENT:2,COMPUTE:4});navigator.gpu;class CoordinateTransform{static{__name(this,"CoordinateTransform")}constructor(e,t){this.canvasWidth=e,this.canvasHeight=t,this.physicsScale=400,this.centerX=e/2,this.centerY=.7*t,this.zoomLevel=1,this.minX=-e/(2*this.physicsScale),this.maxX=e/(2*this.physicsScale),this.minY=-t/(2*this.physicsScale),this.maxY=t/(2*this.physicsScale)}physicsToScreen(e,t){return{x:this.centerX+e*this.physicsScale*this.zoomLevel,y:this.centerY-t*this.physicsScale*this.zoomLevel}}screenToPhysics(e,t){return{x:(e-this.centerX)/(this.physicsScale*this.zoomLevel),y:(this.centerY-t)/(this.physicsScale*this.zoomLevel)}}resize(e,t){this.canvasWidth=e,this.canvasHeight=t,this.centerX=e/2,this.centerY=.7*t,this.minX=-e/(2*this.physicsScale),this.maxX=e/(2*this.physicsScale),this.minY=-t/(2*this.physicsScale),this.maxY=t/(2*this.physicsScale)}scaleLength(e){return e*this.physicsScale*this.zoomLevel}getPhysicsBounds(){return{minX:this.minX,maxX:this.maxX,minY:this.minY,maxY:this.maxY}}}class PerformanceMonitor{static{__name(this,"PerformanceMonitor")}constructor(){this.frameCount=0,this.lastTime=performance.now(),this.fps=60,this.frameTime=16.67,this.avgFrameTime=16.67,this.maxFrameTime=16.67,this.minFrameTime=16.67,this.frameTimes=[],this.historySize=60}update(){const e=performance.now();this.frameTime=e-this.lastTime,this.lastTime=e,this.frameTimes.push(this.frameTime),this.frameTimes.length>this.historySize&&this.frameTimes.shift(),this.avgFrameTime=this.frameTimes.reduce((e,t)=>e+t,0)/this.frameTimes.length,this.fps=1e3/this.avgFrameTime,this.maxFrameTime=Math.max(...this.frameTimes),this.minFrameTime=Math.min(...this.frameTimes)}getMetrics(){return{fps:Math.round(this.fps),avgFrameTime:this.avgFrameTime.toFixed(2),maxFrameTime:this.maxFrameTime.toFixed(2),minFrameTime:this.minFrameTime.toFixed(2)}}isPerformanceGood(){return this.fps>=55&&this.maxFrameTime<25}}class Renderer{static{__name(this,"Renderer")}constructor(e,t={}){this.canvas=e,this.ctx=e.getContext("2d"),this.config={backgroundColor:t.backgroundColor||"#0a0a0a",gridColor:t.gridColor||"#1a1a1a",robotColor:t.robotColor||"#00d4ff",wheelColor:t.wheelColor||"#ffffff",torqueColor:t.torqueColor||"#ff6b35",textColor:t.textColor||"#ffffff",showGrid:!1!==t.showGrid,showDebugInfo:!1!==t.showDebugInfo,showPerformance:!1!==t.showPerformance,targetFPS:t.targetFPS||60,...t},this.transform=new CoordinateTransform(e.width,e.height),this.performance=new PerformanceMonitor,this.isRendering=!1,this.animationId=null,this.lastRenderTime=0,this.frameInterval=1e3/this.config.targetFPS,this.robotState=null,this.robotConfig=null,this.motorTorque=0,this.trainingMetrics={episode:0,step:0,reward:0,totalReward:0,bestReward:0,epsilon:0,isTraining:!1,trainingMode:"idle"},this.showRobotInfo=!0,this.showTrainingInfo=!0,this.showPerformanceInfo=!0}start(){if(this.isRendering)return;this.isRendering=!0,this.lastRenderTime=performance.now();const e=__name(t=>{if(!this.isRendering)return;const i=t-this.lastRenderTime;i>=this.frameInterval&&(this.render(),this.performance.update(),this.lastRenderTime=t-i%this.frameInterval),this.animationId=requestAnimationFrame(e)},"renderLoop");this.animationId=requestAnimationFrame(e)}stop(){this.isRendering=!1,this.animationId&&(cancelAnimationFrame(this.animationId),this.animationId=null)}resize(e,t){this.canvas.width=e,this.canvas.height=t,this.transform.resize(e,t)}getPhysicsBounds(){return this.transform.getPhysicsBounds()}updateRobot(e,t,i=0){this.robotState=e,this.robotConfig=t,this.motorTorque=i}updateTraining(e){this.trainingMetrics={...this.trainingMetrics,...e}}render(){this.clear(),this.drawEnvironment(),this.robotState&&this.robotConfig?this.drawRobot():(this.robotState,this.robotConfig),this.drawUI()}clear(){this.ctx.fillStyle=this.config.backgroundColor,this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height)}drawEnvironment(){this.config.showGrid&&this.drawGrid(),this.drawGround(),this.drawAxes()}drawGrid(){this.ctx.strokeStyle=this.config.gridColor,this.ctx.lineWidth=1,this.ctx.globalAlpha=.3;const e=this.transform.scaleLength(.5);for(let t=this.transform.centerX%e;t<this.canvas.width;t+=e)this.ctx.beginPath(),this.ctx.moveTo(t,0),this.ctx.lineTo(t,this.canvas.height),this.ctx.stroke();for(let t=this.transform.centerY%e;t<this.canvas.height;t+=e)this.ctx.beginPath(),this.ctx.moveTo(0,t),this.ctx.lineTo(this.canvas.width,t),this.ctx.stroke();this.ctx.globalAlpha=1}drawGround(){const e=this.transform.centerY;this.ctx.fillStyle="#2a2a2a",this.ctx.fillRect(0,e,this.canvas.width,this.canvas.height-e),this.ctx.strokeStyle="#404040",this.ctx.lineWidth=2,this.ctx.lineCap="round";const t=this.canvas.width+60;for(let n=-60;n<t;n+=60){this.ctx.beginPath(),this.ctx.moveTo(n,e+5),this.ctx.lineTo(n+15,e+5+7.5),this.ctx.lineTo(n,e+5+15),this.ctx.stroke();for(let t=1;t<4;t++){const i=n+60*t/4;this.ctx.beginPath(),this.ctx.moveTo(i,e+2),this.ctx.lineTo(i,e+8),this.ctx.stroke()}}this.ctx.strokeStyle="#606060",this.ctx.lineWidth=3,this.ctx.beginPath(),this.ctx.moveTo(0,e),this.ctx.lineTo(this.canvas.width,e),this.ctx.stroke(),this.ctx.strokeStyle="rgba(64, 64, 64, 0.5)",this.ctx.lineWidth=1;const i=2*Math.PI*(this.robotConfig?.wheelRadius||.12),s=this.transform.scaleLength(i);this.transform.centerX;const a=this.robotState?.position||0,r=this.transform.physicsToScreen(a,0).x%s;for(let n=r;n<this.canvas.width;n+=s)this.ctx.beginPath(),this.ctx.moveTo(n,e),this.ctx.lineTo(n,e+30),this.ctx.stroke();for(let n=r-s;n>=0;n-=s)this.ctx.beginPath(),this.ctx.moveTo(n,e),this.ctx.lineTo(n,e+30),this.ctx.stroke();if(this.robotState&&this.config.showDebugInfo){const e=this.transform.physicsToScreen(this.robotState.position,0).x,t=this.transform.centerY;this.ctx.strokeStyle="rgba(255, 255, 0, 0.3)",this.ctx.lineWidth=1,this.ctx.beginPath(),this.ctx.moveTo(e-10,t),this.ctx.lineTo(e+10,t),this.ctx.stroke()}}drawAxes(){this.ctx.strokeStyle=this.config.textColor,this.ctx.lineWidth=1,this.ctx.globalAlpha=.5,this.ctx.beginPath(),this.ctx.moveTo(this.transform.centerX,0),this.ctx.lineTo(this.transform.centerX,this.canvas.height),this.ctx.moveTo(0,this.transform.centerY),this.ctx.lineTo(this.canvas.width,this.transform.centerY),this.ctx.stroke(),this.ctx.globalAlpha=1}drawRobot(){if(!this.robotState||!this.robotConfig)return;const{angle:e,position:t}=this.robotState,{centerOfMassHeight:i}=this.robotConfig,s=this.robotConfig?.wheelRadius||.12,a=this.transform.physicsToScreen(t,s),r=this.transform.physicsToScreen(t+Math.sin(e)*i,s+Math.cos(e)*i);this.drawRobotBody(a,r),this.drawWheels(a),this.drawTorqueIndicators(a),this.drawAngleIndicator(a,e)}drawRobotBody(e,t){const i=this.transform.scaleLength(.24),s=Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2)),a=Math.atan2(t.x-e.x,e.y-t.y);this.ctx.save(),this.ctx.translate(e.x,e.y),this.ctx.rotate(a),this.ctx.fillStyle="#2a4d3a",this.ctx.fillRect(-i/2,-s,i,.9*s),this.ctx.strokeStyle="#1a3d2a",this.ctx.lineWidth=2,this.ctx.strokeRect(-i/2,-s,i,.9*s),this.ctx.fillStyle="#ff4444",this.ctx.beginPath(),this.ctx.arc(0,.9*-s,15,0,2*Math.PI),this.ctx.fill(),this.ctx.restore(),this.ctx.fillStyle="#606060",this.ctx.beginPath(),this.ctx.arc(e.x,e.y,4,0,2*Math.PI),this.ctx.fill()}drawWheels(e){const t=this.robotConfig?.wheelRadius||.12,i=this.transform.scaleLength(t);this.ctx.fillStyle="#404040",this.ctx.beginPath(),this.ctx.arc(e.x,e.y,i,0,2*Math.PI),this.ctx.fill(),this.ctx.strokeStyle="#606060",this.ctx.lineWidth=3,this.ctx.beginPath(),this.ctx.arc(e.x,e.y,i,0,2*Math.PI),this.ctx.stroke(),this.ctx.strokeStyle="#202020",this.ctx.lineWidth=6,this.ctx.beginPath(),this.ctx.arc(e.x,e.y,i-2,0,2*Math.PI),this.ctx.stroke(),this.ctx.fillStyle="#707070",this.ctx.beginPath(),this.ctx.arc(e.x,e.y,.3*i,0,2*Math.PI),this.ctx.fill();const s=this.robotState.wheelAngle||0;this.ctx.strokeStyle="#808080",this.ctx.lineWidth=2,this.ctx.lineCap="round";for(let o=0;o<4;o++){const t=s+o*Math.PI/2,a=.4*i,r=.8*i;this.ctx.beginPath(),this.ctx.moveTo(e.x+Math.cos(t)*a,e.y+Math.sin(t)*a),this.ctx.lineTo(e.x+Math.cos(t)*r,e.y+Math.sin(t)*r),this.ctx.stroke()}const a=s,r=.9*i;this.ctx.fillStyle="#ff4444",this.ctx.beginPath(),this.ctx.arc(e.x+Math.cos(a)*r,e.y+Math.sin(a)*r,4,0,2*Math.PI),this.ctx.fill();const n=s+Math.PI;this.ctx.fillStyle="#4444ff",this.ctx.beginPath(),this.ctx.arc(e.x+Math.cos(n)*r,e.y+Math.sin(n)*r,3,0,2*Math.PI),this.ctx.fill()}drawTorqueIndicators(e){if(Math.abs(this.motorTorque)<.1)return;const t=this.robotConfig?.motorStrength||5,i=Math.abs(this.motorTorque)/t,s=80*i,a=Math.min(1,i);this.motorTorque>0?this.ctx.strokeStyle=`rgba(255, 107, 53, ${a})`:this.ctx.strokeStyle=`rgba(53, 107, 255, ${a})`,this.ctx.lineWidth=4,this.ctx.lineCap="round";const r=e.y-30,n=e.x-s/2,o=e.x+s/2;this.ctx.beginPath(),this.ctx.moveTo(n,r),this.ctx.lineTo(o,r),this.ctx.stroke();this.motorTorque>0?(this.ctx.beginPath(),this.ctx.moveTo(o,r),this.ctx.lineTo(o-8,r-4),this.ctx.moveTo(o,r),this.ctx.lineTo(o-8,r+4),this.ctx.stroke()):(this.ctx.beginPath(),this.ctx.moveTo(n,r),this.ctx.lineTo(n+8,r-4),this.ctx.moveTo(n,r),this.ctx.lineTo(n+8,r+4),this.ctx.stroke())}drawAngleIndicator(e,t){this.ctx.strokeStyle=this.config.robotColor,this.ctx.lineWidth=2,this.ctx.globalAlpha=.7,this.ctx.beginPath(),this.ctx.arc(e.x,e.y,50,-Math.PI/2,-Math.PI/2+t,t<0),this.ctx.stroke(),this.ctx.globalAlpha=1}drawUI(){this.showRobotInfo&&this.drawRobotInfo(),this.showTrainingInfo&&this.drawTrainingInfo(),this.showPerformanceInfo&&this.drawPerformanceInfo()}drawRobotInfo(){if(!this.robotState)return;const{angle:e,angularVelocity:t,position:i,velocity:s}=this.robotState;this.ctx.fillStyle=this.config.textColor,this.ctx.font="18px monospace",this.ctx.textAlign="left";const a=20;let r=30;this.ctx.fillStyle="rgba(0, 0, 0, 0.7)",this.ctx.fillRect(10,r-15,200,110),this.ctx.fillStyle=this.config.textColor,this.ctx.fillText("Robot State:",a,r),r+=18,this.ctx.fillText(`Angle: ${(180*e/Math.PI).toFixed(1)}°`,a,r),r+=18,this.ctx.fillText(`Angular Vel: ${t.toFixed(2)} rad/s`,a,r),r+=18,this.ctx.fillText(`Position: ${i.toFixed(2)} m`,a,r),r+=18,this.ctx.fillText(`Velocity: ${s.toFixed(2)} m/s`,a,r),r+=18,this.ctx.fillText(`Motor Torque: ${this.motorTorque.toFixed(2)} N⋅m`,a,r)}drawTrainingInfo(){const e=this.trainingMetrics;this.ctx.fillStyle=this.config.textColor,this.ctx.font="18px monospace",this.ctx.textAlign="right";const t=this.canvas.width-20;let i=30;const s=18;this.ctx.fillStyle="rgba(0, 0, 0, 0.7)",this.ctx.fillRect(t-190,i-15,200,130),this.ctx.fillStyle=this.config.textColor,this.ctx.fillText("Training Status:",t,i),i+=s,this.ctx.fillText(`Mode: ${e.trainingMode}`,t,i),i+=s,this.ctx.fillText(`Episode: ${e.episode}`,t,i),i+=s,this.ctx.fillText(`Step: ${e.step}`,t,i),i+=s,this.ctx.fillText(`Reward: ${e.reward.toFixed(1)}`,t,i),i+=s,this.ctx.fillText(`Best: ${e.bestReward.toFixed(1)}`,t,i),i+=s,this.ctx.fillText(`Epsilon: ${e.epsilon.toFixed(3)}`,t,i)}drawPerformanceInfo(){const e=this.performance.getMetrics();this.ctx.fillStyle=this.config.textColor,this.ctx.font="16px monospace",this.ctx.textAlign="left";const t=this.canvas.height-20;this.ctx.fillStyle="rgba(0, 0, 0, 0.7)",this.ctx.fillRect(10,t-35,200,45);const i=this.performance.isPerformanceGood()?"#00ff88":"#ff4444";this.ctx.fillStyle=i,this.ctx.fillText(`FPS: ${e.fps}`,20,t-20),this.ctx.fillStyle=this.config.textColor,this.ctx.fillText(`Frame: ${e.avgFrameTime}ms (${e.minFrameTime}-${e.maxFrameTime})`,20,t)}toggleUI(e){switch(e){case"robot":this.showRobotInfo=!this.showRobotInfo;break;case"training":this.showTrainingInfo=!this.showTrainingInfo;break;case"performance":this.showPerformanceInfo=!this.showPerformanceInfo}}updateConfig(e){this.config={...this.config,...e}}getStats(){return{isRendering:this.isRendering,canvasSize:{width:this.canvas.width,height:this.canvas.height},performance:this.performance.getMetrics(),targetFPS:this.config.targetFPS,hasRobotState:!!this.robotState,config:this.config}}zoomIn(){this.transform.zoomLevel=Math.min(3,this.transform.zoomLevel+.1)}zoomOut(){this.transform.zoomLevel=Math.max(.5,this.transform.zoomLevel-.1)}resetZoom(){this.transform.zoomLevel=1}getZoomLevel(){return this.transform.zoomLevel}destroy(){this.stop(),this.canvas=null,this.ctx=null,this.transform=null,this.performance=null}}function createRenderer(e,t={}){return new Renderer(e,t)}__name(createRenderer,"createRenderer");class BaseChart{static{__name(this,"BaseChart")}constructor(e,t={}){this.canvas=e,this.ctx=e.getContext("2d"),this.config={backgroundColor:t.backgroundColor||"#1a1a1a",gridColor:t.gridColor||"#404040",lineColor:t.lineColor||"#00d4ff",textColor:t.textColor||"#ffffff",axisColor:t.axisColor||"#666666",padding:t.padding||40,maxDataPoints:t.maxDataPoints||100,title:t.title||"",yLabel:t.yLabel||"",xLabel:t.xLabel||"Episodes",showGrid:!1!==t.showGrid,...t},this.data=[],this.minY=0,this.maxY=1,this.autoScale=!1!==t.autoScale}addData(e,t=null){const i={x:null!==t?t:this.data.length,y:e};if(this.data.push(i),this.data.length>this.config.maxDataPoints&&this.data.shift(),this.autoScale&&this.data.length>0){this.minY=Math.min(...this.data.map(e=>e.y)),this.maxY=Math.max(...this.data.map(e=>e.y));const e=this.maxY-this.minY,t=.1*e;this.minY-=t,this.maxY+=t,e<.1&&(this.minY-=.05,this.maxY+=.05)}}clear(){this.data=[],this.minY=0,this.maxY=1}dataToCanvas(e,t){const i=this.canvas.width-2*this.config.padding,s=this.canvas.height-2*this.config.padding;let a=this.config.padding;if(this.data.length>1){const t=Math.min(...this.data.map(e=>e.x)),s=Math.max(...this.data.map(e=>e.x))-t;s>0&&(a=this.config.padding+(e-t)/s*i)}const r=this.maxY-this.minY;let n=this.canvas.height-this.config.padding;return r>0&&(n=this.canvas.height-this.config.padding-(t-this.minY)/r*s),{x:a,y:n}}drawBackground(){this.ctx.fillStyle=this.config.backgroundColor,this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height),this.ctx.fillStyle="#0a0a0a",this.ctx.fillRect(this.config.padding,this.config.padding,this.canvas.width-2*this.config.padding,this.canvas.height-2*this.config.padding),this.config.showGrid&&this.drawGrid(),this.drawAxes(),this.drawLabels()}drawGrid(){this.ctx.strokeStyle=this.config.gridColor,this.ctx.lineWidth=1,this.ctx.globalAlpha=.3;const e=this.canvas.width-2*this.config.padding,t=this.canvas.height-2*this.config.padding;for(let i=0;i<=10;i++){const t=this.config.padding+i/10*e;this.ctx.beginPath(),this.ctx.moveTo(t,this.config.padding),this.ctx.lineTo(t,this.canvas.height-this.config.padding),this.ctx.stroke()}for(let i=0;i<=8;i++){const e=this.config.padding+i/8*t;this.ctx.beginPath(),this.ctx.moveTo(this.config.padding,e),this.ctx.lineTo(this.canvas.width-this.config.padding,e),this.ctx.stroke()}this.ctx.globalAlpha=1}drawAxes(){this.ctx.strokeStyle=this.config.axisColor,this.ctx.lineWidth=2,this.ctx.beginPath(),this.ctx.moveTo(this.config.padding,this.canvas.height-this.config.padding),this.ctx.lineTo(this.canvas.width-this.config.padding,this.canvas.height-this.config.padding),this.ctx.stroke(),this.ctx.beginPath(),this.ctx.moveTo(this.config.padding,this.config.padding),this.ctx.lineTo(this.config.padding,this.canvas.height-this.config.padding),this.ctx.stroke()}drawLabels(){this.ctx.fillStyle=this.config.textColor,this.ctx.font="12px monospace",this.ctx.textAlign="center",this.config.title&&(this.ctx.font="14px monospace",this.ctx.fillText(this.config.title,this.canvas.width/2,20),this.ctx.font="12px monospace"),this.config.xLabel&&this.ctx.fillText(this.config.xLabel,this.canvas.width/2,this.canvas.height-5),this.config.yLabel&&(this.ctx.save(),this.ctx.translate(15,this.canvas.height/2),this.ctx.rotate(-Math.PI/2),this.ctx.fillText(this.config.yLabel,0,0),this.ctx.restore()),this.ctx.textAlign="right",this.ctx.font="10px monospace";for(let e=0;e<=5;e++){const t=this.minY+(this.maxY-this.minY)*(1-e/5),i=this.config.padding+e/5*(this.canvas.height-2*this.config.padding);this.ctx.fillText(t.toFixed(2),this.config.padding-5,i+3)}}drawLine(){if(this.data.length<2)return;this.ctx.strokeStyle=this.config.lineColor,this.ctx.lineWidth=2,this.ctx.lineCap="round",this.ctx.lineJoin="round",this.ctx.beginPath();const e=this.dataToCanvas(this.data[0].x,this.data[0].y);this.ctx.moveTo(e.x,e.y);for(let t=1;t<this.data.length;t++){const e=this.dataToCanvas(this.data[t].x,this.data[t].y);this.ctx.lineTo(e.x,e.y)}this.ctx.stroke(),this.ctx.fillStyle=this.config.lineColor;for(const t of this.data){const e=this.dataToCanvas(t.x,t.y);this.ctx.beginPath(),this.ctx.arc(e.x,e.y,2,0,2*Math.PI),this.ctx.fill()}}render(){this.drawBackground(),this.drawLine()}setYRange(e,t){this.minY=e,this.maxY=t,this.autoScale=!1}getStats(){if(0===this.data.length)return{count:0,min:0,max:0,avg:0,last:0};const e=this.data.map(e=>e.y);return{count:this.data.length,min:Math.min(...e),max:Math.max(...e),avg:e.reduce((e,t)=>e+t,0)/e.length,last:e[e.length-1]}}}class PerformanceCharts{static{__name(this,"PerformanceCharts")}constructor(e,t={}){this.container=e,this.config={chartHeight:t.chartHeight||150,chartSpacing:t.chartSpacing||10,updateInterval:t.updateInterval||100,...t},this.charts={},this.isRendering=!1,this.lastUpdate=0,this.initializeCharts()}initializeCharts(){this.container.innerHTML='\n            <div class="charts-header">\n                <h3>Performance Metrics</h3>\n                <button id="clear-charts" style="float: right; padding: 4px 8px; font-size: 0.8rem;">Clear</button>\n            </div>\n            <div class="charts-grid">\n                <div class="chart-item">\n                    <canvas id="rewards-chart"></canvas>\n                </div>\n                <div class="chart-item">\n                    <canvas id="loss-chart"></canvas>\n                </div>\n                <div class="chart-item">\n                    <canvas id="qvalue-chart"></canvas>\n                </div>\n                <div class="chart-item">\n                    <canvas id="epsilon-chart"></canvas>\n                </div>\n            </div>\n        ';const e=document.createElement("style");e.textContent=`\n            .charts-header {\n                padding: 10px;\n                background-color: #2d2d2d;\n                border-bottom: 1px solid #404040;\n                color: #00d4ff;\n                font-size: 1rem;\n                display: flex;\n                justify-content: space-between;\n                align-items: center;\n            }\n            .charts-grid {\n                display: flex;\n                flex-direction: column;\n                gap: ${this.config.chartSpacing}px;\n                padding: 10px;\n                background-color: #1a1a1a;\n            }\n            .chart-item {\n                background-color: #0a0a0a;\n                border: 1px solid #404040;\n                border-radius: 4px;\n            }\n            .chart-item canvas {\n                display: block;\n                width: 100%;\n                height: ${this.config.chartHeight}px;\n            }\n        `,document.head.appendChild(e),this.initializeChart("rewards","Episode Rewards","Reward","#00ff88"),this.initializeChart("loss","Training Loss","Loss","#ff6b35"),this.initializeChart("qvalue","Q-Value Estimates","Q-Value","#ffaa00"),this.initializeChart("epsilon","Exploration Rate","Epsilon","#aa00ff"),document.getElementById("clear-charts").addEventListener("click",()=>{this.clearAllCharts()})}initializeChart(e,t,i,s){const a=document.getElementById(`${e}-chart`);if(!a)return;const r=a.getBoundingClientRect();a.width=r.width,a.height=this.config.chartHeight,this.charts[e]=new BaseChart(a,{title:t,yLabel:i,lineColor:s,padding:30})}start(){if(this.isRendering)return;this.isRendering=!0,this.lastUpdate=performance.now();const e=__name(t=>{if(!this.isRendering)return;t-this.lastUpdate>=this.config.updateInterval&&(this.renderAllCharts(),this.lastUpdate=t),requestAnimationFrame(e)},"renderLoop");requestAnimationFrame(e)}stop(){this.isRendering=!1}renderAllCharts(){Object.values(this.charts).forEach(e=>{e.render()})}updateRewards(e,t){this.charts.rewards&&this.charts.rewards.addData(t,e)}updateLoss(e,t){this.charts.loss&&this.charts.loss.addData(t,e)}updateQValue(e,t){this.charts.qvalue&&this.charts.qvalue.addData(t,e)}updateEpsilon(e,t){this.charts.epsilon&&this.charts.epsilon.addData(t,e)}updateMetrics(e){const t=e.episode||0;void 0!==e.reward&&this.updateRewards(t,e.reward),void 0!==e.loss&&this.updateLoss(t,e.loss),void 0!==e.qValue&&this.updateQValue(t,e.qValue),void 0!==e.epsilon&&this.updateEpsilon(t,e.epsilon)}clearAllCharts(){Object.values(this.charts).forEach(e=>{e.clear()})}resize(){Object.entries(this.charts).forEach(([e,t])=>{const i=t.canvas,s=i.getBoundingClientRect();i.width=s.width,i.height=this.config.chartHeight})}getStats(){const e={};return Object.entries(this.charts).forEach(([t,i])=>{e[t]=i.getStats()}),e}exportData(){const e={};return Object.entries(this.charts).forEach(([t,i])=>{e[t]=i.data}),e}importData(e){Object.entries(e).forEach(([e,t])=>{this.charts[e]&&(this.charts[e].data=t)})}destroy(){this.stop(),this.charts={},this.container.innerHTML=""}}function createPerformanceCharts(e,t={}){return new PerformanceCharts(e,t)}__name(createPerformanceCharts,"createPerformanceCharts");class NetworkArchitecture{static{__name(this,"NetworkArchitecture")}constructor(e){this.name=e.name||"Custom",this.description=e.description||"",this.inputSize=e.inputSize||2,this.outputSize=e.outputSize||3,this.layers=e.layers||[8],this.activations=e.activations||["relu"],this.maxParameters=e.maxParameters||200,this.memoryConstraint=e.memoryConstraint||1024,this.targetFrequency=e.targetFrequency||50,this.deployment=e.deployment||"web"}getParameterCount(){let e=0,t=this.inputSize;for(const i of this.layers)e+=t*i+i,t=i;return e+=t*this.outputSize+this.outputSize,e}validate(){const e=[];0===this.layers.length&&e.push("At least one hidden layer is required"),this.layers.length>8&&e.push("Maximum 8 layers supported");for(const[i,s]of this.layers.entries())(s<1||s>256)&&e.push(`Layer ${i+1}: Size must be between 1 and 256, got ${s}`);const t=this.getParameterCount();return t>this.maxParameters&&e.push(`Parameter count ${t} exceeds limit ${this.maxParameters}`),{valid:0===e.length,errors:e,parameterCount:t}}clone(){return new NetworkArchitecture({name:this.name,description:this.description,inputSize:this.inputSize,outputSize:this.outputSize,layers:[...this.layers],activations:[...this.activations],maxParameters:this.maxParameters,memoryConstraint:this.memoryConstraint,targetFrequency:this.targetFrequency,deployment:this.deployment})}}const t={MICRO:new NetworkArchitecture({name:"Micro Bot",description:"Ultra-minimal for 8-bit microcontrollers (< 32KB RAM)",layers:[4],maxParameters:50,memoryConstraint:32,targetFrequency:20,deployment:"embedded"}),NANO:new NetworkArchitecture({name:"Nano Bot",description:"Lightweight for basic two-wheel balancing (Arduino Nano)",layers:[6],maxParameters:80,memoryConstraint:64,targetFrequency:30,deployment:"embedded"}),CLASSIC:new NetworkArchitecture({name:"Classic Bot",description:"Standard two-wheel balancing robot (ESP32/STM32)",layers:[8],maxParameters:150,memoryConstraint:256,targetFrequency:50,deployment:"embedded"}),ENHANCED:new NetworkArchitecture({name:"Enhanced Bot",description:"Improved control with deeper network (Raspberry Pi)",layers:[12,8],maxParameters:400,memoryConstraint:512,targetFrequency:50,deployment:"embedded"}),ADVANCED:new NetworkArchitecture({name:"Advanced Bot",description:"Multi-layer network for complex maneuvers",layers:[16,12,8],maxParameters:800,memoryConstraint:1024,targetFrequency:100,deployment:"embedded"}),RESEARCH:new NetworkArchitecture({name:"Research Bot",description:"Deep network for research and experimentation",layers:[32,24,16,8],maxParameters:2e3,memoryConstraint:4096,targetFrequency:100,deployment:"web"}),MAXIMUM:new NetworkArchitecture({name:"Maximum Bot",description:"Largest network for intensive web training",layers:[64,48,32,24,16],maxParameters:1e4,memoryConstraint:16384,targetFrequency:200,deployment:"web"}),DQN_STANDARD:new NetworkArchitecture({name:"DQN Standard",description:"PyTorch DQN tutorial standard (proven hyperparameters)",layers:[128],maxParameters:1e3,memoryConstraint:2048,targetFrequency:100,deployment:"web"}),CUSTOM:new NetworkArchitecture({name:"Custom",description:"User-defined architecture",layers:[8],maxParameters:1e3,memoryConstraint:2048,targetFrequency:50,deployment:"web"})};function getPreset(e){return t[e.toUpperCase()]}function createCustomArchitecture(e){const t=new NetworkArchitecture(e),i=t.validate();if(!i.valid)throw new Error(`Invalid architecture: ${i.errors.join(", ")}`);return t}__name(getPreset,"getPreset"),__name(createCustomArchitecture,"createCustomArchitecture");class StateHistory{static{__name(this,"StateHistory")}constructor(e=1){this.maxTimesteps=Math.max(1,Math.min(8,e)),this.history=[],this.currentTimesteps=1}setTimesteps(e){for(this.currentTimesteps=Math.max(1,Math.min(8,e));this.history.length<this.currentTimesteps;)if(this.history.length>0){const e=this.history[this.history.length-1];this.history.push({angle:e.angle,angularVelocity:e.angularVelocity,timestamp:Date.now()})}else this.history.push({angle:0,angularVelocity:0,timestamp:Date.now()})}addState(e,t){this.history.unshift({angle:e,angularVelocity:t,timestamp:Date.now()}),this.history.length>this.maxTimesteps&&this.history.pop()}getNormalizedInputs(e=Math.PI/3){const t=2*this.currentTimesteps,i=new Float32Array(t);for(let s=0;s<this.currentTimesteps;s++){let t=0,a=0;s<this.history.length&&(t=this.history[s].angle,a=this.history[s].angularVelocity);const r=Math.max(-1,Math.min(1,t/e)),n=Math.max(-1,Math.min(1,a/10));i[2*s]=r,i[2*s+1]=n}return i}getHistory(){return this.history.slice(0,this.currentTimesteps)}reset(){this.history=[]}getStats(){const e=this.history.slice(0,this.currentTimesteps);let t=0,i=0,s=0;for(const a of e)t+=a.angle,i+=a.angularVelocity;t/=e.length,i/=e.length;for(const a of e)s+=Math.pow(a.angle-t,2);return s/=e.length,{currentTimesteps:this.currentTimesteps,historyLength:e.length,averageAngle:t,averageAngularVelocity:i,angleVariance:s,angleStdDev:Math.sqrt(s)}}}class RobotState{static{__name(this,"RobotState")}constructor(e=0,t=0,i=0,s=0,a=0,r=0){this.angle=e,this.angularVelocity=t,this.position=i,this.velocity=s,this.wheelAngle=a,this.wheelVelocity=r}clone(){return new RobotState(this.angle,this.angularVelocity,this.position,this.velocity,this.wheelAngle,this.wheelVelocity)}getNormalizedInputs(e=Math.PI/3){const t=Math.max(-1,Math.min(1,this.angle/e)),i=Math.max(-1,Math.min(1,this.angularVelocity/10));return new Float32Array([t,i])}hasFailed(e=Math.PI/3){return Math.abs(this.angle)>e}}class BalancingRobot{static{__name(this,"BalancingRobot")}constructor(e={}){this.mass=this._validateParameter(e.mass,1,.5,3,"mass"),this.centerOfMassHeight=this._validateParameter(e.centerOfMassHeight,.4,.2,1,"centerOfMassHeight"),this.motorStrength=this._validateParameter(e.motorStrength,5,2,20,"motorStrength"),this.friction=this._validateParameter(e.friction,.02,0,1,"friction"),this.damping=this._validateParameter(e.damping,.01,0,1,"damping"),this.timestep=this._validateParameter(e.timestep,.02,.001,.1,"timestep"),this.wheelRadius=this._validateParameter(e.wheelRadius,.12,.02,.2,"wheelRadius"),this.wheelMass=this._validateParameter(e.wheelMass,.2,.1,1,"wheelMass"),this.wheelFriction=this._validateParameter(e.wheelFriction,.3,0,1,"wheelFriction"),this.maxAngle=this._validateParameter(e.maxAngle,Math.PI/6,Math.PI/180,Math.PI/3,"maxAngle"),this.motorTorqueRange=this._validateParameter(e.motorTorqueRange,8,.5,10,"motorTorqueRange"),this.rewardType=e.rewardType||"simple",this.angleOffset=this._validateParameter(e.angleOffset,0,-Math.PI/6,Math.PI/6,"angleOffset"),this.offsetVariation=this._validateParameter(e.offsetVariation,.01,0,.1,"offsetVariation"),this.offsetChangeRate=this._validateParameter(e.offsetChangeRate,.001,0,.01,"offsetChangeRate"),this.trainingOffsetRange=this._validateParameter(e.trainingOffsetRange,0,0,Math.PI/6,"trainingOffsetRange"),this.balancePointEstimate=0,this.balancePointConfidence=0,this.adaptationRate=.02,this.gravity=9.81,this.momentOfInertia=this.mass*this.centerOfMassHeight*this.centerOfMassHeight,this.wheelInertia=.5*this.wheelMass*this.wheelRadius*this.wheelRadius,this.state=new RobotState,this.currentMotorTorque=0,this.previousMotorTorque=0,this.historyTimesteps=this._validateParameter(e.historyTimesteps,1,1,8,"historyTimesteps"),this.stateHistory=new StateHistory(8),this.stateHistory.setTimesteps(this.historyTimesteps),this.stepCount=0,this.totalReward=0}_validateParameter(e,t,i,s,a){return null==e||"number"!=typeof e||isNaN(e)?t:e<i||e>s?Math.max(i,Math.min(s,e)):e}reset(e={}){if(this.state=new RobotState(this._normalizeAngle(e.angle||0),e.angularVelocity||0,e.position||0,e.velocity||0,e.wheelAngle||0,e.wheelVelocity||0),this.currentMotorTorque=0,this.previousMotorTorque=0,this.stepCount=0,this.totalReward=0,"offset-adaptive"===this.rewardType&&this.trainingOffsetRange>0){const e=2*(Math.random()-.5)*this.trainingOffsetRange;this.angleOffset=e}this.stateHistory.reset();const t=this.getMeasuredAngle(),i=this.state.angularVelocity;for(let s=0;s<this.stateHistory.maxTimesteps;s++)this.stateHistory.addState(t,i)}step(e){if(this.state.hasFailed(this.maxAngle))return{state:this.state.clone(),reward:"simple"===this.rewardType?0:-10,done:!0};this.previousMotorTorque=this.currentMotorTorque;const t=e*this.motorTorqueRange;this.currentMotorTorque=Math.max(-this.motorStrength,Math.min(this.motorStrength,t));const i=this.state.clone();this._updatePhysics(),this.state.angle=this._normalizeAngle(this.state.angle);const s=this._calculateReward(i,this.currentMotorTorque);this.totalReward+=s;const a=this.state.hasFailed(this.maxAngle);return this.stepCount++,{state:this.state.clone(),reward:s,done:a}}_updatePhysics(){const e=this.timestep,t=this.mass*this.gravity*this.centerOfMassHeight*Math.sin(this.state.angle),i=-this.damping*this.state.angularVelocity,s=(-this.currentMotorTorque+t+i)/this.momentOfInertia;this.state.angularVelocity+=s*e,this.state.angle+=this.state.angularVelocity*e;const a=this.currentMotorTorque/this.wheelRadius,r=this.mass*this.gravity,n=(a+-this.friction*this.state.velocity*r)/this.mass;this.state.velocity+=n*e,this.state.position+=this.state.velocity*e;const o=this.state.velocity*e/this.wheelRadius;for(this.state.wheelAngle+=o;this.state.wheelAngle>2*Math.PI;)this.state.wheelAngle-=2*Math.PI;for(;this.state.wheelAngle<2*-Math.PI;)this.state.wheelAngle+=2*Math.PI;this.state.wheelVelocity=this.state.velocity/this.wheelRadius,this._updateAngleOffset(e);const h=this.getMeasuredAngle();this.stateHistory.addState(h,this.state.angularVelocity)}_calculateReward(e,t){if("simple"===this.rewardType)return this.state.hasFailed(this.maxAngle)?0:1;if("complex"===this.rewardType){if(this.state.hasFailed(this.maxAngle))return-10;return 1-Math.abs(this.state.angle)/this.maxAngle}if("efficient"===this.rewardType){if(this.state.hasFailed(this.maxAngle))return-10;const e=1-Math.abs(this.state.angle)/this.maxAngle,t=this.motorStrength;if(t<=0)return e;const i=Math.abs(this.currentMotorTorque)/t*.1,s=Math.abs(this.currentMotorTorque-this.previousMotorTorque),a=e-i-s/t*.05+(s<.1*t?.02:0);return isFinite(a)?Math.max(a,-1):e}if("offset-adaptive"===this.rewardType){if(this.state.hasFailed(this.maxAngle))return-10;const e=1-Math.abs(this.state.angle)/this.maxAngle,t=Math.abs(this.state.angularVelocity),i=3,s=e+Math.max(0,.2*(1-t/i))+.1;return Math.max(s,-1)}return this.state.hasFailed(this.maxAngle)?0:1}_updateAngleOffset(e){const t=(Math.random()-.5)*this.offsetChangeRate*e;this.angleOffset+=t;const i=(Math.random()-.5)*this.offsetVariation;this.angleOffset+=i*e,this.angleOffset=Math.max(-Math.PI/6,Math.min(Math.PI/6,this.angleOffset))}getMeasuredAngle(){return this.state.angle+this.angleOffset}setTrainingOffsetRange(e){this.trainingOffsetRange=Math.max(0,Math.min(15,e))*Math.PI/180}_updateBalancePointEstimate(e){if(Math.abs(this.state.angularVelocity)<1){const t=this.adaptationRate;this.balancePointEstimate=(1-t)*this.balancePointEstimate+t*e,this.balancePointConfidence=Math.min(1,this.balancePointConfidence+.001)}else this.balancePointConfidence=Math.max(0,this.balancePointConfidence-.002);this.balancePointEstimate=Math.max(-this.maxAngle/2,Math.min(this.maxAngle/2,this.balancePointEstimate))}_normalizeAngle(e){for(;e>Math.PI;)e-=2*Math.PI;for(;e<-Math.PI;)e+=2*Math.PI;return e}getState(){return this.state.clone()}getNormalizedInputs(){if(this.historyTimesteps>1)return this.stateHistory.getNormalizedInputs(this.maxAngle);const e=this.getMeasuredAngle(),t=Math.max(-1,Math.min(1,e/this.maxAngle)),i=Math.max(-1,Math.min(1,this.state.angularVelocity/10));return new Float32Array([t,i])}setHistoryTimesteps(e){this.historyTimesteps=Math.max(1,Math.min(8,e)),this.stateHistory.setTimesteps(this.historyTimesteps)}getConfig(){return{mass:this.mass,centerOfMassHeight:this.centerOfMassHeight,motorStrength:this.motorStrength,friction:this.friction,damping:this.damping,timestep:this.timestep,wheelRadius:this.wheelRadius,wheelMass:this.wheelMass,wheelFriction:this.wheelFriction,rewardType:this.rewardType,maxAngle:this.maxAngle,motorTorqueRange:this.motorTorqueRange}}updateConfig(e){void 0!==e.mass&&(this.mass=this._validateParameter(e.mass,this.mass,.5,3,"mass"),this.momentOfInertia=this.mass*this.centerOfMassHeight*this.centerOfMassHeight),void 0!==e.centerOfMassHeight&&(this.centerOfMassHeight=this._validateParameter(e.centerOfMassHeight,this.centerOfMassHeight,.2,1,"centerOfMassHeight"),this.momentOfInertia=this.mass*this.centerOfMassHeight*this.centerOfMassHeight),void 0!==e.motorStrength&&(this.motorStrength=this._validateParameter(e.motorStrength,this.motorStrength,2,20,"motorStrength")),void 0!==e.friction&&(this.friction=this._validateParameter(e.friction,this.friction,0,1,"friction")),void 0!==e.damping&&(this.damping=this._validateParameter(e.damping,this.damping,0,1,"damping")),void 0!==e.timestep&&(this.timestep=this._validateParameter(e.timestep,this.timestep,.001,.1,"timestep")),void 0!==e.wheelRadius&&(this.wheelRadius=this._validateParameter(e.wheelRadius,this.wheelRadius,.02,.2,"wheelRadius"),this.wheelInertia=.5*this.wheelMass*this.wheelRadius*this.wheelRadius),void 0!==e.wheelMass&&(this.wheelMass=this._validateParameter(e.wheelMass,this.wheelMass,.1,1,"wheelMass"),this.wheelInertia=.5*this.wheelMass*this.wheelRadius*this.wheelRadius),void 0!==e.wheelFriction&&(this.wheelFriction=this._validateParameter(e.wheelFriction,this.wheelFriction,0,1,"wheelFriction")),void 0!==e.maxAngle&&(this.maxAngle=this._validateParameter(e.maxAngle,this.maxAngle,Math.PI/180,Math.PI/3,"maxAngle")),void 0!==e.motorTorqueRange&&(this.motorTorqueRange=this._validateParameter(e.motorTorqueRange,this.motorTorqueRange,.5,10,"motorTorqueRange"))}getStats(){const e={stepCount:this.stepCount,totalReward:this.totalReward,currentMotorTorque:this.currentMotorTorque,simulationTime:this.stepCount*this.timestep};return"offset-adaptive"===this.rewardType&&(e.angleOffset=this.angleOffset,e.balancePointEstimate=this.balancePointEstimate,e.balancePointConfidence=this.balancePointConfidence,e.measuredAngle=this.getMeasuredAngle(),e.trueAngle=this.state.angle),e}setRewardType(e){"simple"!==e&&"complex"!==e&&"efficient"!==e&&"offset-adaptive"!==e||(this.rewardType=e)}getRewardType(){return this.rewardType}isStable(){return isFinite(this.state.angle)&&isFinite(this.state.angularVelocity)&&isFinite(this.state.position)&&isFinite(this.state.velocity)&&isFinite(this.currentMotorTorque)}}function createDefaultRobot(e={}){return new BalancingRobot(e)}__name(createDefaultRobot,"createDefaultRobot");class NeuralNetwork{static{__name(this,"NeuralNetwork")}constructor(){if(this.constructor===NeuralNetwork)throw new Error("NeuralNetwork is an abstract class and cannot be instantiated directly")}async createNetwork(e,t,i,s={}){throw new Error("createNetwork method must be implemented by subclass")}forward(e){throw new Error("forward method must be implemented by subclass")}getParameterCount(){throw new Error("getParameterCount method must be implemented by subclass")}getWeights(){throw new Error("getWeights method must be implemented by subclass")}setWeights(e){throw new Error("setWeights method must be implemented by subclass")}getArchitecture(){throw new Error("getArchitecture method must be implemented by subclass")}validateInput(e){if(!(e instanceof Float32Array))throw new Error("Input must be a Float32Array");if(e.length!==this.inputSize)throw new Error(`Input size mismatch. Expected ${this.inputSize}, got ${e.length}`);for(let t=0;t<e.length;t++)isFinite(e[t])||(e[t]=Math.max(-1,Math.min(1,isNaN(e[t])?0:e[t])))}validateOutput(e){if(!(e instanceof Float32Array))throw new Error("Output must be a Float32Array");if(e.length!==this.outputSize)throw new Error(`Output size mismatch. Expected ${this.outputSize}, got ${e.length}`);for(let t=0;t<e.length;t++)isFinite(e[t])||(e[t]=0)}}const i=2,s=3,a=4,r=256,n=5e4,o={XAVIER:"xavier",HE:"he",RANDOM:"random"};function calculateParameterCount(e,t,i){return e*t+t+(t*i+i)}function validateArchitecture(e,t,o){if(e!==i)throw new Error(`Input size must be ${i}, got ${e}`);if(o!==s)throw new Error(`Output size must be ${s}, got ${o}`);if(t<a||t>r)throw new Error(`Hidden size must be between ${a} and ${r}, got ${t}`);const h=calculateParameterCount(e,t,o);if(h>n)throw new Error(`Parameter count ${h} exceeds maximum ${n}`)}function vectorMatrixMultiply(e,t,i,s,a){if(e.length!==s)throw new Error(`Input size mismatch. Expected ${s}, got ${e.length}`);if(t.length!==s*a)throw new Error(`Weight matrix size mismatch. Expected ${s*a}, got ${t.length}`);if(i.length!==a)throw new Error(`Bias size mismatch. Expected ${a}, got ${i.length}`);const r=new Float32Array(a);for(let n=0;n<a;n++){let o=i[n];for(let i=0;i<s;i++)o+=e[i]*t[i*a+n];r[n]=o}return r}function xavierInit(e,t){const i=Math.sqrt(6/(e+t)),s=new Float32Array(e*t);for(let a=0;a<s.length;a++)s[a]=(2*Math.random()-1)*i;return s}function heInit(e,t){const i=Math.sqrt(2/e),s=new Float32Array(e*t);for(let a=0;a<s.length;a++){const e=Math.random(),t=Math.random(),r=Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t);s[a]=r*i}return s}function zeroInit(e){return new Float32Array(e)}__name(calculateParameterCount,"calculateParameterCount"),__name(validateArchitecture,"validateArchitecture"),__name(vectorMatrixMultiply,"vectorMatrixMultiply"),__name(xavierInit,"xavierInit"),__name(heInit,"heInit"),__name(zeroInit,"zeroInit");const h={time(e,...t){const i=performance.now();return{result:e(...t),time:performance.now()-i}},benchmark(e,t,...i){let s=0,a=null;for(let r=0;r<t;r++){const t=performance.now();a=e(...i);s+=performance.now()-t}return{averageTime:s/t,totalTime:s,iterations:t,lastResult:a}}};class CPUBackend extends NeuralNetwork{static{__name(this,"CPUBackend")}constructor(){super(),this.inputSize=0,this.hiddenSize=0,this.outputSize=0,this.parameterCount=0,this.weightsInputHidden=null,this.biasHidden=null,this.weightsHiddenOutput=null,this.biasOutput=null,this.hiddenActivation=null,this.outputActivation=null,this.initMethod=o.HE,this.isInitialized=!1}async createNetwork(e,t,i,s={}){this._validateVariableArchitecture(e,t,i),this.inputSize=e,this.hiddenSize=t,this.outputSize=i,this.parameterCount=calculateParameterCount(e,t,i),this.initMethod=s.initMethod||o.HE,this._initializeWeights(),this.hiddenActivation=new Float32Array(t),this.outputActivation=new Float32Array(i),this.isInitialized=!0}forward(e){if(!this.isInitialized)throw new Error("Network not initialized. Call createNetwork() first.");this.validateInput(e);const t=vectorMatrixMultiply(e,this.weightsInputHidden,this.biasHidden,this.inputSize,this.hiddenSize);for(let s=0;s<this.hiddenSize;s++)this.hiddenActivation[s]=Math.max(0,t[s]);const i=vectorMatrixMultiply(this.hiddenActivation,this.weightsHiddenOutput,this.biasOutput,this.hiddenSize,this.outputSize);this.validateOutput(i);for(let s=0;s<i.length;s++)i[s]=Math.max(-100,Math.min(100,i[s]));return i}getHiddenActivations(){if(!this.isInitialized)throw new Error("Network not initialized");if(!this.hiddenActivation)throw new Error("No forward pass performed yet");return this.hiddenActivation.slice()}getParameterCount(){return this.parameterCount}getWeights(){if(!this.isInitialized)throw new Error("Network not initialized");return{architecture:{inputSize:this.inputSize,hiddenSize:this.hiddenSize,outputSize:this.outputSize,parameterCount:this.parameterCount},weightsInputHidden:Array.from(this.weightsInputHidden),biasHidden:Array.from(this.biasHidden),weightsHiddenOutput:Array.from(this.weightsHiddenOutput),biasOutput:Array.from(this.biasOutput),initMethod:this.initMethod}}setWeights(e){if(!e.architecture)throw new Error("Invalid weights object: missing architecture");const t=e.architecture;if(this.isInitialized){if(t.inputSize!==this.inputSize||t.hiddenSize!==this.hiddenSize||t.outputSize!==this.outputSize)throw new Error("Weight architecture incompatible with current network")}else this.inputSize=t.inputSize,this.hiddenSize=t.hiddenSize,this.outputSize=t.outputSize,this.parameterCount=t.parameterCount,this.hiddenActivation=new Float32Array(this.hiddenSize),this.outputActivation=new Float32Array(this.outputSize),this.isInitialized=!0;this.weightsInputHidden=new Float32Array(e.weightsInputHidden),this.biasHidden=new Float32Array(e.biasHidden),this.weightsHiddenOutput=new Float32Array(e.weightsHiddenOutput),this.biasOutput=new Float32Array(e.biasOutput),this.initMethod=e.initMethod||this.initMethod}getArchitecture(){return{inputSize:this.inputSize,hiddenSize:this.hiddenSize,outputSize:this.outputSize,parameterCount:this.parameterCount,activations:{hidden:"relu",output:"linear"},initMethod:this.initMethod,backend:"cpu",isInitialized:this.isInitialized}}benchmark(e=1e3){if(!this.isInitialized)throw new Error("Network not initialized");const t=new Float32Array(this.inputSize);for(let i=0;i<this.inputSize;i+=2)t[i]=.1,t[i+1]=-.05;return h.benchmark(e=>this.forward(e),e,t)}_initializeWeights(){switch(this.initMethod){case o.HE:this.weightsInputHidden=heInit(this.inputSize,this.hiddenSize),this.weightsHiddenOutput=heInit(this.hiddenSize,this.outputSize);break;case o.XAVIER:this.weightsInputHidden=xavierInit(this.inputSize,this.hiddenSize),this.weightsHiddenOutput=xavierInit(this.hiddenSize,this.outputSize);break;default:throw new Error(`Unknown initialization method: ${this.initMethod}`)}this.biasHidden=new Float32Array(this.hiddenSize);for(let e=0;e<this.hiddenSize;e++)this.biasHidden[e]=.01;this.biasOutput=zeroInit(this.outputSize)}getMemoryUsage(){if(!this.isInitialized)return{totalBytes:0,breakdown:{}};const e={weightsInputHidden:4*this.weightsInputHidden.length,biasHidden:4*this.biasHidden.length,weightsHiddenOutput:4*this.weightsHiddenOutput.length,biasOutput:4*this.biasOutput.length,hiddenActivation:4*this.hiddenActivation.length,outputActivation:4*this.outputActivation.length},t=Object.values(e).reduce((e,t)=>e+t,0);return{totalBytes:t,totalKB:t/1024,breakdown:e,parameterBytes:4*this.parameterCount,parameterKB:4*this.parameterCount/1024}}clone(){const e=new CPUBackend;if(this.isInitialized){const t="imported"===this.initMethod?o.HE:this.initMethod;e.createNetwork(this.inputSize,this.hiddenSize,this.outputSize,{initMethod:t}),e.setWeights(this.getWeights())}return e}resetWeights(){if(!this.isInitialized)throw new Error("Network not initialized");const e=this.initMethod;("imported"===this.initMethod||!this.initMethod||this.initMethod!==o.HE&&this.initMethod!==o.XAVIER)&&(this.initMethod=o.HE),this._initializeWeights(),this.initMethod=e}_validateVariableArchitecture(e,t,i){if(e<2||e>16)throw new Error(`Input size must be between 2 and 16 (for 1-8 timesteps), got ${e}`);if(e%2!=0)throw new Error(`Input size must be even (pairs of values), got ${e}`);if(i!==s)throw new Error(`Output size must be ${s}, got ${i}`);if(t<a||t>r)throw new Error(`Hidden size must be between ${a} and ${r}, got ${t}`);const o=calculateParameterCount(e,t,i);if(o>n)throw new Error(`Parameter count ${o} exceeds maximum ${n}`)}}class Hyperparameters{static{__name(this,"Hyperparameters")}constructor(e={}){this.learningRate=this._validateParameter(e.learningRate,3e-4,1e-4,.01,"learningRate"),this.gamma=this._validateParameter(e.gamma,.99,.9,.999,"gamma"),this.epsilon=this._validateParameter(e.epsilon,.9,0,1,"epsilon"),this.epsilonMin=this._validateParameter(e.epsilonMin,.01,0,.1,"epsilonMin"),this.epsilonDecay=this._validateParameter(e.epsilonDecay,2500,1e3,1e4,"epsilonDecay"),this.batchSize=this._validateParameter(e.batchSize,128,16,256,"batchSize"),this.targetUpdateFreq=this._validateParameter(e.targetUpdateFreq,100,10,1e3,"targetUpdateFreq"),this.maxEpisodes=this._validateParameter(e.maxEpisodes,1e3,10,1e4,"maxEpisodes"),this.maxStepsPerEpisode=this._validateParameter(e.maxStepsPerEpisode,8e3,50,5e4,"maxStepsPerEpisode"),this.convergenceWindow=this._validateParameter(e.convergenceWindow,100,10,500,"convergenceWindow"),this.convergenceThreshold=this._validateParameter(e.convergenceThreshold,200,50,1e3,"convergenceThreshold"),this.hiddenSize=this._validateParameter(e.hiddenSize,128,64,256,"hiddenSize")}_validateParameter(e,t,i,s,a){return null==e||"number"!=typeof e||isNaN(e)?t:e<i||e>s?Math.max(i,Math.min(s,e)):e}clone(){return new Hyperparameters({learningRate:this.learningRate,gamma:this.gamma,epsilon:this.epsilon,epsilonMin:this.epsilonMin,epsilonDecay:this.epsilonDecay,batchSize:this.batchSize,targetUpdateFreq:this.targetUpdateFreq,maxEpisodes:this.maxEpisodes,maxStepsPerEpisode:this.maxStepsPerEpisode,convergenceWindow:this.convergenceWindow,convergenceThreshold:this.convergenceThreshold,hiddenSize:this.hiddenSize})}}class ReplayBuffer{static{__name(this,"ReplayBuffer")}constructor(e=1e4){this.maxSize=e,this.buffer=[],this.index=0}add(e,t,i,s,a){if(e.length!==s.length)throw new Error(`State size mismatch: current=${e.length}, next=${s.length}`);const r={state:new Float32Array(e),action:t,reward:i,nextState:new Float32Array(s),done:a,stateSize:e.length};this.buffer.length<this.maxSize?this.buffer.push(r):this.buffer[this.index]=r,this.index=(this.index+1)%this.maxSize}sample(e){if(this.buffer.length<e)return this.buffer.slice();const t=[],i=new Set;for(;t.length<e;){const e=Math.floor(Math.random()*this.buffer.length);i.has(e)||(i.add(e),t.push(this.buffer[e]))}return t}size(){return this.buffer.length}clear(){this.buffer=[],this.index=0}}class TrainingMetrics{static{__name(this,"TrainingMetrics")}constructor(){this.reset()}reset(){this.episodeRewards=[],this.episodeLengths=[],this.losses=[],this.epsilonHistory=[],this.startTime=Date.now(),this.totalSteps=0,this.bestReward=-1/0,this.converged=!1,this.convergenceEpisode=null}addEpisode(e,t,i,s){this.episodeRewards.push(e),this.episodeLengths.push(t),this.losses.push(i),this.epsilonHistory.push(s),this.totalSteps+=t,e>this.bestReward&&(this.bestReward=e)}getAverageReward(e=100){const t=Math.max(0,this.episodeRewards.length-e),i=this.episodeRewards.slice(t);return i.reduce((e,t)=>e+t,0)/i.length}getAverageLength(e=100){const t=Math.max(0,this.episodeLengths.length-e),i=this.episodeLengths.slice(t);return i.reduce((e,t)=>e+t,0)/i.length}getTrainingTime(){return(Date.now()-this.startTime)/1e3}checkConvergence(e,t){if(this.episodeRewards.length<t)return!1;return this.getAverageReward(t)>=e&&!this.converged?(this.converged=!0,this.convergenceEpisode=this.episodeRewards.length,!0):this.converged}getSummary(){const e=this.episodeRewards.length,t=e>0?this.getAverageReward():0,i=e>0?this.getAverageLength():0,s=this.losses.length>0?this.losses.reduce((e,t)=>e+t,0)/this.losses.length:0;return{episodes:e,totalSteps:this.totalSteps,averageReward:t,bestReward:this.bestReward,averageLength:i,averageLoss:s,trainingTime:this.getTrainingTime(),converged:this.converged,convergenceEpisode:this.convergenceEpisode,currentEpsilon:this.epsilonHistory[this.epsilonHistory.length-1]||0}}}class QLearning{static{__name(this,"QLearning")}constructor(e={}){this.hyperparams=new Hyperparameters(e),this.metrics=new TrainingMetrics,this.replayBuffer=new ReplayBuffer(1e4),this.qNetwork=null,this.targetNetwork=null,this.isInitialized=!1,this.episode=0,this.stepCount=0,this.globalStepCount=0,this.lastTargetUpdate=0,this.consecutiveMaxEpisodes=0,this.trainingCompleted=!1,this.actions=[-1,0,1],this.numActions=this.actions.length}async initialize(e=i){try{this.qNetwork=new CPUBackend,await this.qNetwork.createNetwork(e,this.hyperparams.hiddenSize,this.numActions,{initMethod:o.HE}),this.targetNetwork=this.qNetwork.clone(),this.isInitialized=!0}catch(t){throw t}}selectAction(e,t=!0){if(!this.isInitialized)throw new Error("Q-Learning not initialized. Call initialize() first.");if(!(e instanceof Float32Array))throw new Error("Invalid state input. Expected Float32Array");const i=this.qNetwork.getArchitecture().inputSize;if(e.length!==i)throw new Error(`Invalid state input size. Expected ${i}, got ${e.length}`);if(t&&Math.random()<this.hyperparams.epsilon)return Math.floor(Math.random()*this.numActions);{const t=this.qNetwork.forward(e);return this._argmax(t)}}train(e,t,i,s,a){if(!this.isInitialized)throw new Error("Q-Learning not initialized. Call initialize() first.");return this.globalStepCount++,this._updateEpsilon(),this.replayBuffer.add(e,t,i,s,a),this.replayBuffer.size()>=this.hyperparams.batchSize?this._trainBatch():0}_updateEpsilon(){if(this.globalStepCount<this.hyperparams.epsilonDecay){this.initialEpsilon||(this.initialEpsilon=this.hyperparams.epsilon);const e=this.initialEpsilon,t=this.hyperparams.epsilonMin,i=this.globalStepCount/this.hyperparams.epsilonDecay;this.hyperparams.epsilon=e+i*(t-e)}else this.hyperparams.epsilon=this.hyperparams.epsilonMin}_trainBatch(){const e=this.replayBuffer.sample(this.hyperparams.batchSize);let t=0;if(this.stepCount%50==0){const e=this.qNetwork.getWeights().weightsHiddenOutput;Math.sqrt(e.reduce((e,t)=>e+t*t,0)/e.length)}for(const i of e){const{state:s,action:a,reward:r,nextState:n,done:o}=i,h=this.qNetwork.forward(s)[a];let l;if(o)l=r;else{const e=this.targetNetwork.forward(n),t=Math.max(...e);l=r+this.hyperparams.gamma*t}let d=l-h;d=Math.max(-5,Math.min(5,d)),this.stepCount%50==0&&e[0];t+=this._updateNetwork(s,a,d)}return this.stepCount++,this.stepCount-this.lastTargetUpdate>=this.hyperparams.targetUpdateFreq&&(this._updateTargetNetwork(),this.lastTargetUpdate=this.stepCount),t/e.length}_updateNetwork(e,t,i){const s=this.hyperparams.learningRate,a=this.qNetwork.getWeights(),r=this._getHiddenActivation(e),n=Math.abs(i),o=n<=1?.5*i*i:1*(n-.5),h=a.weightsHiddenOutput;for(let u=0;u<r.length;u++){const e=u*this.numActions+t;let a=i*r[u];a=Math.max(-.5,Math.min(.5,a)),h[e]+=s*a,h[e]=Math.max(-10,Math.min(10,h[e]))}let l=Math.max(-.5,Math.min(.5,i));a.biasOutput[t]+=s*l,a.biasOutput[t]=Math.max(-10,Math.min(10,a.biasOutput[t]));const d=a.weightsInputHidden,c=a.biasHidden;for(let u=0;u<r.length;u++){const a=r[u]>0?1:0,n=i*h[u*this.numActions+t]*a;for(let t=0;t<e.length;t++){const i=t*r.length+u;let a=n*e[t];a=Math.max(-.5,Math.min(.5,a)),d[i]+=s*a,d[i]=Math.max(-10,Math.min(10,d[i]))}let o=Math.max(-.5,Math.min(.5,n));c[u]+=s*o,c[u]=Math.max(-10,Math.min(10,c[u]))}return this.qNetwork.setWeights(a),o}_getHiddenActivation(e){return this.qNetwork.forward(e),this.qNetwork.getHiddenActivations()}_updateTargetNetwork(){const e=this.qNetwork.getWeights();this.targetNetwork.setWeights(e)}runEpisode(e,t=!1){if(!this.isInitialized)throw new Error("Q-Learning not initialized. Call initialize() first.");e.reset();let i=e.getNormalizedInputs(),s=0,a=0,r=0,n=0;for(let h=0;h<this.hyperparams.maxStepsPerEpisode;h++){const t=this.selectAction(i,!0),o=this.actions[t],h=e.step(o),l=e.getNormalizedInputs(),d=h.reward,c=h.done,u=this.train(i,t,d,l,c);if(u>0&&(r+=u,n++),s+=d,a++,c)break;i=l}this.episode++;const o=n>0?r/n:0;return a>=this.hyperparams.maxStepsPerEpisode?this.consecutiveMaxEpisodes++:this.consecutiveMaxEpisodes=0,this.metrics.addEpisode(s,a,o,this.hyperparams.epsilon),{episode:this.episode,reward:s,steps:a,loss:o,epsilon:this.hyperparams.epsilon,consecutiveMaxEpisodes:this.consecutiveMaxEpisodes,trainingCompleted:this.trainingCompleted}}async runTraining(e,t={}){const i=t.verbose||!1,s=t.saveInterval||100,a=t.onEpisodeEnd||null;this.metrics.reset();for(let r=0;r<this.hyperparams.maxEpisodes;r++){const n=this.runEpisode(e,i),o=this.metrics.checkConvergence(this.hyperparams.convergenceThreshold,this.hyperparams.convergenceWindow);if(o&&this.metrics.converged,i&&(r+1)%s===0){this.metrics.getSummary()}if(a&&a(n,this.metrics.getSummary()),t.earlyStop&&o)break}this.metrics.getSummary();return this.metrics}evaluate(e,t=10){if(!this.isInitialized)throw new Error("Q-Learning not initialized. Call initialize() first.");const i=this.hyperparams.epsilon;this.hyperparams.epsilon=0;const s=[];for(let n=0;n<t;n++){e.reset();let t=e.getNormalizedInputs(),i=0,a=0;for(let s=0;s<this.hyperparams.maxStepsPerEpisode;s++){const s=this.selectAction(t,!1),r=this.actions[s],n=e.step(r),o=e.getNormalizedInputs();if(i+=n.reward,a++,n.done)break;t=o}s.push({reward:i,steps:a})}this.hyperparams.epsilon=i;const a=s.reduce((e,t)=>e+t.reward,0)/s.length,r=s.reduce((e,t)=>e+t.steps,0)/s.length;return{episodes:t,averageReward:a,bestReward:Math.max(...s.map(e=>e.reward)),worstReward:Math.min(...s.map(e=>e.reward)),averageSteps:r,results:s}}getQValue(e,t){if(!this.isInitialized)throw new Error("Q-Learning not initialized. Call initialize() first.");return this.qNetwork.forward(e)[t]}getAllQValues(e){if(!this.isInitialized)throw new Error("Q-Learning not initialized. Call initialize() first.");return this.qNetwork.forward(e)}save(){if(!this.isInitialized)throw new Error("Q-Learning not initialized. Call initialize() first.");return{hyperparams:this.hyperparams,qNetworkWeights:this.qNetwork.getWeights(),targetNetworkWeights:this.targetNetwork.getWeights(),episode:this.episode,stepCount:this.stepCount,metrics:this.metrics.getSummary(),actions:this.actions}}async load(e){const t=e.qNetworkWeights?.architecture;if(!t)throw new Error("Invalid model data: missing architecture information");if(this.isInitialized){const e=this.qNetwork.getArchitecture();e.inputSize===t.inputSize&&e.hiddenSize===t.hiddenSize&&e.outputSize===t.outputSize||(this.isInitialized=!1,this.qNetwork=null,this.targetNetwork=null)}this.hyperparams=new Hyperparameters({...e.hyperparams,hiddenSize:t.hiddenSize}),this.episode=e.episode||0,this.stepCount=e.stepCount||0,this.actions=e.actions||[-1,0,1],this.numActions=this.actions.length,this.isInitialized||await this.initialize(t.inputSize),this.qNetwork.setWeights(e.qNetworkWeights),this.targetNetwork.setWeights(e.targetNetworkWeights)}reset(){this.metrics.reset(),this.replayBuffer.clear(),this.episode=0,this.stepCount=0,this.globalStepCount=0,this.lastTargetUpdate=0,this.consecutiveMaxEpisodes=0,this.trainingCompleted=!1,this.initialEpsilon=null,this.isInitialized&&(this.qNetwork.resetWeights(),this.targetNetwork=this.qNetwork.clone())}getStats(){return{...this.metrics.getSummary(),replayBufferSize:this.replayBuffer.size(),stepCount:this.stepCount,lastTargetUpdate:this.lastTargetUpdate,networkParameters:this.isInitialized?this.qNetwork.getParameterCount():0,consecutiveMaxEpisodes:this.consecutiveMaxEpisodes,trainingCompleted:this.trainingCompleted}}_argmax(e){let t=0,i=e[0];for(let s=1;s<e.length;s++)e[s]>i&&(i=e[s],t=s);return t}}function createDefaultQLearning(e={}){return new QLearning(e)}__name(createDefaultQLearning,"createDefaultQLearning");class ShaderManager{static{__name(this,"ShaderManager")}constructor(e){this.device=e,this.shaderModules=new Map,this.computePipelines=new Map,this.bindGroupLayouts=new Map,this.uniformBuffers=new Map,this.storageBuffers=new Map,this.shaderSources=new Map,this.compilationTimes=new Map,this.pipelineCreationTimes=new Map}async loadShaders(){const e=performance.now();try{await this._loadShaderSources(),await this._compileShaderModules(),await this._createComputePipelines();performance.now()}catch(t){throw t}}async _loadShaderSources(){const e=Object.entries({matmul:"./shaders/matmul.wgsl",relu:"./shaders/relu.wgsl",qlearning:"./shaders/qlearning.wgsl"}).map(async([e,t])=>{try{const i=await fetch(t);if(!i.ok)throw new Error(`Failed to load shader ${e}: ${i.statusText}`);const s=await i.text();this.shaderSources.set(e,s)}catch(i){this.shaderSources.set(e,this._getInlineShaderSource(e))}});await Promise.all(e)}_getInlineShaderSource(e){return{matmul:"\n                @group(0) @binding(0) var<storage, read> matrixA: array<f32>;\n                @group(0) @binding(1) var<storage, read> matrixB: array<f32>;\n                @group(0) @binding(2) var<storage, read> bias: array<f32>;\n                @group(0) @binding(3) var<storage, read_write> matrixC: array<f32>;\n                @group(0) @binding(4) var<uniform> params: vec4<u32>;\n                \n                @compute @workgroup_size(64, 1, 1)\n                fn matmul_simple(@builtin(global_invocation_id) global_id: vec3<u32>) {\n                    let index = global_id.x;\n                    let M = params.x;\n                    let K = params.y;\n                    let N = params.z;\n                    \n                    if (index >= M * N) { return; }\n                    \n                    let row = index / N;\n                    let col = index % N;\n                    \n                    var sum: f32 = 0.0;\n                    for (var k: u32 = 0u; k < K; k++) {\n                        sum += matrixA[row * K + k] * matrixB[k * N + col];\n                    }\n                    \n                    matrixC[index] = sum + bias[col];\n                }\n            ",relu:"\n                @group(0) @binding(0) var<storage, read> input_data: array<f32>;\n                @group(0) @binding(1) var<storage, read_write> output_data: array<f32>;\n                @group(0) @binding(2) var<uniform> params: vec4<u32>;\n                \n                @compute @workgroup_size(64, 1, 1)\n                fn relu(@builtin(global_invocation_id) global_id: vec3<u32>) {\n                    let index = global_id.x;\n                    let size = params.x;\n                    \n                    if (index >= size) { return; }\n                    \n                    output_data[index] = max(0.0, input_data[index]);\n                }\n            ",qlearning:"\n                @group(0) @binding(0) var<storage, read> q_values: array<f32>;\n                @group(0) @binding(1) var<storage, read> target_q_values: array<f32>;\n                @group(0) @binding(2) var<storage, read> actions: array<u32>;\n                @group(0) @binding(3) var<storage, read_write> td_errors: array<f32>;\n                @group(0) @binding(4) var<uniform> params: vec4<f32>;\n                \n                @compute @workgroup_size(32, 1, 1)\n                fn compute_td_errors(@builtin(global_invocation_id) global_id: vec3<u32>) {\n                    let batch_idx = global_id.x;\n                    let batch_size = u32(params.x);\n                    let gamma = params.y;\n                    \n                    if (batch_idx >= batch_size) { return; }\n                    \n                    let action = actions[batch_idx];\n                    let current_q = q_values[batch_idx * 3u + action];\n                    let target_q = target_q_values[batch_idx * 3u + action];\n                    \n                    td_errors[batch_idx] = target_q - current_q;\n                }\n            "}[e]||""}async _compileShaderModules(){for(const[t,i]of this.shaderSources){const s=performance.now();try{const e=this.device.createShaderModule({label:`${t}_shader`,code:i}),a=await e.getCompilationInfo();if(a.messages.length>0){const e=a.messages.filter(e=>"error"===e.type);if(e.length>0)throw new Error(`Shader ${t} compilation failed: ${e.map(e=>e.message).join(", ")}`)}this.shaderModules.set(t,e);const r=performance.now()-s;this.compilationTimes.set(t,r)}catch(e){throw e}}}async _createComputePipelines(){await this._createMatMulPipelines(),await this._createActivationPipelines(),await this._createQLearningPipelines()}async _createMatMulPipelines(){const e=this.shaderModules.get("matmul");if(!e)throw new Error("Matrix multiplication shader module not found");const t=this.device.createBindGroupLayout({label:"matmul_bind_group_layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]});this.bindGroupLayouts.set("matmul",t);const i=this.device.createPipelineLayout({label:"matmul_pipeline_layout",bindGroupLayouts:[t]}),s=["main","matmul_simple","matmul_batch"];for(const r of s)try{const t=this.device.createComputePipeline({label:`matmul_${r}_pipeline`,layout:i,compute:{module:e,entryPoint:r}});this.computePipelines.set(`matmul_${r}`,t)}catch(a){}}async _createActivationPipelines(){const e=this.shaderModules.get("relu");if(!e)throw new Error("ReLU shader module not found");const t=this.device.createBindGroupLayout({label:"activation_bind_group_layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]});this.bindGroupLayouts.set("activation",t);const i=this.device.createPipelineLayout({label:"activation_pipeline_layout",bindGroupLayouts:[t]}),s=["relu","leaky_relu","relu_derivative","relu_inplace","softmax"];for(const r of s)try{const t=this.device.createComputePipeline({label:`${r}_pipeline`,layout:i,compute:{module:e,entryPoint:r}});this.computePipelines.set(r,t)}catch(a){}}async _createQLearningPipelines(){const e=this.shaderModules.get("qlearning");if(!e)throw new Error("Q-learning shader module not found");const t=this.device.createBindGroupLayout({label:"qlearning_bind_group_layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:5,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:6,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:7,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:8,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:9,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:10,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:11,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:12,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]});this.bindGroupLayouts.set("qlearning",t);const i=this.device.createPipelineLayout({label:"qlearning_pipeline_layout",bindGroupLayouts:[t]}),s=["compute_td_errors","update_output_weights","update_output_bias","update_hidden_weights","update_hidden_bias"];for(const r of s)try{const t=this.device.createComputePipeline({label:`qlearning_${r}_pipeline`,layout:i,compute:{module:e,entryPoint:r}});this.computePipelines.set(`qlearning_${r}`,t)}catch(a){}}getPipeline(e){const t=this.computePipelines.get(e);if(!t)throw new Error(`Pipeline ${e} not found. Available pipelines: ${Array.from(this.computePipelines.keys()).join(", ")}`);return t}getBindGroupLayout(e){const t=this.bindGroupLayouts.get(e);if(!t)throw new Error(`Bind group layout ${e} not found. Available layouts: ${Array.from(this.bindGroupLayouts.keys()).join(", ")}`);return t}getPerformanceMetrics(){return{totalCompilationTime:Array.from(this.compilationTimes.values()).reduce((e,t)=>e+t,0),totalPipelineTime:Array.from(this.pipelineCreationTimes.values()).reduce((e,t)=>e+t,0),shadersCompiled:this.shaderModules.size,pipelinesCreated:this.computePipelines.size,compilationTimes:Object.fromEntries(this.compilationTimes),pipelineCreationTimes:Object.fromEntries(this.pipelineCreationTimes),availablePipelines:Array.from(this.computePipelines.keys()),availableLayouts:Array.from(this.bindGroupLayouts.keys())}}validateShaders(){const e={allShadersCompiled:!0,missingShaders:[],availableShaders:Array.from(this.shaderModules.keys()),availablePipelines:Array.from(this.computePipelines.keys())},t=["matmul","relu","qlearning"];for(const i of t)this.shaderModules.has(i)||(e.allShadersCompiled=!1,e.missingShaders.push(i));return e.allPipelinesCreated=["matmul_simple","relu","qlearning_compute_td_errors"].every(e=>this.computePipelines.has(e)),e}destroy(){this.shaderModules.clear(),this.computePipelines.clear(),this.bindGroupLayouts.clear(),this.shaderSources.clear(),this.compilationTimes.clear(),this.pipelineCreationTimes.clear()}}const l={STORAGE_READ_WRITE:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,STORAGE_READ_ONLY:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,STORAGE_WRITE_ONLY:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC,UNIFORM:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,STAGING_UPLOAD:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,STAGING_DOWNLOAD:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST,VERTEX:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,INDEX:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST};class BufferManager{static{__name(this,"BufferManager")}constructor(e,t={}){this.device=e,this.isDestroyed=!1,this.config={maxBufferSize:t.maxBufferSize||67108864,maxTotalMemory:t.maxTotalMemory||536870912,alignment:t.alignment||256,poolEnabled:!1!==t.poolEnabled,poolMaxAge:t.poolMaxAge||3e4,poolMaxSize:t.poolMaxSize||50,asyncTimeout:t.asyncTimeout||1e4,enableValidation:!1!==t.enableValidation,enableProfiling:!1!==t.enableProfiling},this.buffers=new Map,this.bindGroups=new Map,this.bufferMetadata=new Map,this.bufferPools=new Map,this.poolStats={hits:0,misses:0,evictions:0,totalReused:0},this.memoryUsage={totalAllocated:0,totalActive:0,totalPooled:0,bufferCount:0,pooledCount:0},this.performanceMetrics={bufferCreationTimes:[],memoryTransferTimes:[],mappingTimes:[],asyncOperationTimes:[],errorCount:0,warningCount:0},this.pendingOperations=new Map,this.operationCounter=0,this.validationEnabled=this.config.enableValidation,this.errorLog=[],this.bufferTypeStats=new Map,this._setupPoolCleanup()}async createBuffer(e,t,i,s={}){this._validateNotDestroyed();const{label:a="unnamed_buffer",allowReuse:r=!0,persistent:n=!1}=s,o=performance.now();try{let s,h=null;if("number"==typeof t)s=t;else if(t instanceof ArrayBuffer)s=t.byteLength,h=new Uint8Array(t);else{if(!ArrayBuffer.isView(t))throw new Error("Data must be ArrayBuffer, TypedArray, or number (size)");s=t.byteLength,h=new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}this._validateBufferSize(s,a);const l=this._alignSize(s);let d=null;r&&this.config.poolEnabled&&(d=this._getBufferFromPool(l,i)),d?(this.poolStats.hits++,this.poolStats.totalReused++):(this._validateMemoryLimit(l),d=e.createBuffer({label:`enhanced_${a}`,size:l,usage:i}),this.poolStats.misses++,this._updateMemoryUsage(l,"allocate")),h&&await this.updateBuffer(e.queue,d,h,0,{label:a}),this._trackBufferMetadata(d,{label:a,size:l,usage:i,persistent:n,createdAt:Date.now(),accessCount:0});const c=performance.now()-o;return this.performanceMetrics.bufferCreationTimes.push(c),d}catch(h){throw this._handleError(`Failed to create buffer ${a}`,h),h}}async updateBuffer(e,t,i,s=0,a={}){this._validateNotDestroyed();const{label:r="buffer_update",useStaging:n=!1}=a,o=performance.now(),h=this._generateOperationId();try{let a;if(i instanceof ArrayBuffer)a=new Uint8Array(i);else{if(!ArrayBuffer.isView(i))throw new Error("Data must be ArrayBuffer or TypedArray");a=new Uint8Array(i.buffer,i.byteOffset,i.byteLength)}this._validateBufferUpdate(t,a,s),this.pendingOperations.set(h,{type:"update",buffer:t,size:a.length,startTime:o}),n&&a.length>65536?await this._updateBufferStaging(e,t,a,s,r):e.writeBuffer(t,s,a),this._updateBufferAccess(t);const l=performance.now()-o;this.performanceMetrics.memoryTransferTimes.push(l),this.config.enableProfiling}catch(l){throw this._handleError(`Failed to update buffer ${r}`,l),l}finally{this.pendingOperations.delete(h)}}async readBuffer(e,t,i,s=0,a={}){this._validateNotDestroyed();const{label:r="buffer_read",timeout:n=this.config.asyncTimeout}=a,o=performance.now(),h=this._generateOperationId();try{this._validateBufferRead(t,i,s),this.pendingOperations.set(h,{type:"read",buffer:t,size:i,startTime:o});const a=await this.createBuffer(e,i,l.STAGING_DOWNLOAD,{label:`staging_${r}_read`,allowReuse:!0}),d=e.createCommandEncoder({label:`copy_${r}_to_staging`});d.copyBufferToBuffer(t,s,a,0,i);const c=d.finish();e.queue.submit([c]);const u=a.mapAsync(GPUMapMode.READ),p=new Promise((e,t)=>{setTimeout(()=>t(new Error(`Buffer read timeout after ${n}ms`)),n)});await Promise.race([u,p]);const m=performance.now(),g=a.getMappedRange().slice();a.unmap();const f=performance.now()-m;this.performanceMetrics.mappingTimes.push(f),this._returnBufferToPool(a,i,l.STAGING_DOWNLOAD),this._updateBufferAccess(t);const b=performance.now()-o;return this.performanceMetrics.memoryTransferTimes.push(b),this.performanceMetrics.asyncOperationTimes.push(b),this.config.enableProfiling,g}catch(d){throw this._handleError(`Failed to read buffer ${r}`,d),d}finally{this.pendingOperations.delete(h)}}async createNetworkBuffers(e,t={}){const{inputSize:i,hiddenSize:s,outputSize:a,batchSize:r=1}=e,{persistent:n=!1,allowReuse:o=!0}=t,h={},d=performance.now();try{const t=this._calculateBufferSizes(e);h.input=await this.createBuffer(this.device,t.input,l.STORAGE_READ_ONLY,{label:"neural_input",persistent:n,allowReuse:o}),h.hidden=await this.createBuffer(this.device,t.hidden,l.STORAGE_READ_WRITE,{label:"neural_hidden",persistent:n,allowReuse:o}),h.output=await this.createBuffer(this.device,t.output,l.STORAGE_WRITE_ONLY,{label:"neural_output",persistent:n,allowReuse:o}),h.weightsHidden=await this.createBuffer(this.device,t.weightsHidden,l.STORAGE_READ_WRITE,{label:"weights_hidden",persistent:!0,allowReuse:o}),h.weightsOutput=await this.createBuffer(this.device,t.weightsOutput,l.STORAGE_READ_WRITE,{label:"weights_output",persistent:!0,allowReuse:o}),h.biasHidden=await this.createBuffer(this.device,t.biasHidden,l.STORAGE_READ_WRITE,{label:"bias_hidden",persistent:!0,allowReuse:o}),h.biasOutput=await this.createBuffer(this.device,t.biasOutput,l.STORAGE_READ_WRITE,{label:"bias_output",persistent:!0,allowReuse:o}),h.matmulParams=await this.createBuffer(this.device,16,l.UNIFORM,{label:"matmul_params",persistent:n,allowReuse:o}),h.activationParams=await this.createBuffer(this.device,16,l.UNIFORM,{label:"activation_params",persistent:n,allowReuse:o}),h.stagingInput=await this.createBuffer(this.device,t.input,l.STAGING_UPLOAD,{label:"staging_input",persistent:!1,allowReuse:!0}),h.stagingOutput=await this.createBuffer(this.device,t.output,l.STAGING_DOWNLOAD,{label:"staging_output",persistent:!1,allowReuse:!0}),r>1&&(h.qValues=await this.createBuffer(this.device,t.qValues,l.STORAGE_READ_WRITE,{label:`q_values_batch_${r}`,persistent:n,allowReuse:o}),h.targetQValues=await this.createBuffer(this.device,t.qValues,l.STORAGE_READ_WRITE,{label:`target_q_values_batch_${r}`,persistent:n,allowReuse:o}),h.actions=await this.createBuffer(this.device,4*r,l.STORAGE_READ_ONLY,{label:`actions_batch_${r}`,persistent:n,allowReuse:o}),h.rewards=await this.createBuffer(this.device,4*r,l.STORAGE_READ_ONLY,{label:`rewards_batch_${r}`,persistent:n,allowReuse:o}),h.dones=await this.createBuffer(this.device,4*r,l.STORAGE_READ_ONLY,{label:`dones_batch_${r}`,persistent:n,allowReuse:o}),h.tdErrors=await this.createBuffer(this.device,4*r,l.STORAGE_WRITE_ONLY,{label:`td_errors_batch_${r}`,persistent:n,allowReuse:o}),h.qlearningParams=await this.createBuffer(this.device,32,l.UNIFORM,{label:`qlearning_params_batch_${r}`,persistent:n,allowReuse:o})),Object.entries(h).forEach(([e,t])=>{this.buffers.set(e,t)});performance.now(),Object.keys(h).length,this.memoryUsage.totalAllocated;return h}catch(c){throw this._handleError("Failed to create network buffers",c),c}}_calculateBufferSizes(e){const{inputSize:t,hiddenSize:i,outputSize:s,batchSize:a=1}=e;if(!(t&&i&&s&&a))throw new Error("Invalid architecture: all sizes must be positive");const r={};r.input=this._alignSize(a*t*4),r.hidden=this._alignSize(a*i*4),r.output=this._alignSize(a*s*4),r.weightsHidden=this._alignSize(t*i*4),r.weightsOutput=this._alignSize(i*s*4),r.biasHidden=this._alignSize(4*i),r.biasOutput=this._alignSize(4*s),r.qValues=this._alignSize(a*s*4);const n=Object.values(r).reduce((e,t)=>e+t,0);if(this.validationEnabled&&n>this.config.maxTotalMemory)throw new Error(`Total buffer memory ${this._formatBytes(n)} exceeds limit ${this._formatBytes(this.config.maxTotalMemory)}`);return Object.entries(r).forEach(([e,t])=>{}),r}_alignSize(e){return Math.ceil(e/this.alignment)*this.alignment}_createBuffer(e,t,i){const s=performance.now();if(t>this.maxBufferSize)throw new Error(`Buffer ${e} size ${t} exceeds maximum ${this.maxBufferSize}`);const a=this.device.createBuffer({label:`neural_network_${e}`,size:t,usage:i});this.buffers.set(e,a),this.bufferSizes.set(e,t),this.totalMemoryUsed+=t;const r=performance.now()-s;return this.bufferCreationTimes.push(r),a}createBindGroups(e,t){const i={};return i.matmul=this.device.createBindGroup({label:"matmul_bind_group",layout:t.matmul,entries:[{binding:0,resource:{buffer:e.input}},{binding:1,resource:{buffer:e.weightsHidden}},{binding:2,resource:{buffer:e.biasHidden}},{binding:3,resource:{buffer:e.hidden}},{binding:4,resource:{buffer:e.matmulParams}}]}),i.activation=this.device.createBindGroup({label:"activation_bind_group",layout:t.activation,entries:[{binding:0,resource:{buffer:e.hidden}},{binding:1,resource:{buffer:e.hidden}},{binding:2,resource:{buffer:e.activationParams}}]}),i.output=this.device.createBindGroup({label:"output_bind_group",layout:t.matmul,entries:[{binding:0,resource:{buffer:e.hidden}},{binding:1,resource:{buffer:e.weightsOutput}},{binding:2,resource:{buffer:e.biasOutput}},{binding:3,resource:{buffer:e.output}},{binding:4,resource:{buffer:e.matmulParams}}]}),e.qValues&&(i.qlearning=this.device.createBindGroup({label:"qlearning_bind_group",layout:t.qlearning,entries:[{binding:0,resource:{buffer:e.qValues}},{binding:1,resource:{buffer:e.targetQValues}},{binding:2,resource:{buffer:e.actions}},{binding:3,resource:{buffer:e.rewards}},{binding:4,resource:{buffer:e.dones}},{binding:5,resource:{buffer:e.hidden}},{binding:6,resource:{buffer:e.input}},{binding:7,resource:{buffer:e.weightsHidden}},{binding:8,resource:{buffer:e.biasHidden}},{binding:9,resource:{buffer:e.weightsOutput}},{binding:10,resource:{buffer:e.biasOutput}},{binding:11,resource:{buffer:e.tdErrors}},{binding:12,resource:{buffer:e.qlearningParams}}]})),Object.entries(i).forEach(([e,t])=>{this.bindGroups.set(e,t)}),i}async uploadData(e,t,i=0){const s=performance.now(),a=this.buffers.get(e);if(!a)throw new Error(`Buffer ${e} not found`);let r;if(t instanceof ArrayBuffer)r=new Uint8Array(t);else{if(!ArrayBuffer.isView(t))throw new Error("Data must be ArrayBuffer or TypedArray");r=new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}this.device.queue.writeBuffer(a,i,r);const n=performance.now()-s;this.memoryTransferTimes.push(n)}async downloadData(e,t,i=0){const s=performance.now(),a=this.buffers.get(e);if(!a)throw new Error(`Buffer ${e} not found`);const r=this.device.createBuffer({label:`staging_${e}_read`,size:t,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),n=this.device.createCommandEncoder({label:`copy_${e}_to_staging`});n.copyBufferToBuffer(a,i,r,0,t);const o=n.finish();this.device.queue.submit([o]),await r.mapAsync(GPUMapMode.READ);const h=r.getMappedRange().slice();r.unmap(),r.destroy();const l=performance.now()-s;return this.memoryTransferTimes.push(l),h}updateUniformBuffer(e,t){const i=this.buffers.get(e);if(!i)throw new Error(`Uniform buffer ${e} not found`);let s;if("matmulParams"===e)s=new Uint32Array([t.M||0,t.K||0,t.N||0,0]);else if("activationParams"===e)s=new Uint32Array([t.size||0,0,0,0]);else{if("qlearningParams"!==e)throw new Error(`Unknown uniform buffer format for ${e}`);s=new Float32Array([t.batch_size||1,t.input_size||2,t.hidden_size||8,t.output_size||3,t.learning_rate||.01,t.gamma||.99,t.epsilon||1e-8,t.clip_grad_norm||1])}this.device.queue.writeBuffer(i,0,s)}getBuffer(e){const t=this.buffers.get(e);if(!t)throw new Error(`Buffer ${e} not found. Available buffers: ${Array.from(this.buffers.keys()).join(", ")}`);return t}getBindGroup(e){const t=this.bindGroups.get(e);if(!t)throw new Error(`Bind group ${e} not found. Available bind groups: ${Array.from(this.bindGroups.keys()).join(", ")}`);return t}getMemoryUsage(){const e=Array.from(this.buffers.entries()).map(([e,t])=>({name:e,size:this.bufferSizes.get(e),sizeFormatted:this._formatBytes(this.bufferSizes.get(e))})),t=this.bufferCreationTimes.length>0?this.bufferCreationTimes.reduce((e,t)=>e+t)/this.bufferCreationTimes.length:0,i=this.memoryTransferTimes.length>0?this.memoryTransferTimes.reduce((e,t)=>e+t)/this.memoryTransferTimes.length:0;return{totalMemoryUsed:this.totalMemoryUsed,totalMemoryFormatted:this._formatBytes(this.totalMemoryUsed),bufferCount:this.buffers.size,bindGroupCount:this.bindGroups.size,bufferInfo:e,performance:{avgCreationTime:t.toFixed(2)+"ms",avgTransferTime:i.toFixed(2)+"ms",totalCreations:this.bufferCreationTimes.length,totalTransfers:this.memoryTransferTimes.length}}}_formatUsage(e){const t=[];return e&GPUBufferUsage.VERTEX&&t.push("VERTEX"),e&GPUBufferUsage.INDEX&&t.push("INDEX"),e&GPUBufferUsage.UNIFORM&&t.push("UNIFORM"),e&GPUBufferUsage.STORAGE&&t.push("STORAGE"),e&GPUBufferUsage.COPY_SRC&&t.push("COPY_SRC"),e&GPUBufferUsage.COPY_DST&&t.push("COPY_DST"),e&GPUBufferUsage.MAP_READ&&t.push("MAP_READ"),e&GPUBufferUsage.MAP_WRITE&&t.push("MAP_WRITE"),t.join(" | ")}_formatBytes(e){if(0===e)return"0 B";const t=Math.floor(Math.log(e)/Math.log(1024));return parseFloat((e/Math.pow(1024,t)).toFixed(2))+" "+["B","KB","MB","GB"][t]}destroy(){for(const[t,i]of this.buffers)try{i.destroy()}catch(e){}this.buffers.clear(),this.bindGroups.clear(),this.bufferPools.clear(),this.bufferSizes.clear(),this.totalMemoryUsed=0,this.bufferCreationTimes=[],this.memoryTransferTimes=[]}}class WebGPUNeuralNetwork{static{__name(this,"WebGPUNeuralNetwork")}constructor(e){this.device=e,this.shaderManager=null,this.bufferManager=null,this.inputSize=0,this.hiddenSize=0,this.outputSize=0,this.buffers=null,this.bindGroups=null,this.isInitialized=!1,this.weightsInitialized=!1,this.forwardPassTimes=[],this.gpuMemoryUsed=0,this.pendingOperations=new Map,this.operationCounter=0,this.maxConcurrentOps=4,this.asyncQueue=[],this.errorCount=0,this.maxErrors=10,this.lastError=null,this.errorLog=[],this._batchBufferCache=new Map,this._batchBindGroupCache=new Map,this.operationTimeout=3e4,this.activeTimeouts=new Map}async initialize(e,t,i,s={}){validateArchitecture(e,t,i),this.inputSize=e,this.hiddenSize=t,this.outputSize=i,this.shaderManager=new ShaderManager(this.device),this.bufferManager=new BufferManager(this.device,{maxBufferSize:16777216,maxTotalMemory:268435456,poolEnabled:!0,poolMaxAge:6e4,poolMaxSize:20,enableValidation:!0,enableProfiling:!0});try{await this.shaderManager.loadShaders();const a={inputSize:e,hiddenSize:t,outputSize:i,batchSize:1};this.buffers=await this.bufferManager.createNetworkBuffers(a,{persistent:!0,allowReuse:!0}),await this._createBindGroups(),await this.initializeWeights(s.initMethod||"xavier",s.seed),this.isInitialized=!0;const r=this.bufferManager.getMemoryUsage();this.gpuMemoryUsed=r.memory.totalActive}catch(a){throw a}}async initializeWeights(e="xavier",t=null){const i=this._generateWeights(this.inputSize,this.hiddenSize,e,t),s=this._generateBias(this.hiddenSize),a=this._generateWeights(this.hiddenSize,this.outputSize,e,t?t+1:null),r=this._generateBias(this.outputSize);await this.bufferManager.updateBuffer(this.device.queue,this.buffers.weightsHidden,i,0,{label:"init_weights_hidden"}),await this.bufferManager.updateBuffer(this.device.queue,this.buffers.biasHidden,s,0,{label:"init_bias_hidden"}),await this.bufferManager.updateBuffer(this.device.queue,this.buffers.weightsOutput,a,0,{label:"init_weights_output"}),await this.bufferManager.updateBuffer(this.device.queue,this.buffers.biasOutput,r,0,{label:"init_bias_output"}),this.weightsInitialized=!0}_generateWeights(e,t,i,s){const a=e*t,r=new Float32Array(a);let n=s?this._seededRandom(s):Math.random;switch(i){case"xavier":const i=Math.sqrt(2/(e+t));for(let e=0;e<a;e++)r[e]=2*(n()-.5)*i;break;case"he":const s=Math.sqrt(2/e);for(let e=0;e<a;e++)r[e]=this._boxMuller()*s;break;default:for(let e=0;e<a;e++)r[e]=.1*(n()-.5)}return r}_generateBias(e){return new Float32Array(e).fill(.01)}_seededRandom(e){let t=e;return function(){return t=(1664525*t+1013904223)%4294967296,t/4294967296}}_boxMuller(){const e=Math.random(),t=Math.random();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}async forward(e){if(!this.isInitialized)throw new Error("Neural network not initialized");if(e.length!==this.inputSize)throw new Error(`Input size mismatch. Expected ${this.inputSize}, got ${e.length}`);const t=performance.now();try{await this.bufferManager.updateBuffer(this.device.queue,this.buffers.input,e,0,{label:"forward_input"}),await this._executeForwardPass();const i=await this.bufferManager.readBuffer(this.device,this.buffers.output,4*this.outputSize,0,{label:"forward_output"}),s=new Float32Array(i),a=performance.now()-t;return this.forwardPassTimes.push(a),this.forwardPassTimes.length>100&&this.forwardPassTimes.shift(),s}catch(i){throw i}}async _executeForwardPass(){try{const e=this.device.createCommandEncoder({label:"neural_network_forward_pass"}),t=e.beginComputePass({label:"forward_pass_compute",timestampWrites:this.device.features.has("timestamp-query")?{querySet:null,beginningOfPassWriteIndex:void 0,endOfPassWriteIndex:void 0}:void 0}),i=new Uint32Array([1,this.inputSize,this.hiddenSize,0]);this.device.queue.writeBuffer(this.buffers.matmulParams,0,i),t.setPipeline(this.shaderManager.getPipeline("matmul_simple")),t.setBindGroup(0,this.bindGroups.matmulHidden),t.dispatchWorkgroups(Math.ceil(1*this.hiddenSize/64));const s=new Uint32Array([this.hiddenSize,0,0,0]);this.device.queue.writeBuffer(this.buffers.activationParams,0,s),t.setPipeline(this.shaderManager.getPipeline("relu")),t.setBindGroup(0,this.bindGroups.activation),t.dispatchWorkgroups(Math.ceil(this.hiddenSize/64));const a=new Uint32Array([1,this.hiddenSize,this.outputSize,0]);this.device.queue.writeBuffer(this.buffers.matmulParams,0,a),t.setPipeline(this.shaderManager.getPipeline("matmul_simple")),t.setBindGroup(0,this.bindGroups.matmulOutput),t.dispatchWorkgroups(Math.ceil(1*this.outputSize/64)),t.end();const r=e.finish();this.device.queue.submit([r]),await this.device.queue.onSubmittedWorkDone()}catch(e){throw new Error(`GPU forward pass failed: ${e.message}`)}}async forwardBatch(e,t,i={}){const{reuseBuffers:s=!0,async:a=!1}=i;if(!this.isInitialized)throw new Error("Neural network not initialized");if(e.length!==t*this.inputSize)throw new Error(`Batch input size mismatch. Expected ${t*this.inputSize}, got ${e.length}`);const r=performance.now(),n=`batch_${t}`;try{let i=s?this._batchBufferCache?.get(n):null,r=s?this._batchBindGroupCache?.get(n):null;if(!i||!r){const e={inputSize:this.inputSize,hiddenSize:this.hiddenSize,outputSize:this.outputSize,batchSize:t};i=await this.bufferManager.createNetworkBuffers(e,{persistent:s,allowReuse:!0}),r=await this._createBatchBindGroups(i,t),s&&(this._batchBufferCache=this._batchBufferCache||new Map,this._batchBindGroupCache=this._batchBindGroupCache||new Map,this._batchBufferCache.set(n,i),this._batchBindGroupCache.set(n,r))}if(await this._syncWeightsToBatchBuffers(i),await this.bufferManager.updateBuffer(this.device.queue,i.input,e,0,{label:"batch_input",useStaging:e.length>65536}),a)return this._executeBatchForwardPassAsync(t,r,i),null;await this._executeBatchForwardPass(t,r,i);const o=await this.bufferManager.readBuffer(this.device,i.output,t*this.outputSize*4,0,{label:"batch_output"}),h=new Float32Array(o);performance.now();return h}catch(o){throw o}}async _syncWeightsToBatchBuffers(e){try{const t=this.device.createCommandEncoder({label:"weight_sync_to_batch"});t.copyBufferToBuffer(this.buffers.weightsHidden,0,e.weightsHidden,0,this.inputSize*this.hiddenSize*4),t.copyBufferToBuffer(this.buffers.biasHidden,0,e.biasHidden,0,4*this.hiddenSize),t.copyBufferToBuffer(this.buffers.weightsOutput,0,e.weightsOutput,0,this.hiddenSize*this.outputSize*4),t.copyBufferToBuffer(this.buffers.biasOutput,0,e.biasOutput,0,4*this.outputSize),this.device.queue.submit([t.finish()])}catch(t){throw t}}async _createBatchBindGroups(e,t){const i={matmul:this.shaderManager.getBindGroupLayout("matmul"),activation:this.shaderManager.getBindGroupLayout("activation")},s={};return s.matmulHidden=this.device.createBindGroup({label:`batch_matmul_hidden_${t}`,layout:i.matmul,entries:[{binding:0,resource:{buffer:e.input}},{binding:1,resource:{buffer:e.weightsHidden}},{binding:2,resource:{buffer:e.biasHidden}},{binding:3,resource:{buffer:e.hidden}},{binding:4,resource:{buffer:e.matmulParams}}]}),s.matmulOutput=this.device.createBindGroup({label:`batch_matmul_output_${t}`,layout:i.matmul,entries:[{binding:0,resource:{buffer:e.hidden}},{binding:1,resource:{buffer:e.weightsOutput}},{binding:2,resource:{buffer:e.biasOutput}},{binding:3,resource:{buffer:e.output}},{binding:4,resource:{buffer:e.matmulParams}}]}),s.activation=this.device.createBindGroup({label:`batch_activation_${t}`,layout:i.activation,entries:[{binding:0,resource:{buffer:e.hidden}},{binding:1,resource:{buffer:e.hidden}},{binding:2,resource:{buffer:e.activationParams}}]}),s}async _executeBatchForwardPass(e,t,i){try{const s=this.device.createCommandEncoder({label:`batch_forward_pass_${e}`}),a=s.beginComputePass({label:"batch_forward_compute"}),r=new Uint32Array([e,this.inputSize,this.hiddenSize,0]);this.device.queue.writeBuffer(i.matmulParams,0,r),this.shaderManager.computePipelines.has("matmul_batch")?(a.setPipeline(this.shaderManager.getPipeline("matmul_batch")),a.setBindGroup(0,t.matmulHidden),a.dispatchWorkgroups(Math.ceil(this.hiddenSize/8),Math.ceil(e/8),1)):(a.setPipeline(this.shaderManager.getPipeline("matmul_simple")),a.setBindGroup(0,t.matmulHidden),a.dispatchWorkgroups(Math.ceil(e*this.hiddenSize/64)));const n=new Uint32Array([e*this.hiddenSize,0,0,0]);this.device.queue.writeBuffer(i.activationParams,0,n),a.setPipeline(this.shaderManager.getPipeline("relu")),a.setBindGroup(0,t.activation),a.dispatchWorkgroups(Math.ceil(e*this.hiddenSize/64));const o=new Uint32Array([e,this.hiddenSize,this.outputSize,0]);this.device.queue.writeBuffer(i.matmulParams,0,o),this.shaderManager.computePipelines.has("matmul_batch")?(a.setPipeline(this.shaderManager.getPipeline("matmul_batch")),a.setBindGroup(0,t.matmulOutput),a.dispatchWorkgroups(Math.ceil(this.outputSize/8),Math.ceil(e/8),1)):(a.setPipeline(this.shaderManager.getPipeline("matmul_simple")),a.setBindGroup(0,t.matmulOutput),a.dispatchWorkgroups(Math.ceil(e*this.outputSize/64))),a.end();const h=s.finish();this.device.queue.submit([h]),await this.device.queue.onSubmittedWorkDone()}catch(s){throw s}}async _executeBatchForwardPassAsync(e,t,i){try{const s=this.device.createCommandEncoder({label:`async_batch_forward_${e}`}),a=s.beginComputePass({label:"async_batch_compute"}),r=new Uint32Array([e,this.inputSize,this.hiddenSize,0]);this.device.queue.writeBuffer(i.matmulParams,0,r),a.setPipeline(this.shaderManager.getPipeline("matmul_simple")),a.setBindGroup(0,t.matmulHidden),a.dispatchWorkgroups(Math.ceil(e*this.hiddenSize/64));const n=new Uint32Array([e*this.hiddenSize,0,0,0]);this.device.queue.writeBuffer(i.activationParams,0,n),a.setPipeline(this.shaderManager.getPipeline("relu")),a.setBindGroup(0,t.activation),a.dispatchWorkgroups(Math.ceil(e*this.hiddenSize/64));const o=new Uint32Array([e,this.hiddenSize,this.outputSize,0]);this.device.queue.writeBuffer(i.matmulParams,0,o),a.setPipeline(this.shaderManager.getPipeline("matmul_simple")),a.setBindGroup(0,t.matmulOutput),a.dispatchWorkgroups(Math.ceil(e*this.outputSize/64)),a.end(),this.device.queue.submit([s.finish()])}catch(s){throw s}}async getWeights(){if(!this.isInitialized)throw new Error("Neural network not initialized");const e=await this.bufferManager.readBuffer(this.device,this.buffers.weightsHidden,this.inputSize*this.hiddenSize*4,0,{label:"get_weights_hidden"}),t=await this.bufferManager.readBuffer(this.device,this.buffers.biasHidden,4*this.hiddenSize,0,{label:"get_bias_hidden"}),i=await this.bufferManager.readBuffer(this.device,this.buffers.weightsOutput,this.hiddenSize*this.outputSize*4,0,{label:"get_weights_output"}),s=await this.bufferManager.readBuffer(this.device,this.buffers.biasOutput,4*this.outputSize,0,{label:"get_bias_output"});return{weightsHidden:new Float32Array(e),biasHidden:new Float32Array(t),weightsOutput:new Float32Array(i),biasOutput:new Float32Array(s)}}async setWeights(e){if(!this.isInitialized)throw new Error("Neural network not initialized");await this.bufferManager.updateBuffer(this.device.queue,this.buffers.weightsHidden,e.weightsHidden,0,{label:"set_weights_hidden"}),await this.bufferManager.updateBuffer(this.device.queue,this.buffers.biasHidden,e.biasHidden,0,{label:"set_bias_hidden"}),await this.bufferManager.updateBuffer(this.device.queue,this.buffers.weightsOutput,e.weightsOutput,0,{label:"set_weights_output"}),await this.bufferManager.updateBuffer(this.device.queue,this.buffers.biasOutput,e.biasOutput,0,{label:"set_bias_output"}),this.weightsInitialized=!0}getArchitecture(){return{inputSize:this.inputSize,hiddenSize:this.hiddenSize,outputSize:this.outputSize,parameterCount:calculateParameterCount(this.inputSize,this.hiddenSize,this.outputSize),backend:"webgpu",isInitialized:this.isInitialized,weightsInitialized:this.weightsInitialized}}getPerformanceMetrics(){const e=this.forwardPassTimes,t=e.length>0?e.reduce((e,t)=>e+t)/e.length:0,i=this.bufferManager?this.bufferManager.getMemoryUsage():null,s=this.bufferManager?this.bufferManager.getPerformanceMetrics():null;return{averageForwardTime:t,totalForwardPasses:e.length,gpuMemoryUsed:this.gpuMemoryUsed,bufferManager:i?{memory:i.memory,buffers:i.buffers,pool:i.pool,performance:i.performance,config:i.config}:null,bufferPerformance:s?{bufferCreation:s.bufferCreation,memoryTransfer:s.memoryTransfer,mapping:s.mapping,asyncOperations:s.asyncOperations,errors:s.errors}:null,shaderManager:this.shaderManager?this.shaderManager.getPerformanceMetrics():null,asyncOperations:this.getAsyncStatus(),efficiency:{bufferPoolHitRate:i?i.pool.hitRate:"0%",memoryUtilization:i?i.memory.utilizationPercent+"%":"0%",averageBufferCreationTime:i?i.performance.avgCreationTime:"0ms",averageTransferTime:i?i.performance.avgTransferTime:"0ms",errorRate:this.operationCounter>0?(this.errorCount/this.operationCounter*100).toFixed(2)+"%":"0%"}}}async benchmarkAgainstCPU(e,t={}){const{iterations:i=1e3,warmupIterations:s=100,testBatchSizes:a=[1,4,8,16],includeMemoryAnalysis:r=!0,includeAccuracyCheck:n=!0}=t,o=performance.now(),h={config:{iterations:i,warmupIterations:s,testBatchSizes:a,architecture:this.getArchitecture()},singleInference:null,batchProcessing:{},memoryComparison:null,accuracyVerification:null,summary:null};try{h.singleInference=await this._benchmarkSingleInference(e,i,s);for(const s of a)h.batchProcessing[s]=await this._benchmarkBatchProcessing(e,s,Math.floor(i/s));r&&(h.memoryComparison=await this._compareMemoryUsage(e)),n&&(h.accuracyVerification=await this._verifyAccuracy(e)),h.summary=this._generateBenchmarkSummary(h);const t=performance.now()-o;return h.benchmarkTime=t,h}catch(l){throw l}}async _benchmarkSingleInference(e,t,i){const s=new Float32Array([.1,-.05]);for(let d=0;d<i;d++)e.forward(s),await this.forward(s);const a=[];for(let d=0;d<t;d++){const t=performance.now();e.forward(s),a.push(performance.now()-t)}const r=[];for(let d=0;d<t;d++){const e=performance.now();await this.forward(s),r.push(performance.now()-e)}const n=[];for(let d=0;d<t;d++){const e=performance.now();await this.forwardRealTime(s,{realTime:!0,skipValidation:!0}),n.push(performance.now()-e)}const o=this._calculatePerformanceStats(a),h=this._calculatePerformanceStats(r),l=this._calculatePerformanceStats(n);return{cpu:o,gpu:h,gpuRealTime:l,speedup:{standard:o.median/h.median,realTime:o.median/l.median},throughput:{cpu:1e3/o.median,gpu:1e3/h.median,gpuRealTime:1e3/l.median},realTimeCapable:l.p95<=5,iterations:t}}async _benchmarkBatchProcessing(e,t,i){const s=new Float32Array(t*this.inputSize);for(let h=0;h<s.length;h+=2)s[h]=.2*Math.random()-.1,s[h+1]=.1*Math.random()-.05;for(let h=0;h<10;h++){for(let i=0;i<t;i++){const t=s.slice(2*i,2*(i+1));e.forward(t)}await this.forwardBatch(s,t)}const a=[];for(let h=0;h<i;h++){const i=performance.now();for(let a=0;a<t;a++){const t=s.slice(2*a,2*(a+1));e.forward(t)}a.push(performance.now()-i)}const r=[];for(let h=0;h<i;h++){const e=performance.now();await this.forwardBatch(s,t),r.push(performance.now()-e)}const n=this._calculatePerformanceStats(a),o=this._calculatePerformanceStats(r);return{batchSize:t,cpu:{...n,timePerSample:n.median/t,throughput:1e3*t/n.median},gpu:{...o,timePerSample:o.median/t,throughput:1e3*t/o.median},speedup:n.median/o.median,batchEfficiency:n.median/t/(o.median/t),iterations:i}}async _compareMemoryUsage(e){const t=e.getMemoryUsage(),i=this.bufferManager.getMemoryUsage();return{cpu:{totalBytes:t.totalBytes,totalKB:t.totalKB,parameterBytes:t.parameterBytes,breakdown:t.breakdown},gpu:{totalBytes:i.memory.totalActive,totalKB:i.memory.totalActive/1024,bufferCount:i.buffers.count,pooledBytes:i.memory.totalPooled,efficiency:i.pool.hitRate},comparison:{memoryRatio:i.memory.totalActive/t.totalBytes,gpuOverhead:i.memory.totalActive-t.totalBytes,bufferPoolSavings:i.memory.totalPooled}}}async _verifyAccuracy(e,t=100){const i=[],s={absolute:0,relative:0};let a=0,r=0;for(let c=0;c<t;c++){const t=new Float32Array([.4*(Math.random()-.5),.2*(Math.random()-.5)]),n=e.forward(t),o=await this.forward(t),h=[],l=[];for(let e=0;e<n.length;e++){const t=Math.abs(n[e]-o[e]),i=0!==n[e]?Math.abs((n[e]-o[e])/n[e]):0;h.push(t),l.push(i),s.absolute=Math.max(s.absolute,t),s.relative=Math.max(s.relative,i)}const d=Math.max(...h),c=Math.max(...l);a+=d,r+=c,i.push({input:Array.from(t),cpuOutput:Array.from(n),gpuOutput:Array.from(o),absoluteErrors:h,relativeErrors:l,maxAbsoluteError:d,maxRelativeError:c})}const n=a/t,o=r/t,h=i.flatMap(e=>e.cpuOutput),l=i.flatMap(e=>e.gpuOutput),d=this._calculateCorrelation(h,l);return{testCases:t,maxErrors:s,averageErrors:{absolute:n,relative:o},correlation:d,passed:{absolute:s.absolute<1e-6,relative:s.relative<1e-5,correlation:d>.9999},detailedErrors:i.slice(0,5)}}_generateBenchmarkSummary(e){const t={overallSpeedup:e.singleInference.speedup.standard,realTimeSpeedup:e.singleInference.speedup.realTime,realTimeCapable:e.singleInference.realTimeCapable,bestBatchSpeedup:0,optimalBatchSize:1,memoryEfficient:!1,numericallyAccurate:!1,productionReady:!1,recommendations:[]};for(const[i,s]of Object.entries(e.batchProcessing))s.speedup>t.bestBatchSpeedup&&(t.bestBatchSpeedup=s.speedup,t.optimalBatchSize=parseInt(i));return e.memoryComparison&&(t.memoryEfficient=e.memoryComparison.comparison.memoryRatio<2),e.accuracyVerification&&(t.numericallyAccurate=e.accuracyVerification.passed.absolute&&e.accuracyVerification.passed.relative&&e.accuracyVerification.passed.correlation),t.productionReady=t.overallSpeedup>=2&&t.realTimeCapable&&t.memoryEfficient&&t.numericallyAccurate,t.overallSpeedup<2&&t.recommendations.push("Optimize GPU compute pipeline for better single inference performance"),t.realTimeCapable||t.recommendations.push("Implement additional real-time optimizations to meet latency requirements"),t.memoryEfficient||t.recommendations.push("Optimize buffer management to reduce GPU memory overhead"),t.numericallyAccurate||t.recommendations.push("Review shader implementations for numerical precision issues"),t.bestBatchSpeedup<1.5&&t.recommendations.push("Improve batch processing efficiency for training workflows"),t}_calculatePerformanceStats(e){const t=[...e].sort((e,t)=>e-t),i=e.length,s=e.reduce((e,t)=>e+t,0)/i,a=e.reduce((e,t)=>e+Math.pow(t-s,2),0)/i;return{count:i,min:Math.min(...e),max:Math.max(...e),mean:s,median:t[Math.floor(i/2)],p90:t[Math.floor(.9*i)],p95:t[Math.floor(.95*i)],p99:t[Math.floor(.99*i)],std:Math.sqrt(a),cv:Math.sqrt(a)/s}}_calculateCorrelation(e,t){const i=e.length,s=e.reduce((e,t)=>e+t,0)/i,a=t.reduce((e,t)=>e+t,0)/i;let r=0,n=0,o=0;for(let h=0;h<i;h++){const i=e[h]-s,l=t[h]-a;r+=i*l,n+=i*i,o+=l*l}return r/Math.sqrt(n*o)}validate(){const e={isValid:!0,issues:[],warnings:[],bufferStatus:{},performance:{}};if(this.isInitialized||(e.isValid=!1,e.issues.push("Network not initialized")),this.weightsInitialized||(e.isValid=!1,e.issues.push("Weights not initialized")),this.device||(e.isValid=!1,e.issues.push("WebGPU device not available")),this.shaderManager&&this.bufferManager||(e.isValid=!1,e.issues.push("GPU managers not initialized")),this.bufferManager){const t=this.bufferManager.getMemoryUsage(),i=this.bufferManager.getPerformanceMetrics();e.bufferStatus={totalBuffers:t.buffers.count,memoryUsage:t.memory.totalActiveFormatted,memoryUtilization:t.memory.utilizationPercent+"%",poolEfficiency:t.pool.hitRate,errorCount:i.errors.count},i.errors.count>0&&e.warnings.push(`${i.errors.count} buffer errors detected`),parseFloat(t.memory.utilizationPercent)>90&&e.warnings.push("High memory utilization (>90%)"),parseFloat(t.pool.hitRate)<50&&t.pool.hits+t.pool.misses>10&&e.warnings.push("Low buffer pool efficiency (<50% hit rate)");const s=parseFloat(t.performance.avgCreationTime),a=parseFloat(t.performance.avgTransferTime);e.performance={avgBufferCreation:t.performance.avgCreationTime,avgMemoryTransfer:t.performance.avgTransferTime,isPerformant:s<5&&a<10},e.performance.isPerformant||e.warnings.push("Suboptimal buffer performance detected")}if(this.shaderManager){const t=this.shaderManager.validateShaders();t.allShadersCompiled||(e.isValid=!1,e.issues.push(`Missing shaders: ${t.missingShaders.join(", ")}`))}if(this.buffers){const t=["input","hidden","output","weightsHidden","weightsOutput","biasHidden","biasOutput"];for(const i of t)this.buffers[i]||(e.isValid=!1,e.issues.push(`Missing required buffer: ${i}`))}return e}async executeAsyncOperation(e,t,i=this.operationTimeout){const s=this._generateOperationId();try{if(this.pendingOperations.size>=this.maxConcurrentOps)return void(await this._queueOperation({operation:e,operationName:t,timeoutMs:i,operationId:s}));this.pendingOperations.set(s,{name:t,startTime:performance.now(),promise:null});const a=new Promise((e,a)=>{const r=setTimeout(()=>{a(new Error(`Operation ${t} timed out after ${i}ms`))},i);this.activeTimeouts.set(s,r)}),r=await Promise.race([e(),a]);return this._cleanupOperation(s),r}catch(a){throw this._handleAsyncError(a,t,s),a}}async _queueOperation(e){return new Promise((t,i)=>{this.asyncQueue.push({...e,resolve:t,reject:i}),this._processQueue()})}async _processQueue(){if(0===this.asyncQueue.length||this.pendingOperations.size>=this.maxConcurrentOps)return;const{operation:e,operationName:t,timeoutMs:i,operationId:s,resolve:a,reject:r}=this.asyncQueue.shift();try{a(await this.executeAsyncOperation(e,t,i))}catch(n){r(n)}setImmediate(()=>this._processQueue())}_generateOperationId(){return`op_${++this.operationCounter}_${Date.now()}`}_handleAsyncError(e,t,i){this.errorCount++,this.lastError=e;const s={timestamp:(new Date).toISOString(),operationName:t,operationId:i,message:e.message,stack:e.stack};this.errorLog.push(s),this.errorLog.length>100&&this.errorLog.shift(),this._cleanupOperation(i),this.errorCount,this.maxErrors}_cleanupOperation(e){this.pendingOperations.delete(e);const t=this.activeTimeouts.get(e);t&&(clearTimeout(t),this.activeTimeouts.delete(e))}async waitForOperations(e=6e4){const t=performance.now();for(;this.pendingOperations.size>0;){if(performance.now()-t>e){const e=Array.from(this.pendingOperations.keys());throw new Error(`Timeout waiting for operations: ${e.join(", ")}`)}await new Promise(e=>setTimeout(e,10))}}getAsyncStatus(){return{pendingOperations:this.pendingOperations.size,queuedOperations:this.asyncQueue.length,totalErrors:this.errorCount,lastError:this.lastError?{message:this.lastError.message,timestamp:this.errorLog[this.errorLog.length-1]?.timestamp}:null,recentErrors:this.errorLog.slice(-5),maxConcurrentOps:this.maxConcurrentOps,operationTimeout:this.operationTimeout}}resetErrorState(){this.errorCount=0,this.lastError=null,this.errorLog=[]}destroy(){for(const[e,t]of this.activeTimeouts)clearTimeout(t);this.activeTimeouts.clear(),this.pendingOperations.clear(),this.asyncQueue=[],this._batchBufferCache?.clear(),this._batchBindGroupCache?.clear(),this.bufferManager&&(this.bufferManager.destroy(),this.bufferManager=null),this.shaderManager&&(this.shaderManager.destroy(),this.shaderManager=null),this.buffers=null,this.bindGroups=null,this.isInitialized=!1,this.weightsInitialized=!1,this.forwardPassTimes=[],this.errorCount}async _createBindGroups(){const e={matmul:this.shaderManager.getBindGroupLayout("matmul"),activation:this.shaderManager.getBindGroupLayout("activation")};this.bindGroups={},this.bindGroups.matmulHidden=this.device.createBindGroup({label:"matmul_hidden_bind_group",layout:e.matmul,entries:[{binding:0,resource:{buffer:this.buffers.input}},{binding:1,resource:{buffer:this.buffers.weightsHidden}},{binding:2,resource:{buffer:this.buffers.biasHidden}},{binding:3,resource:{buffer:this.buffers.hidden}},{binding:4,resource:{buffer:this.buffers.matmulParams}}]}),this.bindGroups.matmulOutput=this.device.createBindGroup({label:"matmul_output_bind_group",layout:e.matmul,entries:[{binding:0,resource:{buffer:this.buffers.hidden}},{binding:1,resource:{buffer:this.buffers.weightsOutput}},{binding:2,resource:{buffer:this.buffers.biasOutput}},{binding:3,resource:{buffer:this.buffers.output}},{binding:4,resource:{buffer:this.buffers.matmulParams}}]}),this.bindGroups.activation=this.device.createBindGroup({label:"activation_bind_group",layout:e.activation,entries:[{binding:0,resource:{buffer:this.buffers.hidden}},{binding:1,resource:{buffer:this.buffers.hidden}},{binding:2,resource:{buffer:this.buffers.activationParams}}]})}async forwardRealTime(e,t={}){const{realTime:i=!0,skipValidation:s=!1}=t;if(!this.isInitialized)throw new Error("Neural network not initialized");if(!s&&e.length!==this.inputSize)throw new Error(`Input size mismatch. Expected ${this.inputSize}, got ${e.length}`);const a=performance.now();try{this.device.queue.writeBuffer(this.buffers.input,0,e),i?await this._executeRealTimeForwardPass():await this._executeForwardPass();const t=await this.bufferManager.readBuffer(this.device,this.buffers.output,4*this.outputSize,0,{label:"realtime_forward_output"}),s=new Float32Array(t),r=performance.now()-a;return this.forwardPassTimes.push(r),this.forwardPassTimes.length>50&&this.forwardPassTimes.shift(),s}catch(r){throw r}}async _executeRealTimeForwardPass(){try{const e=this.device.createCommandEncoder({label:"realtime_forward"}),t=e.beginComputePass({label:"realtime_compute"}),i=new Uint32Array([1,this.inputSize,this.hiddenSize,0]);this.device.queue.writeBuffer(this.buffers.matmulParams,0,i),t.setPipeline(this.shaderManager.getPipeline("matmul_simple")),t.setBindGroup(0,this.bindGroups.matmulHidden),t.dispatchWorkgroups(Math.ceil(this.hiddenSize/64));const s=new Uint32Array([this.hiddenSize,0,0,0]);this.device.queue.writeBuffer(this.buffers.activationParams,0,s),t.setPipeline(this.shaderManager.getPipeline("relu")),t.setBindGroup(0,this.bindGroups.activation),t.dispatchWorkgroups(Math.ceil(this.hiddenSize/64));const a=new Uint32Array([1,this.hiddenSize,this.outputSize,0]);this.device.queue.writeBuffer(this.buffers.matmulParams,0,a),t.setPipeline(this.shaderManager.getPipeline("matmul_simple")),t.setBindGroup(0,this.bindGroups.matmulOutput),t.dispatchWorkgroups(Math.ceil(this.outputSize/64)),t.end(),this.device.queue.submit([e.finish()])}catch(e){throw e}}}const d={storageBuffer:1024},c={maxComputeWorkgroupSizeX:64,maxComputeInvocationsPerWorkgroup:64};class WebGPUDeviceInfo{static{__name(this,"WebGPUDeviceInfo")}constructor(){this.isAvailable=!1,this.adapter=null,this.device=null,this.capabilities=null,this.features=new Set,this.limits=null,this.errorMessage=null,this.fallbackReason=null}getSummary(){return{isAvailable:this.isAvailable,hasComputeShaders:this.features.has("compute")||this.isAvailable,maxBufferSize:this.limits?.maxBufferSize||0,maxComputeWorkgroupSizeX:this.limits?.maxComputeWorkgroupSizeX||0,maxComputeInvocationsPerWorkgroup:this.limits?.maxComputeInvocationsPerWorkgroup||0,errorMessage:this.errorMessage,fallbackReason:this.fallbackReason,adapterInfo:this.adapter?{vendor:this.adapter.info?.vendor||"Unknown",architecture:this.adapter.info?.architecture||"Unknown",device:this.adapter.info?.device||"Unknown",description:this.adapter.info?.description||"Unknown"}:null}}meetsRequirements(){return!(!this.isAvailable||!this.limits)&&(this.limits.maxBufferSize<d.storageBuffer?(this.fallbackReason=`Insufficient buffer size: ${this.limits.maxBufferSize} < ${d.storageBuffer}`,!1):this.limits.maxComputeWorkgroupSizeX<c.maxComputeWorkgroupSizeX?(this.fallbackReason=`Insufficient workgroup size X: ${this.limits.maxComputeWorkgroupSizeX} < ${c.maxComputeWorkgroupSizeX}`,!1):!(this.limits.maxComputeInvocationsPerWorkgroup<c.maxComputeInvocationsPerWorkgroup)||(this.fallbackReason=`Insufficient compute invocations: ${this.limits.maxComputeInvocationsPerWorkgroup} < ${c.maxComputeInvocationsPerWorkgroup}`,!1))}}class WebGPUDeviceManager{static{__name(this,"WebGPUDeviceManager")}constructor(){this.deviceInfo=new WebGPUDeviceInfo,this.isInitialized=!1,this.initializationPromise=null}async initWebGPU(e={}){return this.initializationPromise||(this.initializationPromise=this._initWebGPUInternal(e)),this.initializationPromise}async _initWebGPUInternal(e){const{preferHighPerformance:t=!0,forceFallback:i=!1}=e;try{if(i)throw new Error("Forced CPU fallback for testing");if(!navigator.gpu)throw new Error("WebGPU is not supported in this browser. Requires Chrome 113+ or Edge 113+");const e=await navigator.gpu.requestAdapter({powerPreference:t?"high-performance":"low-power"});if(!e)throw new Error("No suitable WebGPU adapter found. Your GPU may not support WebGPU");this.deviceInfo.adapter=e,e.info;Array.from(e.features);const s=this._createDeviceDescriptor(e),a=await e.requestDevice(s);if(!a)throw new Error("Failed to obtain WebGPU device");if(this.deviceInfo.device=a,this.deviceInfo.features=a.features,this.deviceInfo.limits=a.limits,a.addEventListener("uncapturederror",e=>{}),!this.deviceInfo.meetsRequirements())throw new Error(`WebGPU device does not meet requirements: ${this.deviceInfo.fallbackReason}`);return this.deviceInfo.isAvailable=!0,this.isInitialized=!0,this.deviceInfo}catch(s){return this.deviceInfo.isAvailable=!1,this.deviceInfo.errorMessage=s.message,this.deviceInfo.fallbackReason=this.deviceInfo.fallbackReason||s.message,this.deviceInfo}}_createDeviceDescriptor(e){const t=[],i=["timestamp-query","pipeline-statistics-query"];for(const s of i)e.features.has(s)&&t.push(s);return{requiredFeatures:t,requiredLimits:{maxBufferSize:Math.min(e.limits.maxBufferSize,1073741824),maxComputeWorkgroupSizeX:Math.min(e.limits.maxComputeWorkgroupSizeX,256)}}}getDeviceInfo(){return this.deviceInfo}isWebGPUAvailable(){return this.deviceInfo.isAvailable&&this.isInitialized}getDevice(){return this.deviceInfo.device}destroy(){this.deviceInfo.device&&(this.deviceInfo.device.destroy(),this.deviceInfo.device=null),this.deviceInfo.adapter=null,this.isInitialized=!1,this.initializationPromise=null}getPerformanceEstimate(){if(!this.isWebGPUAvailable())return{estimatedSpeedup:1,supportedOperations:["basic"],recommendedBatchSize:1};const e=this.deviceInfo.limits,t=Math.min(e.maxComputeWorkgroupSizeX,64);return{estimatedSpeedup:Math.min(t/8,10),supportedOperations:["matrix_multiply","activation_functions","gradient_computation"],recommendedBatchSize:Math.floor(t/4),maxWorkgroupSize:t,maxBufferSizeMB:Math.floor(e.maxBufferSize/1048576)}}}class WebGPUBackend extends NeuralNetwork{static{__name(this,"WebGPUBackend")}constructor(){super(),this.deviceManager=new WebGPUDeviceManager,this.isWebGPUAvailable=!1,this.gpuNetwork=null,this.cpuBackend=new CPUBackend,this.usingFallback=!1,this.isInitialized=!1,this.performanceMetrics={initializationTime:0,forwardPassTimes:[],gpuMemoryUsage:0,fallbackReason:null}}async createNetwork(e,t,i,s={}){const a=performance.now();try{let i,r,n;if("object"==typeof e&&e.layers?(i=e,r=i.inputSize||2,n=i.outputSize||3):(r=e||2,n=n||3,i={name:"Legacy",inputSize:r,outputSize:n,layers:[t||8],getParameterCount:__name(function(){let e=0,t=this.inputSize;for(const i of this.layers)e+=t*i+i,t=i;return e+=t*this.outputSize+this.outputSize,e},"getParameterCount")}),1===i.layers.length)validateArchitecture(r,i.layers[0],n);else{const e=i.validate?i.validate():{valid:!0};if(!e.valid)throw new Error(`Invalid architecture: ${e.errors.join(", ")}`)}this.currentArchitecture=i;const o=await this.deviceManager.initWebGPU({forceFallback:s.forceCPU||!1});o.isAvailable&&o.meetsRequirements()?(this.isWebGPUAvailable=!0,this.usingFallback=!1,this.gpuNetwork=new WebGPUNeuralNetwork(this.deviceManager.getDevice()),await this.gpuNetwork.initialize(i,s)):(this.isWebGPUAvailable=!1,this.usingFallback=!0,this.performanceMetrics.fallbackReason=o.fallbackReason||o.errorMessage,await this.cpuBackend.createNetwork(i,s)),this.isInitialized=!0,this.performanceMetrics.initializationTime=performance.now()-a;this.isWebGPUAvailable}catch(r){if(this.usingFallback)throw r;this.isWebGPUAvailable=!1,this.usingFallback=!0,this.performanceMetrics.fallbackReason=r.message,await this.cpuBackend.createNetwork(architecture,s),this.isInitialized=!0}}async forward(e){if(!this.isInitialized)throw new Error("Network not initialized. Call createNetwork() first.");const t=performance.now();let i;i=this.isWebGPUAvailable&&this.gpuNetwork?await this.gpuNetwork.forward(e):this.cpuBackend.forward(e);const s=performance.now()-t;return this.performanceMetrics.forwardPassTimes.push(s),this.performanceMetrics.forwardPassTimes.length>100&&this.performanceMetrics.forwardPassTimes.shift(),i}getParameterCount(){return this.isInitialized&&this.currentArchitecture?this.currentArchitecture.getParameterCount():0}async getWeights(){if(!this.isInitialized)throw new Error("Network not initialized");return this.isWebGPUAvailable&&this.gpuNetwork?await this.gpuNetwork.getWeights():this.cpuBackend.getWeights()}async setWeights(e){return this.isWebGPUAvailable&&this.gpuNetwork?await this.gpuNetwork.setWeights(e):this.cpuBackend.setWeights(e)}getArchitecture(){return this.isInitialized&&this.currentArchitecture?{...this.currentArchitecture,parameterCount:this.currentArchitecture.getParameterCount(),backend:this.isWebGPUAvailable?"webgpu":"cpu",webgpuAvailable:this.isWebGPUAvailable,usingFallback:this.usingFallback,fallbackReason:this.performanceMetrics.fallbackReason,deviceInfo:this.deviceManager.getDeviceInfo().getSummary(),performanceEstimate:this.deviceManager.getPerformanceEstimate()}:{backend:"uninitialized",webgpuAvailable:this.isWebGPUAvailable,usingFallback:this.usingFallback}}getBackendInfo(){return{type:this.isWebGPUAvailable?"webgpu":"cpu",webgpuAvailable:this.isWebGPUAvailable,usingFallback:this.usingFallback,fallbackReason:this.performanceMetrics.fallbackReason,deviceInfo:this.deviceManager.getDeviceInfo(),performanceMetrics:this.getPerformanceMetrics(),capabilities:this.deviceManager.getPerformanceEstimate()}}getPerformanceMetrics(){const e=this.performanceMetrics.forwardPassTimes,t=e.length>0?e.reduce((e,t)=>e+t)/e.length:0,i={initializationTime:this.performanceMetrics.initializationTime,averageForwardTime:t,totalForwardPasses:e.length,estimatedSpeedup:this.isWebGPUAvailable?this.deviceManager.getPerformanceEstimate().estimatedSpeedup:1,memoryUsage:this.getMemoryUsage()};if(this.isWebGPUAvailable&&this.gpuNetwork){const e=this.gpuNetwork.getPerformanceMetrics();return{...i,gpu:e,backend:"webgpu"}}return{...i,backend:"cpu"}}benchmark(e=1e3){if(!this.isInitialized)throw new Error("Network not initialized");return{...this.cpuBackend.benchmark(e),backend:this.isWebGPUAvailable?"webgpu":"cpu",webgpuAvailable:this.isWebGPUAvailable,usingFallback:this.usingFallback,estimatedSpeedup:this.isWebGPUAvailable?this.deviceManager.getPerformanceEstimate().estimatedSpeedup:1}}getMemoryUsage(){const e=this.cpuBackend.getMemoryUsage();return{...e,backend:this.isWebGPUAvailable?"webgpu":"cpu",gpuMemoryEstimate:this.isWebGPUAvailable?e.totalBytes:0,webgpuBuffers:this.isWebGPUAvailable?"Not implemented (Phase 2.2)":"N/A"}}clone(){const e=new WebGPUBackend;return this.isInitialized&&this.currentArchitecture&&(e.createNetwork(this.currentArchitecture,{initMethod:"xavier"}),e.setWeights(this.getWeights())),e}resetWeights(){if(!this.isInitialized)throw new Error("Network not initialized");this.cpuBackend.resetWeights()}destroy(){this.gpuNetwork&&(this.gpuNetwork.destroy(),this.gpuNetwork=null),this.cpuBackend&&(this.cpuBackend=null),this.deviceManager&&(this.deviceManager.destroy(),this.deviceManager=null),this.isInitialized=!1,this.isWebGPUAvailable=!1,this.usingFallback=!1}}async function checkWebGPUAvailability(){try{if(!navigator.gpu)return{available:!1,reason:"WebGPU API not found in browser"};const e=await navigator.gpu.requestAdapter();return e?{available:!0,adapterInfo:e.info?{vendor:e.info.vendor,device:e.info.device}:"Unknown adapter"}:{available:!1,reason:"No WebGPU adapter available"}}catch(e){return{available:!1,reason:e.message}}}__name(checkWebGPUAvailability,"checkWebGPUAvailability");class SystemCapabilities{static{__name(this,"SystemCapabilities")}constructor(){this.coreCount=this.detectCores(),this.targetCores=Math.max(1,Math.floor(.5*this.coreCount)),this.maxWorkers=Math.min(this.targetCores,64)}detectCores(){return"undefined"!=typeof navigator&&navigator.hardwareConcurrency?navigator.hardwareConcurrency:4}getWorkerConfig(){return{workerCount:this.maxWorkers,episodesPerWorker:2,batchSize:2*this.maxWorkers}}}class WorkerPool{static{__name(this,"WorkerPool")}constructor(e,t){this.workerCount=e,this.workers=[],this.availableWorkers=[],this.busyWorkers=new Set,this.taskQueue=[],this.workerScript=t,this.initialized=!1}async initialize(){for(let t=0;t<this.workerCount;t++)try{const e=new Worker(this.workerScript);e.onmessage=e=>{this.handleWorkerMessage(t,e.data)},e.onerror=e=>{},e.postMessage({type:"ping",taskId:`init-${t}`}),this.workers[t]=e,this.availableWorkers.push(t)}catch(e){throw e}this.initialized=!0;for(let t=0;t<this.workers.length;t++)this.workers[t].postMessage({type:"initialize",taskId:`worker-init-${t}`})}handleWorkerMessage(e,t){"episode_complete"===t.type?(this.busyWorkers.delete(e),this.availableWorkers.push(e),this.processNextTask()):"error"===t.type?(this.busyWorkers.delete(e),this.availableWorkers.push(e)):"pong"===t.type||t.type}async executeParallelEpisodes(e){if(!this.initialized)throw new Error("Worker pool not initialized");return new Promise((t,i)=>{const s=[];let a=0;const r=__name((i,r)=>{s[i]=r,a++,a===e.length&&t(s)},"taskCompleteHandler");e.forEach((e,t)=>{this.taskQueue.push({id:t,task:e,callback:r})}),this.processAllTasks()})}processAllTasks(){for(;this.availableWorkers.length>0&&this.taskQueue.length>0;)this.processNextTask()}processNextTask(){if(0===this.availableWorkers.length||0===this.taskQueue.length)return;const e=this.availableWorkers.pop(),t=this.taskQueue.shift();this.busyWorkers.add(e),this.workers[e].postMessage({type:"run_episode",taskId:t.id,...t.task});const i=this.workers[e].onmessage;this.workers[e].onmessage=s=>{s.data.taskId===t.id&&(t.callback(t.id,s.data.result),this.workers[e].onmessage=i),i(s)}}terminate(){this.workers.forEach(e=>{e.terminate()}),this.workers=[],this.availableWorkers=[],this.busyWorkers.clear(),this.initialized=!1}}class ParallelTrainingManager{static{__name(this,"ParallelTrainingManager")}constructor(e,t){this.qLearning=e,this.environment=t,this.capabilities=new SystemCapabilities,this.workerPool=null,this.config=this.capabilities.getWorkerConfig(),this.parallelEnabled=this.config.workerCount>1,this.stats={totalParallelEpisodes:0,totalSerialEpisodes:0,parallelTime:0,serialTime:0,speedupFactor:1}}async initialize(){if(this.parallelEnabled)try{const e=await this.createWorkerScript();this.workerPool=new WorkerPool(this.config.workerCount,e),await this.workerPool.initialize()}catch(e){this.parallelEnabled=!1}}async createWorkerScript(){try{const e=await fetch("./src/training/EpisodeWorker.js");if(!e.ok)throw new Error(`Failed to fetch EpisodeWorker.js: ${e.status}`);const t=await e.text(),i=new Blob([t],{type:"application/javascript"});return URL.createObjectURL(i)}catch(e){return this.createFallbackWorkerScript()}}createFallbackWorkerScript(){const e=new Blob(["\n            // Fallback episode worker\n            let episodeCount = 0;\n            \n            self.onmessage = function(event) {\n                const { type, taskId } = event.data;\n                \n                if (type === 'initialize') {\n                    self.postMessage({\n                        type: 'initialized',\n                        taskId: taskId,\n                        success: true\n                    });\n                    return;\n                }\n                \n                if (type === 'run_episode') {\n                    try {\n                        const result = runSimulatedEpisode(event.data);\n                        \n                        self.postMessage({\n                            type: 'episode_complete',\n                            taskId: taskId,\n                            result: result\n                        });\n                    } catch (error) {\n                        self.postMessage({\n                            type: 'error',\n                            taskId: taskId,\n                            error: { message: error.message }\n                        });\n                    }\n                }\n            };\n            \n            function runSimulatedEpisode(params) {\n                episodeCount++;\n                \n                // Simulate episode with reasonable results\n                const maxSteps = params.maxSteps || 1000;\n                const steps = Math.floor(Math.random() * maxSteps * 0.8) + maxSteps * 0.2;\n                const success = Math.random() > 0.3; // 70% success rate\n                const reward = success ? steps : Math.random() * steps * 0.5;\n                \n                // Simulate some computation time\n                const startTime = Date.now();\n                const computeTime = 5 + Math.random() * 15; // 5-20ms\n                while (Date.now() - startTime < computeTime) {\n                    // Busy wait\n                }\n                \n                // Generate some fake experiences\n                const experiences = [];\n                for (let i = 0; i < Math.min(steps, 100); i++) {\n                    experiences.push({\n                        state: [Math.random() * 2 - 1, Math.random() * 2 - 1],\n                        action: Math.floor(Math.random() * 3),\n                        reward: success ? 1.0 : 0.0,\n                        nextState: [Math.random() * 2 - 1, Math.random() * 2 - 1],\n                        done: i === steps - 1\n                    });\n                }\n                \n                return {\n                    episodeId: params.episodeId || episodeCount,\n                    totalReward: reward,\n                    stepCount: steps,\n                    experiences: experiences,\n                    completed: success,\n                    finalState: {\n                        angle: Math.random() * 0.2 - 0.1,\n                        angularVelocity: Math.random() * 0.4 - 0.2,\n                        position: Math.random() * 2 - 1,\n                        velocity: Math.random() * 0.4 - 0.2\n                    }\n                };\n            }\n        "],{type:"application/javascript"});return URL.createObjectURL(e)}async runEpisodes(e,t={}){return this.parallelEnabled&&e>=this.config.workerCount?this.runParallelEpisodes(e,t):this.runSerialEpisodes(e,t)}async runParallelEpisodes(e,t={}){const i=Date.now(),s=this.qLearning.qNetwork.getWeights(),a=this.environment.getConfig(),r=this.environment.historyTimesteps||1,n=[];for(let h=0;h<e;h++)n.push({episodeId:h,maxSteps:this.qLearning.hyperparams.maxStepsPerEpisode,robotConfig:a,neuralNetworkWeights:s,epsilon:this.qLearning.hyperparams.epsilon,explorationEnabled:!0,timesteps:r,...t});try{const t=await this.workerPool.executeParallelEpisodes(n);let s=0;for(let e=0;e<t.length;e++){const i=t[e];if(i&&i.experiences)for(const e of i.experiences){const t=this.qLearning.qNetwork.getArchitecture().inputSize;e.state.length===t&&e.nextState.length===t&&(this.qLearning.replayBuffer.add(new Float32Array(e.state),e.action,e.reward,new Float32Array(e.nextState),e.done),s++)}}const a=Date.now()-i;return this.stats.totalParallelEpisodes+=e,this.stats.parallelTime+=a,t}catch(o){return this.runSerialEpisodes(e,t)}}async runSerialEpisodes(e,t={}){const i=Date.now(),s=[];for(let r=0;r<e;r++){const e=this.qLearning.runEpisode(this.environment,t.verbose);s.push(e),r%10==0&&await new Promise(e=>setTimeout(e,0))}const a=Date.now()-i;return this.stats.totalSerialEpisodes+=e,this.stats.serialTime+=a,s}updateSpeedupStats(){if(this.stats.totalSerialEpisodes>0&&this.stats.totalParallelEpisodes>0){const e=this.stats.totalSerialEpisodes/this.stats.serialTime,t=this.stats.totalParallelEpisodes/this.stats.parallelTime;this.stats.speedupFactor=t/e}}getPerformanceStats(){return this.updateSpeedupStats(),{...this.stats,coreCount:this.capabilities.coreCount,workerCount:this.config.workerCount,parallelEnabled:this.parallelEnabled}}cleanup(){this.workerPool&&this.workerPool.terminate()}}class ParallelQLearning{static{__name(this,"ParallelQLearning")}constructor(e,t){this.qLearning=e,this.environment=t,this.parallelManager=new ParallelTrainingManager(e,t),this.initialized=!1}async initialize(){await this.parallelManager.initialize(),this.initialized=!0}async runTraining(e={}){this.initialized||await this.initialize();const t=e.verbose||!1,i=this.parallelManager.config.batchSize||4,s=this.qLearning.hyperparams.maxEpisodes;let a=0;for(;a<s;){const e=s-a,r=Math.min(i,e);if(this.parallelManager.parallelEnabled&&r>=2)for(let i=0;i<r;i++){this.qLearning.runEpisode(this.environment,t)}else{this.qLearning.runEpisode(this.environment,t)}a+=r,a%20==0&&await new Promise(e=>setTimeout(e,0))}return this.qLearning.metrics}cleanup(){this.parallelManager.cleanup()}getPerformanceStats(){return this.parallelManager.getPerformanceStats()}}class TrainingPerformanceTracker{static{__name(this,"TrainingPerformanceTracker")}constructor(){this.reset(),this.renderingConfig={alwaysRenderThreshold:100,skipRenderRatio:20,currentSkipCount:0,renderingMode:"full"},this.sampleWindow=6e4,this.episodeTimes=[],this.stepTimes=[]}reset(){this.startTime=Date.now(),this.lastEpisodeTime=Date.now(),this.lastStepTime=Date.now(),this.totalEpisodes=0,this.totalSteps=0,this.totalTrainingTime=0,this.currentEpisodesPerMinute=0,this.currentStepsPerSecond=0,this.trainingEfficiency=0,this.episodeTimes=[],this.stepTimes=[]}startEpisode(){const e=Date.now();this.lastEpisodeTime=e,this.episodeStartTime=e}endEpisode(e,t=0){const i=Date.now(),s=i-this.episodeStartTime;this.totalEpisodes++,this.totalSteps+=e,this.totalTrainingTime+=t,this.episodeTimes.push({timestamp:i,duration:s,steps:e,trainingTime:t}),this.cleanOldSamples(),this.updateRates()}recordStep(){const e=Date.now();this.stepTimes.push(e),this.lastStepTime=e,this.stepTimes.length%100==0&&this.cleanOldSamples()}cleanOldSamples(){const e=Date.now()-this.sampleWindow;this.episodeTimes=this.episodeTimes.filter(t=>t.timestamp>e),this.stepTimes=this.stepTimes.filter(t=>t>e);this.episodeTimes.length>1e3&&(this.episodeTimes=this.episodeTimes.slice(-1e3)),this.stepTimes.length>1e4&&(this.stepTimes=this.stepTimes.slice(-1e4))}updateRates(){const e=Date.now(),t=e-this.sampleWindow,i=this.episodeTimes.filter(e=>e.timestamp>t);if(i.length>0){const t=i.map(e=>e.timestamp),s=(e-Math.min.apply(Math,t))/1e3/60;this.currentEpisodesPerMinute=s>0?i.length/s:0}const s=this.stepTimes.filter(e=>e>t);if(s.length>0){const t=(e-Math.min.apply(Math,s))/1e3;this.currentStepsPerSecond=t>0?s.length/t:0}if(i.length>0){const e=i.reduce((e,t)=>e+t.trainingTime,0),t=i.reduce((e,t)=>e+t.duration,0);this.trainingEfficiency=t>0?e/t*100:0}}shouldRenderEpisode(e){return!0}shouldRenderStep(e){return!0}getPerformanceStats(){const e=(Date.now()-this.startTime)/1e3;return{totalEpisodes:this.totalEpisodes,totalSteps:this.totalSteps,totalTimeSeconds:e,episodesPerMinute:this.currentEpisodesPerMinute,stepsPerSecond:this.currentStepsPerSecond,trainingEfficiency:this.trainingEfficiency,averageEpisodeDuration:this.episodeTimes.length>0?this.episodeTimes.reduce((e,t)=>e+t.duration,0)/this.episodeTimes.length:0,renderingMode:this.renderingConfig.renderingMode,renderSkipRatio:this.renderingConfig.skipRenderRatio,estimatedMaxEpisodesPerHour:60*this.currentEpisodesPerMinute,estimatedMaxStepsPerMinute:60*this.currentStepsPerSecond}}getDisplayStats(){const e=this.getPerformanceStats();return{episodesPerMinute:e.episodesPerMinute>0?e.episodesPerMinute.toFixed(1):"--",stepsPerSecond:e.stepsPerSecond>0?e.stepsPerSecond.toFixed(1):"--",renderingMode:this.getRenderingModeDisplay(),trainingEfficiency:e.trainingEfficiency>0?`${e.trainingEfficiency.toFixed(1)}%`:"--",totalEpisodes:e.totalEpisodes,totalSteps:e.totalSteps,totalTimeMinutes:(e.totalTimeSeconds/60).toFixed(1),estimatedMaxPerHour:e.estimatedMaxEpisodesPerHour>0?`~${e.estimatedMaxEpisodesPerHour.toFixed(0)} ep/h`:"--"}}getRenderingModeDisplay(){switch(this.renderingConfig.renderingMode){case"full":return"Full (every episode)";case"sparse":return`Sparse (1:${this.renderingConfig.skipRenderRatio})`;case"minimal":return"Minimal (stats only)";case"disabled":return"Disabled";default:return"Unknown"}}autoAdjustRendering(e=120,t=120){t<.8*e?this.renderingConfig.skipRenderRatio=Math.min(50,this.renderingConfig.skipRenderRatio+5):t>1.2*e&&this.renderingConfig.skipRenderRatio>1&&(this.renderingConfig.skipRenderRatio=Math.max(1,this.renderingConfig.skipRenderRatio-2))}logPerformanceSummary(){this.getDisplayStats()}}class SmartRenderingManager{static{__name(this,"SmartRenderingManager")}constructor(e,t={}){this.performanceTracker=e,this.lastRenderTime=Date.now(),this.targetRenderInterval=1e3/(t.targetFPS||120),this.frameSkipCount=0,this.renderingMode=t.mode||"raf",this.actualTargetFPS=t.targetFPS||120}shouldRenderFrame(e){return!0}forceNextRender(){this.lastRenderTime=0}getRenderStats(){return{lastRenderTime:this.lastRenderTime,targetInterval:this.targetRenderInterval,frameSkipCount:this.frameSkipCount,targetFPS:1e3/this.targetRenderInterval}}}class UIControls{static{__name(this,"UIControls")}constructor(e){this.app=e,this.parameters={trainingSpeed:1,hiddenNeurons:8,learningRate:.002,gamma:.99,epsilon:.9,epsilonMin:.01,epsilonDecay:2500,batchSize:128,targetUpdateFreq:100,maxEpisodes:1e3,maxStepsPerEpisode:1e3,robotMass:1,robotHeight:.4,motorStrength:5,wheelFriction:.3,maxAngle:Math.PI/6,motorTorqueRange:8},this.networkConfig={preset:"DQN_STANDARD",customLayers:[8],currentArchitecture:null},this.validationRanges={trainingSpeed:{min:.1,max:1e3},hiddenNeurons:{min:4,max:16},learningRate:{min:1e-4,max:.01},gamma:{min:.8,max:.999},epsilon:{min:0,max:1},epsilonMin:{min:0,max:.1},epsilonDecay:{min:1e3,max:1e4},batchSize:{min:4,max:512},targetUpdateFreq:{min:10,max:1e3},maxEpisodes:{min:100,max:1e6},maxStepsPerEpisode:{min:50,max:5e3},robotMass:{min:.5,max:3},robotHeight:{min:.2,max:.8},motorStrength:{min:1,max:20},wheelFriction:{min:0,max:1},maxAngle:{min:Math.PI/180,max:Math.PI/3},motorTorqueRange:{min:.5,max:10}},this.loadParameters()}initialize(){this.setupSliderControls(),this.setupKeyboardShortcuts(),this.updateAllDisplays()}setupSliderControls(){const e=document.getElementById("training-speed");document.getElementById("training-speed-value"),e&&e.addEventListener("input",e=>{const t=parseFloat(e.target.value);this.setParameter("trainingSpeed",t),this.app.setTrainingSpeed(t)});[{id:"speed-1x",value:1},{id:"speed-2x",value:2},{id:"speed-10x",value:10},{id:"speed-20x",value:20},{id:"speed-50x",value:50}].forEach(e=>{const t=document.getElementById(e.id);t&&t.addEventListener("click",()=>{this.setSpeedPreset(e.value)})});const t=document.getElementById("speed-parallel");t&&t.addEventListener("click",()=>{this.enableParallelTraining()});const i=document.getElementById("debug-speed"),s=document.getElementById("debug-speed-value");i&&i.addEventListener("input",e=>{const t=parseFloat(e.target.value);this.app.setDebugSpeed(t),s.textContent=`${t.toFixed(1)}x`}),this.setupNetworkConfiguration();const a=document.getElementById("learning-rate");document.getElementById("learning-rate-value"),a.addEventListener("input",e=>{const t=parseFloat(e.target.value);this.setParameter("learningRate",t),this.app.updateLearningRate(t)});const r=document.getElementById("epsilon");document.getElementById("epsilon-value"),r.addEventListener("input",e=>{const t=parseFloat(e.target.value);this.setParameter("epsilon",t),this.app.updateEpsilon(t)});const n=document.getElementById("gamma");document.getElementById("gamma-value"),n.addEventListener("input",e=>{const t=parseFloat(e.target.value);this.setParameter("gamma",t),this.app.updateGamma(t)});const o=document.getElementById("epsilon-min");document.getElementById("epsilon-min-value"),o.addEventListener("input",e=>{const t=parseFloat(e.target.value);this.setParameter("epsilonMin",t),this.app.updateEpsilonMin(t)});const h=document.getElementById("epsilon-decay");document.getElementById("epsilon-decay-value"),h.addEventListener("input",e=>{const t=parseInt(e.target.value);this.setParameter("epsilonDecay",t),this.app.updateEpsilonDecay(t)});const l=document.getElementById("batch-size");document.getElementById("batch-size-value"),l.addEventListener("input",e=>{const t=parseInt(e.target.value);this.setParameter("batchSize",t),this.app.updateBatchSize(t)});const d=document.getElementById("target-update-freq");document.getElementById("target-update-freq-value"),d.addEventListener("input",e=>{const t=parseInt(e.target.value);this.setParameter("targetUpdateFreq",t),this.app.updateTargetUpdateFreq(t)});const c=document.getElementById("max-episodes");document.getElementById("max-episodes-value"),c.addEventListener("input",e=>{const t=parseInt(e.target.value);this.setParameter("maxEpisodes",t),this.app.updateMaxEpisodes(t)});const u=document.getElementById("max-steps-per-episode");document.getElementById("max-steps-per-episode-value"),u.addEventListener("input",e=>{const t=parseInt(e.target.value);this.setParameter("maxStepsPerEpisode",t),this.app.updateMaxStepsPerEpisode(t)});const p=document.getElementById("robot-mass");document.getElementById("robot-mass-value"),p.addEventListener("input",e=>{const t=parseFloat(e.target.value);this.setParameter("robotMass",t),this.app.updateRobotMass(t)});const m=document.getElementById("robot-height");document.getElementById("robot-height-value"),m.addEventListener("input",e=>{const t=parseFloat(e.target.value);this.setParameter("robotHeight",t),this.app.updateRobotHeight(t)});const g=document.getElementById("motor-strength");document.getElementById("motor-strength-value"),g.addEventListener("input",e=>{const t=parseFloat(e.target.value);this.setParameter("motorStrength",t),this.app.updateMotorStrength(t)});const f=document.getElementById("wheel-friction");document.getElementById("wheel-friction-value"),f&&f.addEventListener("input",e=>{const t=parseFloat(e.target.value);this.setParameter("wheelFriction",t),this.app.updateWheelFriction(t)});const b=document.getElementById("max-angle");document.getElementById("max-angle-value"),b&&b.addEventListener("input",e=>{const t=parseFloat(e.target.value);this.setParameter("maxAngle",t),this.app.updateMaxAngle(t)});const y=document.getElementById("motor-torque-range");document.getElementById("motor-torque-range-value"),y&&y.addEventListener("input",e=>{const t=parseFloat(e.target.value);this.setParameter("motorTorqueRange",t),this.app.updateMotorTorqueRange(t)});const w=document.getElementById("history-timesteps"),v=document.getElementById("history-timesteps-value");w&&w.addEventListener("input",e=>{const t=parseInt(e.target.value);v.textContent=t,this.app&&this.app.robot&&(this.app.robot.setHistoryTimesteps(t),this.app.qlearning&&(this.app.qlearning.episode,this.app.initializeQLearning().then(()=>{}).catch(e=>{})))})}setupNetworkConfiguration(){this.networkConfig.currentArchitecture=getPreset(this.networkConfig.preset);const e=document.getElementById("network-preset"),t=document.getElementById("preset-description"),i=document.getElementById("custom-architecture");if(e){e.addEventListener("change",e=>{const s=e.target.value;if(this.networkConfig.preset=s,"CUSTOM"===s)i.style.display="block",this.setupCustomArchitecture();else{i.style.display="none";const e=getPreset(s);this.networkConfig.currentArchitecture=e,t.textContent=e.description,this.updateArchitectureDisplay(),this.app.updateNetworkArchitecture(e)}});const s=getPreset(this.networkConfig.preset);t.textContent=s.description,this.updateArchitectureDisplay()}const s=document.getElementById("layer-count"),a=document.getElementById("layer-count-value");s&&s.addEventListener("input",e=>{const t=parseInt(e.target.value);a.textContent=t,this.updateCustomLayers(t)})}setupCustomArchitecture(){const e=parseInt(document.getElementById("layer-count").value);this.updateCustomLayers(e)}updateCustomLayers(e){const t=document.getElementById("layer-configs");for(t.innerHTML="";this.networkConfig.customLayers.length<e;)this.networkConfig.customLayers.push(8);for(;this.networkConfig.customLayers.length>e;)this.networkConfig.customLayers.pop();for(let i=0;i<e;i++){const e=document.createElement("div");e.className="layer-config",e.innerHTML=`\n                <label>Layer ${i+1}:</label>\n                <input type="range" id="layer-${i}-size" min="1" max="256" step="1" value="${this.networkConfig.customLayers[i]}">\n                <span class="layer-value" id="layer-${i}-value">${this.networkConfig.customLayers[i]}</span>\n            `,t.appendChild(e);const s=e.querySelector("input"),a=e.querySelector(".layer-value");s.addEventListener("input",e=>{const t=parseInt(e.target.value);this.networkConfig.customLayers[i]=t,a.textContent=t,this.updateCustomArchitecture()})}this.updateCustomArchitecture()}updateCustomArchitecture(){try{const e=createCustomArchitecture({name:"Custom",description:"User-defined architecture",layers:[...this.networkConfig.customLayers],maxParameters:1e4,deployment:"web"});this.networkConfig.currentArchitecture=e,this.updateArchitectureDisplay(),this.app.updateNetworkArchitecture(e)}catch(e){this.showArchitectureError(e.message)}}updateArchitectureDisplay(){const e=this.networkConfig.currentArchitecture;if(!e)return;const t=document.getElementById("architecture-display"),i=document.getElementById("parameter-count"),s=document.getElementById("memory-estimate");if(t){const i=e.layers.join(" → ");t.textContent=`Input(${e.inputSize}) → ${i} → Output(${e.outputSize})`}if(i){const t=e.getParameterCount();i.textContent=`Total Parameters: ${t.toLocaleString()}`,i.className=t>1e3?"validation-warning":""}if(s){const t=4*e.getParameterCount()/1024;s.textContent=`Memory: ~${t.toFixed(1)} KB`}this.clearArchitectureError()}showArchitectureError(e){const t=document.querySelector(".architecture-summary");if(t){let i=t.querySelector(".validation-error");i||(i=document.createElement("div"),i.className="validation-error",t.appendChild(i)),i.textContent=`Error: ${e}`}}clearArchitectureError(){const e=document.querySelector(".architecture-summary .validation-error");e&&e.remove()}getNetworkArchitecture(){return this.networkConfig.currentArchitecture}setupKeyboardShortcuts(){document.addEventListener("keydown",e=>{if("INPUT"!==e.target.tagName)switch(e.key.toLowerCase()){case" ":e.preventDefault(),this.app.isTraining&&this.app.pauseTraining();break;case"s":e.preventDefault(),this.app.isTraining?this.app.stopTraining():this.app.startTraining();break;case"r":e.preventDefault(),this.app.resetEnvironment();break;case"1":e.preventDefault(),this.app.switchDemoMode("physics");break;case"2":e.preventDefault(),this.app.switchDemoMode("training");break;case"3":e.preventDefault(),this.app.switchDemoMode("evaluation");break;case"h":e.preventDefault(),this.app.renderer.toggleUI("robot")}}),document.addEventListener("keydown",e=>{if("INPUT"!==e.target.tagName&&this.app.userControlEnabled)switch(e.key){case"ArrowLeft":e.preventDefault(),this.app.manualControl.leftPressed=!0,this.app.updateManualTorque(),document.getElementById("control-left")?.classList.add("active");break;case"ArrowRight":e.preventDefault(),this.app.manualControl.rightPressed=!0,this.app.updateManualTorque(),document.getElementById("control-right")?.classList.add("active");break;case"ArrowUp":e.preventDefault(),this.app.isTraining||this.app.resetRobotPosition(),document.getElementById("control-reset")?.classList.add("active")}}),document.addEventListener("keyup",e=>{if("INPUT"!==e.target.tagName&&this.app.userControlEnabled)switch(e.key){case"ArrowLeft":e.preventDefault(),this.app.manualControl.leftPressed=!1,this.app.updateManualTorque(),document.getElementById("control-left")?.classList.remove("active");break;case"ArrowRight":e.preventDefault(),this.app.manualControl.rightPressed=!1,this.app.updateManualTorque(),document.getElementById("control-right")?.classList.remove("active");break;case"ArrowUp":e.preventDefault(),document.getElementById("control-reset")?.classList.remove("active")}})}setParameter(e,t){const i=this.validationRanges[e];i&&(t=Math.max(i.min,Math.min(i.max,t))),this.parameters[e]=t,this.saveParameters(),this.updateAllDisplays(),this.app&&this.app.robot&&("maxAngle"===e?this.app.updateMaxAngle(t):"motorTorqueRange"===e&&this.app.updateMotorTorqueRange(t))}getParameter(e){return this.parameters[e]}updateAllDisplays(){document.getElementById("training-speed").value=this.parameters.trainingSpeed,document.getElementById("training-speed-value").textContent=`${this.parameters.trainingSpeed.toFixed(1)}x`,document.getElementById("learning-rate").value=this.parameters.learningRate,document.getElementById("learning-rate-value").textContent=this.parameters.learningRate.toFixed(4),document.getElementById("gamma").value=this.parameters.gamma,document.getElementById("gamma-value").textContent=this.parameters.gamma.toFixed(3),document.getElementById("epsilon").value=this.parameters.epsilon,document.getElementById("epsilon-value").textContent=this.parameters.epsilon.toFixed(2),document.getElementById("epsilon-min").value=this.parameters.epsilonMin,document.getElementById("epsilon-min-value").textContent=this.parameters.epsilonMin.toFixed(3),document.getElementById("epsilon-decay").value=this.parameters.epsilonDecay,document.getElementById("epsilon-decay-value").textContent=this.parameters.epsilonDecay.toString(),document.getElementById("batch-size").value=this.parameters.batchSize,document.getElementById("batch-size-value").textContent=this.parameters.batchSize.toString(),document.getElementById("target-update-freq").value=this.parameters.targetUpdateFreq,document.getElementById("target-update-freq-value").textContent=this.parameters.targetUpdateFreq.toString(),document.getElementById("max-episodes").value=this.parameters.maxEpisodes,document.getElementById("max-episodes-value").textContent=this.parameters.maxEpisodes.toString(),document.getElementById("max-steps-per-episode").value=this.parameters.maxStepsPerEpisode,document.getElementById("max-steps-per-episode-value").textContent=this.parameters.maxStepsPerEpisode.toString(),document.getElementById("robot-mass").value=this.parameters.robotMass,document.getElementById("robot-mass-value").textContent=`${this.parameters.robotMass.toFixed(1)} kg`,document.getElementById("robot-height").value=this.parameters.robotHeight,document.getElementById("robot-height-value").textContent=`${this.parameters.robotHeight.toFixed(2)} m`,document.getElementById("motor-strength").value=this.parameters.motorStrength,document.getElementById("motor-strength-value").textContent=`${this.parameters.motorStrength.toFixed(1)} Nm`,document.getElementById("wheel-friction")&&(document.getElementById("wheel-friction").value=this.parameters.wheelFriction,document.getElementById("wheel-friction-value").textContent=this.parameters.wheelFriction.toFixed(2)),document.getElementById("max-angle")&&(document.getElementById("max-angle").value=this.parameters.maxAngle,document.getElementById("max-angle-value").textContent=`${(180*this.parameters.maxAngle/Math.PI).toFixed(1)}°`),document.getElementById("motor-torque-range")&&(document.getElementById("motor-torque-range").value=this.parameters.motorTorqueRange,document.getElementById("motor-torque-range-value").textContent=`±${this.parameters.motorTorqueRange.toFixed(1)} Nm`)}saveParameters(){try{localStorage.setItem("twowheelbot-rl-parameters",JSON.stringify(this.parameters))}catch(e){}}loadParameters(){try{const e=localStorage.getItem("twowheelbot-rl-parameters");if(e){const t=JSON.parse(e);this.parameters={...this.parameters,...t}}}catch(e){}}setSpeedPreset(e){this.setParameter("trainingSpeed",e),document.getElementById("training-speed").value=e,document.getElementById("training-speed-value").textContent=`${e.toFixed(1)}x`,this.app.setTrainingSpeed(e),this.parallelModeEnabled=!1,this.app.setParallelMode(!1)}enableParallelTraining(){this.parallelModeEnabled=!0,document.getElementById("training-speed-value").textContent="Parallel Mode",this.app.setParallelMode(!0),this.isTraining}resetToDefaults(){this.parameters={trainingSpeed:1,hiddenNeurons:8,learningRate:.002,gamma:.99,epsilon:.9,epsilonMin:.01,epsilonDecay:2500,batchSize:128,targetUpdateFreq:100,maxEpisodes:1e3,maxStepsPerEpisode:1e3,robotMass:1,robotHeight:.4,motorStrength:5,wheelFriction:.3},this.updateAllDisplays(),this.saveParameters()}syncParametersFromQLearning(){if(!this.app.qlearning)return;const e=this.app.qlearning.hyperparams;this.parameters.learningRate=e.learningRate,this.parameters.gamma=e.gamma,this.parameters.epsilon=e.epsilon,this.parameters.epsilonMin=e.epsilonMin,this.parameters.epsilonDecay=e.epsilonDecay,this.parameters.batchSize=e.batchSize,this.parameters.targetUpdateFreq=e.targetUpdateFreq,this.parameters.maxEpisodes=e.maxEpisodes,this.parameters.maxStepsPerEpisode=e.maxStepsPerEpisode,this.updateParameterDisplays(["epsilon","gamma","learningRate","epsilonMin","epsilonDecay","batchSize","targetUpdateFreq","maxEpisodes","maxStepsPerEpisode"])}updateParameterDisplays(e){e.forEach(e=>{const t=this.getElementIdForParameter(e),i=`${t}-value`,s=document.getElementById(t),a=document.getElementById(i);s&&a&&(s.value=this.parameters[e],a.textContent=this.formatParameterValue(e,this.parameters[e]))})}getElementIdForParameter(e){return{learningRate:"learning-rate",gamma:"gamma",epsilon:"epsilon",epsilonMin:"epsilon-min",epsilonDecay:"epsilon-decay",batchSize:"batch-size",targetUpdateFreq:"target-update-freq",maxEpisodes:"max-episodes",maxStepsPerEpisode:"max-steps-per-episode"}[e]||e}formatParameterValue(e,t){switch(e){case"learningRate":return t.toFixed(4);case"gamma":case"epsilonMin":return t.toFixed(3);case"epsilon":return t.toFixed(2);default:return t.toString()}}}class TwoWheelBotRL{static{__name(this,"TwoWheelBotRL")}constructor(){this.canvas=null,this.renderer=null,this.webgpuBackend=null,this.isInitialized=!1,this.robot=null,this.qlearning=null,this.uiControls=null,this.performanceCharts=null,this.systemCapabilities=null,this.parallelQLearning=null,this.performanceTracker=new TrainingPerformanceTracker,this.smartRenderingManager=new SmartRenderingManager(this.performanceTracker,{targetFPS:60,mode:"interval"}),this._isTraining=!1,this.isPaused=!1,this.trainingStep=0,this.episodeCount=0,this.bestScore=0,this.currentReward=0,this.lastQValue=0,this.trainingSpeed=1,this.targetPhysicsStepsPerFrame=1,this.episodeEnded=!1,this.parallelModeEnabled=!1,this.resetAngleDegrees=0,this.maxOffsetRangeDegrees=5,this.debugSpeed=1,this.debugLastAction="None",this.debugCurrentReward=0,this.demoMode="freerun",this.currentModelName="No model loaded",this.modelHasUnsavedChanges=!1,this.trainingStartTime=null,this.manualControl={enabled:!1,leftPressed:!1,rightPressed:!1,upPressed:!1,manualTorque:0},this.simulationInterval=null,this.pdControllerEnabled=!0,this.userControlOnlyEnabled=!1,this.userControlEnabled=!0,this.currentNetworkArchitecture=null,this.lastPhysicsUpdate=0,this.physicsUpdateInterval=20,this.frameTimeHistory=[],this.lastFrameTime=0,this.performanceCheckInterval=60,this.webgpuStatus={checked:!1,available:!1,deviceInfo:null,error:null},this.previousState=null,this.previousAction=void 0,this.previousReward=0,this.previousDone=!1,this.lastTrainingLoss=0}async initialize(){try{this.showLoading(!0),this.initializeRenderer(),await this.initializeComponents(),await this.initializeWebGPUBackend(),this.initializeControls(),this.uiControls=new UIControls(this),this.uiControls.initialize(),this.systemCapabilities=new SystemCapabilities,this.updateWebGPUStatusDisplay(),this.updateCPUCoresStatusDisplay(),this.startSimulation(),this.updatePDControllerUI(),this.updateUserControlOnlyUI(),this.updateFreeRunSpeedUI(),this.updateModelDisplay("No model loaded",null),this.isInitialized=!0}catch(e){this.showError("Failed to initialize application: "+e.message)}finally{this.showLoading(!1)}}get isTraining(){return this._isTraining}set isTraining(e){this._isTraining,this._isTraining=e}initializeRenderer(){if(this.canvas=document.getElementById("simulation-canvas"),!this.canvas)throw new Error("Canvas element not found");this.resizeCanvas(),this.renderer=createRenderer(this.canvas,{showGrid:!0,showDebugInfo:!0,showPerformance:!0,targetFPS:60}),window.addEventListener("resize",()=>this.resizeCanvas());const e=document.getElementById("charts-panel");e&&(this.performanceCharts=createPerformanceCharts(e),this.performanceCharts.start())}async initializeWebGPUBackend(){const e=document.getElementById("webgpu-text");try{e.textContent="Initializing WebGPU...",this.webgpuBackend=new WebGPUBackend;const t=await checkWebGPUAvailability();this.webgpuStatus.checked=!0,this.webgpuStatus.available=t.available,t.available?(e.textContent="WebGPU Available",e.className="status-available"):(e.textContent="WebGPU Unavailable (CPU fallback)",e.className="status-unavailable",this.webgpuStatus.error=t.reason),setTimeout(()=>{const e=document.getElementById("webgpu-status");e&&(e.style.display="none")},1e4),this.webgpuStatus.deviceInfo=t}catch(t){e.textContent="WebGPU Error (CPU fallback)",e.className="status-unavailable",setTimeout(()=>{const e=document.getElementById("webgpu-status");e&&(e.style.display="none")},1e4),this.webgpuStatus.checked=!0,this.webgpuStatus.available=!1,this.webgpuStatus.error=t.message,this.webgpuBackend=new WebGPUBackend}}initializeControls(){document.getElementById("start-training").addEventListener("click",()=>{this.isTraining?this.stopTraining():this.startTraining()}),document.getElementById("pause-training").addEventListener("click",()=>{this.pauseTraining()}),document.getElementById("reset-environment").addEventListener("click",()=>{this.resetEnvironment()}),document.getElementById("toggle-physics").addEventListener("click",()=>{this.switchDemoMode("physics")}),document.getElementById("toggle-network").addEventListener("click",()=>{this.renderer.toggleUI("robot")}),document.getElementById("toggle-metrics").addEventListener("click",()=>{this.renderer.toggleUI("training")}),document.getElementById("save-model").addEventListener("click",()=>{this.saveModelToLocalStorage()}),document.getElementById("test-model-btn")?.addEventListener("click",()=>{this.testModel()}),document.getElementById("export-model").addEventListener("click",()=>{this.exportModelToCpp()}),document.getElementById("import-model").addEventListener("click",()=>{this.importModelFromCpp()}),document.getElementById("reset-parameters").addEventListener("click",()=>{this.resetModelParameters()}),document.getElementById("refresh-webgpu").addEventListener("click",()=>{this.updateWebGPUStatusDisplay()}),document.getElementById("zoom-in-btn")?.addEventListener("click",()=>{this.renderer&&this.renderer.transform.zoomIn()}),document.getElementById("zoom-out-btn")?.addEventListener("click",()=>{this.renderer&&this.renderer.transform.zoomOut()}),document.getElementById("zoom-reset-btn")?.addEventListener("click",()=>{this.renderer&&this.renderer.transform.resetZoom()}),document.getElementById("toggle-pd-controller")?.addEventListener("click",()=>{this.togglePDController()}),document.getElementById("toggle-user-control-only")?.addEventListener("click",()=>{this.toggleUserControlOnly()}),document.getElementById("reward-function")?.addEventListener("change",e=>{this.setRewardFunction(e.target.value)}),this.setupOnScreenControls(),this.setupCollapsibleSections(),this.refreshModelList()}setupCollapsibleSections(){const e=document.querySelectorAll(".control-section h3");e.forEach(e=>{e.addEventListener("click",()=>{const t=e.parentElement;t.classList.toggle("collapsed");const i=e.textContent.trim(),s=t.classList.contains("collapsed");localStorage.setItem(`section-${i}`,s.toString())})}),e.forEach(e=>{const t=e.textContent.trim(),i=localStorage.getItem(`section-${t}`);if(null!==i){const t=e.parentElement;"true"===i?t.classList.add("collapsed"):t.classList.remove("collapsed")}})}async startTraining(){if(this.isTraining)return;this.qlearning||await this.initializeQLearning();const e=document.getElementById("training-speed");if(e){const t=parseFloat(e.value);this.setTrainingSpeed(t)}this.isTraining=!0,this.isPaused=!1,this.demoMode="training",this.updateFreeRunSpeedUI(),this.robot&&this.maxOffsetRangeDegrees>0&&this.robot.setTrainingOffsetRange(this.maxOffsetRangeDegrees),this.trainingStartTime=new Date;const t=this.trainingStartTime.toISOString().replace(/[:.]/g,"-").slice(0,-5);"No model loaded"!==this.currentModelName&&this.currentModelName.startsWith("TwoWheelBot_DQN_")||(this.currentModelName=`Unsaved_DQN_${t}`),this.modelHasUnsavedChanges=!0,this.qlearning&&0!==this.episodeCount||(this.episodeCount=0,this.trainingStep=0,this.bestScore=-1/0),this.updateTrainingModelDisplay(),this.startNewEpisode();const i=document.getElementById("start-training");i.textContent="Stop Training",i.classList.remove("primary"),i.classList.add("danger"),i.disabled=!1,document.getElementById("pause-training").disabled=!1,this.updatePDControllerUI()}stopTraining(){if(!this.isTraining)return;this.isTraining=!1,this.isPaused=!1,this.demoMode="freerun",this.trainingSpeed=1,this.targetPhysicsStepsPerFrame=1,this.episodeCount=0,this.trainingStep=0,this.bestScore=0,this.currentReward=0,this.qlearning&&(this.qlearning.episode=0,this.qlearning.stepCount=0,this.qlearning.globalStepCount=0,this.qlearning.lastTargetUpdate=0,this.qlearning.hyperparams.epsilon=this.qlearning.initialEpsilon||.9,this.qlearning.replayBuffer.clear()),this.performanceTracker&&this.performanceTracker.reset(),this.performanceCharts&&"function"==typeof this.performanceCharts.reset&&this.performanceCharts.reset(),this.previousState=null,this.previousAction=void 0,this.previousReward=0,this.previousDone=!1,this.lastTrainingLoss=0;const e=document.getElementById("start-training"),t=document.getElementById("pause-training");e.textContent="Start Training",e.classList.remove("danger"),e.classList.add("primary"),t.textContent="Pause Training",t.disabled=!0,this.updateTrainingModelDisplay(),this.updatePDControllerUI(),this.updateUserControlOnlyUI(),this.updateOnScreenControlsVisibility(),this.robot.reset(),this.isInitialized&&this.startSimulation()}pauseTraining(){if(!this.isTraining)return;this.isPaused=!this.isPaused;document.getElementById("pause-training").textContent=this.isPaused?"Resume Training":"Pause Training",this.updateTrainingModelDisplay()}resetEnvironment(){if(this.isTraining=!1,this.isPaused=!1,this.parallelModeEnabled=!1,this.demoMode="freerun",this.pdControllerEnabled=!0,this.userControlOnlyEnabled=!1,this.trainingStep=0,this.episodeCount=0,this.bestScore=0,this.currentReward=0,this.episodeEnded=!1,this.previousState=null,this.previousAction=void 0,this.previousReward=0,this.previousDone=!1,this.lastTrainingLoss=0,this.qlearning&&this.qlearning.reset(),this.parallelQLearning&&(this.parallelQLearning.cleanup(),this.parallelQLearning=null),this.performanceCharts&&this.performanceCharts.reset(),this.robot){let e=0;if("freerun"===this.demoMode&&Math.abs(this.resetAngleDegrees)>0){e=(this.resetAngleDegrees||0)*Math.PI/180}this.robot.reset({angle:e,angularVelocity:0,position:0,velocity:0})}document.getElementById("start-training").disabled=!1,document.getElementById("pause-training").disabled=!0,document.getElementById("pause-training").textContent="Pause Training";const e=document.getElementById("parallel-training");e&&(e.textContent="Parallel",e.classList.remove("active")),this.updateFreeRunSpeedUI(),this.updatePDControllerUI(),this.updateUserControlOnlyUI(),this.updateOnScreenControlsVisibility(),this.updateUI()}resizeCanvas(){const e=document.getElementById("main-container"),t=document.getElementById("controls-panel"),i=e.clientWidth,s=e.clientHeight,a=i-(t?t.offsetWidth:300),r=s,n=window.devicePixelRatio||1;this.canvas.style.width=a+"px",this.canvas.style.height=r+"px";const o=a*n,h=r*n;if(this.canvas.width=o,this.canvas.height=h,this.renderer){this.renderer.resize(o,h);this.canvas.getContext("2d").setTransform(n,0,0,n,0,0)}}startSimulation(){this.stopSimulation(),this.renderer.start(),"interval"===this.smartRenderingManager.renderingMode?this.startHighPerformanceSimulation():this.startDisplaySyncedSimulation()}stopSimulation(){this.simulationInterval&&(clearInterval(this.simulationInterval),this.simulationInterval=null)}startDisplaySyncedSimulation(){const e=__name(t=>{this.isInitialized&&(this.runSimulationFrame(t||performance.now()),requestAnimationFrame(e))},"simulate");requestAnimationFrame(e)}startHighPerformanceSimulation(){const e=1e3/this.smartRenderingManager.actualTargetFPS;let t;t=this.trainingSpeed<=20||this.trainingSpeed<=100?e:1;let i=performance.now(),s=0;const a=__name(async()=>{if(!this.isInitialized)return;const e=performance.now();if(s++,s%60==0){}await this.runSimulationFrame(e),i=e},"simulate");this.simulationInterval=setInterval(a,t)}async runSimulationFrame(e){if(this.lastFrameTime>0){const t=e-this.lastFrameTime;if(this.frameTimeHistory.push(t),this.frameTimeHistory.length>this.performanceCheckInterval&&this.frameTimeHistory.shift(),t>50&&Math.random(),this.frameTimeHistory.length===this.performanceCheckInterval){const e=this.frameTimeHistory.reduce((e,t)=>e+t)/this.frameTimeHistory.length;this.smartRenderingManager.actualTargetFPS;const t=this.smartRenderingManager.shouldRenderFrame(this.trainingSpeed);e>200&&this.targetPhysicsStepsPerFrame>500&&t&&this.setTrainingSpeed(Math.max(50,.8*this.trainingSpeed))}}let t;if(this.lastFrameTime=e,t="freerun"===this.demoMode?Math.max(1,16.67/this.debugSpeed):"training"===this.demoMode&&(this.parallelModeEnabled||this.trainingSpeed>100)?0:this.physicsUpdateInterval,e-this.lastPhysicsUpdate>=t){await this.updatePhysics();const t=this.parallelModeEnabled?1e3:this.trainingSpeed;this.smartRenderingManager.shouldRenderFrame(t)&&(this.updateRenderer(),this.updateUI()),this.lastPhysicsUpdate=e}}async updatePhysics(){if(!this.robot)return;const e=performance.now();let t;if("freerun"===this.demoMode){const e=this.robot?this.robot.historyTimesteps:1,i=Math.max(1,Math.round(3*this.debugSpeed));t=Math.max(i,e)}else t=this.parallelModeEnabled?1e3:this.trainingSpeed<=100?Math.max(3,this.targetPhysicsStepsPerFrame):this.trainingSpeed<=200?Math.min(this.targetPhysicsStepsPerFrame,500):Math.min(this.targetPhysicsStepsPerFrame,1e3);const i=this.isPaused?1:t;let s=0,a=0,r=0;for(let n=0;n<i;n++){if(performance.now(),n>0&&n%50==0){const e=performance.now();await new Promise(e=>setTimeout(e,0)),r+=performance.now()-e}let e=0,t=0;const o=this.robot.getNormalizedInputs();switch(this.demoMode){case"freerun":e=this.manualControl.leftPressed||this.manualControl.rightPressed?this.getManualTorque():this.userControlOnlyEnabled?0:this.pdControllerEnabled?this.getPhysicsDemoTorque():this.qlearning?this.getEvaluationTorque():0;break;case"training":if(this.isTraining&&!this.isPaused){const i=this.getTrainingTorqueWithAction();e=i.torque,t=i.actionIndex}else e=this.userControlEnabled&&(this.manualControl.leftPressed||this.manualControl.rightPressed)?this.getManualTorque():this.userControlOnlyEnabled?0:this.pdControllerEnabled?this.getPhysicsDemoTorque():this.qlearning?this.getEvaluationTorque():0}const h=performance.now(),l=this.robot.step(e);if(s+=performance.now()-h,this.currentReward=l.reward,(!this.robot.isStable()||!isFinite(l.reward))&&"training"===this.demoMode&&this.isTraining)return this.episodeEnded=!0,void this.handleEpisodeEnd({...l,done:!0,reward:-10});if("freerun"===this.demoMode&&(this.debugCurrentReward=l.reward),"training"===this.demoMode&&this.isTraining&&!this.isPaused&&this.qlearning){const e=this.robot.getNormalizedInputs(),s=this._shouldTrainThisStep(n,i);if(this.previousState&&void 0!==this.previousAction&&s){const t=performance.now(),i=this.qlearning.train(this.previousState,this.previousAction,this.previousReward,e,this.previousDone);a+=performance.now()-t,this.lastTrainingLoss=isFinite(i)?i:0}if(l.done){const i=this.qlearning.train(o,t,l.reward,e,l.done);this.lastTrainingLoss=isFinite(i)?i:0,this.previousState=null,this.previousAction=void 0,this.previousReward=0,this.previousDone=!1}else this.previousState=o.slice(),this.previousAction=t,this.previousReward=l.reward,this.previousDone=l.done}if(l.done&&"training"===this.demoMode&&!this.isPaused&&!this.episodeEnded)return this.episodeEnded=!0,void this.handleEpisodeEnd(l);if(this.episodeEnded)break;if(this.isTraining&&!this.isPaused){this.trainingStep++,this.performanceTracker.recordStep();const e=this.uiControls?.getParameter("maxStepsPerEpisode")||1e3;if(this.trainingStep>=e&&!this.episodeEnded&&"training"===this.demoMode){this.episodeEnded=!0;const e={state:this.robot.getState(),reward:1,done:!0};this.handleEpisodeEnd(e);break}const t=this.robot.getState(),i=this.renderer?this.renderer.getPhysicsBounds():null;if(i&&(t.position<i.minX||t.position>i.maxX)){if("training"===this.demoMode&&!this.episodeEnded){this.episodeEnded=!0;const e={state:this.robot.getState(),reward:-1,done:!0};this.handleEpisodeEnd(e);break}"manual"!==this.demoMode&&"physics"!==this.demoMode||this.robot.reset({angle:0,angularVelocity:0,position:0,velocity:0})}}}performance.now();this.trainingSpeed>=40&&Math.random()}updateRenderer(){if(!this.renderer||!this.robot)return;const e=this.robot.getState(),t=this.robot.getConfig(),i=this.robot.getStats();this.renderer.updateRobot(e,t,i.currentMotorTorque);const s={episode:this.episodeCount,step:this.trainingStep,reward:this.currentReward,totalReward:i.totalReward,bestReward:this.bestScore,epsilon:this.qlearning?this.qlearning.hyperparams.epsilon:0,isTraining:this.isTraining,trainingMode:this.demoMode};this.renderer.updateTraining(s)}updateUI(){if(document.getElementById("training-step").textContent=`Step: ${this.trainingStep.toLocaleString()}`,document.getElementById("episode-count").textContent=`Episode: ${this.episodeCount}`,document.getElementById("best-score").textContent=`Best Score: ${this.bestScore.toFixed(1)}`,document.getElementById("current-reward").textContent=`Current Reward: ${this.currentReward.toFixed(1)}`,this.qlearning&&(document.getElementById("epsilon-display").textContent=`Epsilon: ${this.qlearning.hyperparams.epsilon.toFixed(3)}`,document.getElementById("consecutive-episodes").textContent=`Consecutive Max Episodes: ${this.qlearning.consecutiveMaxEpisodes}/20`,this.uiControls&&this.uiControls.syncParametersFromQLearning()),document.getElementById("training-loss").textContent=`Training Loss: ${this.lastTrainingLoss.toFixed(4)}`,document.getElementById("qvalue-estimate").textContent=`Q-Value: ${this.lastQValue.toFixed(3)}`,this.updateHistoryDebugDisplay(),"freerun"===this.demoMode){const e=this.robot?this.robot.getState():null;e&&(document.getElementById("debug-last-action").textContent=this.debugLastAction,document.getElementById("debug-current-reward").textContent=this.debugCurrentReward.toFixed(3),document.getElementById("debug-robot-angle").textContent=`${(180*e.angle/Math.PI).toFixed(2)}°`,document.getElementById("debug-angular-velocity").textContent=`${e.angularVelocity.toFixed(3)} rad/s`)}const e=document.getElementById("training-status-indicator");if(this.isTraining&&!this.isPaused?e.className="status-indicator training":this.isTraining&&this.isPaused?e.className="status-indicator paused":e.className="status-indicator stopped",this.renderer){const e=this.renderer.performance.getMetrics();document.getElementById("fps-counter").textContent=`FPS: ${e.fps}`}this.updateBackendPerformanceDisplay()}updateHistoryDebugDisplay(){const e=document.getElementById("history-debug-content");if(!e||!this.robot)return;const t=this.robot.getState(),i=this.robot.historyTimesteps||1,s=this.robot.getNormalizedInputs();let a=[];if("offset-adaptive"===this.robot.rewardType){const e=this.robot.getMeasuredAngle(),i=t.angle,s=this.robot.angleOffset;a.push(`True: angle=${i.toFixed(3)}, angVel=${t.angularVelocity.toFixed(3)}`),a.push(`Measured: angle=${e.toFixed(3)}, offset=${s.toFixed(3)}`)}else a.push(`Current: angle=${t.angle.toFixed(3)}, angVel=${t.angularVelocity.toFixed(3)}`);a.push(`Network Input [${i}x]:`);for(let r=0;r<s.length;r+=2){const e=s[r],t=s[r+1],i=r/2+1;a.push(`  T${i}: [${e.toFixed(2)}, ${t.toFixed(2)}]`)}if(a.push(`Timesteps: ${i} (${s.length} inputs total)`),this.robot.stateHistory&&i>1){const e=this.robot.stateHistory.getStats();a.push(`Avg Angle: ${e.averageAngle.toFixed(3)}, StdDev: ${e.angleStdDev.toFixed(3)}`)}e.innerHTML=a.map(e=>`<div>${e}</div>`).join("")}updateWebGPUStatusDisplay(){const e=document.getElementById("backend-type"),t=document.getElementById("device-info"),i=document.getElementById("performance-estimate");if(!this.webgpuBackend)return e.textContent="Backend: Not initialized",t.textContent="WebGPU backend not yet initialized",void(i.textContent="");const s=this.webgpuBackend.getBackendInfo(),a=s.deviceInfo,r=s.webgpuAvailable?"WebGPU":"CPU (Fallback)";if(e.textContent=`Backend: ${r}`,s.webgpuAvailable&&a.adapterInfo){const e=a.adapterInfo;t.innerHTML=`\n                <div>Vendor: ${e.vendor}</div>\n                <div>Device: ${e.device}</div>\n                <div>Architecture: ${e.architecture}</div>\n            `}else s.fallbackReason?t.innerHTML=`\n                <div style="color: #ff6666;">Fallback reason:</div>\n                <div>${s.fallbackReason}</div>\n            `:t.textContent="No detailed device information available";if(s.capabilities&&s.webgpuAvailable){const e=s.capabilities;i.innerHTML=`\n                <div>Estimated speedup: ${e.estimatedSpeedup.toFixed(1)}x</div>\n                <div>Max workgroup size: ${e.maxWorkgroupSize||"Unknown"}</div>\n                <div>Max buffer size: ${e.maxBufferSizeMB||"Unknown"} MB</div>\n            `}else i.textContent="CPU backend - no hardware acceleration"}updateCPUCoresStatusDisplay(){const e=document.getElementById("cores-info"),t=document.getElementById("workers-info"),i=document.getElementById("parallel-speedup");if(!this.systemCapabilities)return e.textContent="CPU Cores: Not detected",t.textContent="Parallel training unavailable",void(i.textContent="");const s=this.systemCapabilities.coreCount,a=this.systemCapabilities.targetCores,r=this.systemCapabilities.maxWorkers;if(e.textContent=`CPU Cores: ${s} detected`,t.innerHTML=r>1?`\n                <div>Using ${a} cores (50% of ${s})</div>\n                <div>Worker threads: ${r}</div>\n            `:'\n                <div style="color: #ff6666;">Single core detected</div>\n                <div>Parallel training disabled</div>\n            ',this.parallelQLearning){const e=this.parallelQLearning.getPerformanceStats();e.speedupFactor>1?i.innerHTML=`\n                    <div>Training speedup: ${e.speedupFactor.toFixed(1)}x</div>\n                    <div>Parallel episodes: ${e.totalParallelEpisodes}</div>\n                `:i.textContent="Speedup measurement in progress..."}else i.textContent=r>1?`Estimated speedup: ${Math.min(r,4).toFixed(1)}x`:"No parallel acceleration"}updatePerformanceMetricsDisplay(){const e=document.getElementById("episodes-per-minute"),t=document.getElementById("steps-per-second"),i=document.getElementById("rendering-mode"),s=document.getElementById("training-efficiency");if(!this.performanceTracker)return;const a=this.performanceTracker.getDisplayStats();if(e&&(e.textContent=`Episodes/min: ${a.episodesPerMinute}`),t&&(t.textContent=`Steps/sec: ${a.stepsPerSecond}`),i){const e=a.renderingMode;let t="#ffaa00";e.includes("Full")?t="#00ff88":e.includes("Sparse")?t="#ffaa00":e.includes("Minimal")&&(t="#ff6666"),i.innerHTML=`<span style="color: ${t}">Rendering: ${e}</span>`}if(s){const e=parseFloat(a.trainingEfficiency.replace("%",""));let t="#00d4ff";e>=80?t="#00ff88":e>=50?t="#ffaa00":e>0&&(t="#ff6666"),s.innerHTML=`<span style="color: ${t}">Training efficiency: ${a.trainingEfficiency}</span>`}}updateBackendPerformanceDisplay(){const e=document.getElementById("backend-performance");if(!this.webgpuBackend)return void(e.textContent="");const t=this.webgpuBackend.getPerformanceMetrics();if(t.totalForwardPasses>0){const i=t.averageForwardTime.toFixed(2),s=t.estimatedSpeedup.toFixed(1);e.textContent=`Avg forward pass: ${i}ms | Est. speedup: ${s}x`}else e.textContent="No performance data yet"}showLoading(e){document.getElementById("loading").style.display=e?"flex":"none"}showError(e){alert("Error: "+e)}destroy(){this.renderer&&(this.renderer.destroy(),this.renderer=null),this.webgpuBackend&&(this.webgpuBackend.destroy(),this.webgpuBackend=null),this.robot=null,this.qlearning=null}async initializeComponents(){const e=new UIControls(this),t=.02/3;this.robot=createDefaultRobot({mass:e.getParameter("robotMass"),centerOfMassHeight:e.getParameter("robotHeight"),motorStrength:e.getParameter("motorStrength"),friction:.1,damping:.05,timestep:t,maxAngle:e.getParameter("maxAngle"),motorTorqueRange:e.getParameter("motorTorqueRange"),rewardType:"complex"}),this.maxOffsetRangeDegrees>0&&this.robot.setTrainingOffsetRange(this.maxOffsetRangeDegrees),this.robot.reset({angle:.1*(Math.random()-.5),angularVelocity:0,position:0,velocity:0})}async initializeQLearning(e={}){const t=2*(this.robot?this.robot.historyTimesteps:1),i=this.uiControls?{learningRate:this.uiControls.getParameter("learningRate"),epsilon:this.uiControls.getParameter("epsilon"),epsilonDecay:.995,maxEpisodes:1e3,maxStepsPerEpisode:1e3,hiddenSize:this.uiControls.getParameter("hiddenNeurons"),...e}:{learningRate:.002,epsilon:.3,epsilonDecay:.995,gamma:.95,batchSize:8,targetUpdateFreq:100,maxEpisodes:1e3,maxStepsPerEpisode:1e3,hiddenSize:8,...e};if(this.qlearning=createDefaultQLearning(i),this.webgpuBackend,await this.qlearning.initialize(t),this.systemCapabilities&&this.systemCapabilities.maxWorkers>1&&(this.parallelQLearning=new ParallelQLearning(this.qlearning,this.robot),await this.parallelQLearning.initialize()),this.webgpuBackend){this.webgpuBackend.getBackendInfo().usingFallback}}getPhysicsDemoTorque(){const e=this.robot.getState(),t=20*this.robot.getMeasuredAngle()+5*e.angularVelocity;Math.abs(this.robot.angleOffset)>.01&&Math.random();const i=.5*(Math.random()-.5);return Math.max(-5,Math.min(5,t+i))}getTrainingTorque(){return this.getTrainingTorqueWithAction().torque}getTrainingTorqueWithAction(){if(!this.qlearning)return{torque:0,actionIndex:0};const e=this.robot.getNormalizedInputs();if(Math.abs(this.robot.angleOffset)>.01&&Math.random()<.01){this.robot.getState().angle,this.robot.getMeasuredAngle()}const t=this.qlearning.getAllQValues(e),i=this.qlearning.selectAction(e,!0);if(t&&t.length>0){const e=Array.from(t).filter(e=>isFinite(e));this.lastQValue=e.length>0?Math.max(...e):0,this.trainingStep}else this.lastQValue=0;return{torque:[-1,0,1][i],actionIndex:i}}getEvaluationTorque(){if(!this.qlearning)return 0;const e=this.robot.getNormalizedInputs();return[-1,0,1][this.qlearning.selectAction(e,!1)]}async startNextEpisodeOrBatch(){try{this.shouldUseParallelTraining()?await this.runParallelEpisodeBatch():this.startNewEpisode()}catch(e){this.isTraining=!1,this.isPaused=!1,this.demoMode="freerun";const t=document.getElementById("start-training"),i=document.getElementById("pause-training");t&&(t.disabled=!1),i&&(i.disabled=!0,i.textContent="Pause Training"),this.updateTrainingModelDisplay(),this.updateOnScreenControlsVisibility(),alert("Training stopped due to an error. Please check the console for details and try starting training again.")}}shouldUseParallelTraining(){return!(!this.parallelQLearning||!this.parallelQLearning.parallelManager.parallelEnabled)&&this.parallelModeEnabled}async runParallelEpisodeBatch(){try{const e=this.parallelQLearning.parallelManager.config.batchSize,t=e,i=Date.now();this.performanceTracker.startEpisode();const s=await this.parallelQLearning.parallelManager.runEpisodes(t);let a=0,r=0,n=-1/0;for(let u=0;u<s.length;u++){const e=s[u];if(e){const t=e.totalReward||0,i=e.stepCount||0;if(a+=t,r+=i,t>n&&(n=t),this.episodeCount++,t>this.bestScore&&(this.bestScore=t),this.performanceCharts&&this.qlearning){const e=this.robot?this.robot.historyTimesteps:1,i=new Float32Array(2*e).fill(0),s=this.qlearning.getAllQValues(i),a=Array.from(s).reduce((e,t)=>e+t,0)/s.length;this.performanceCharts.updateMetrics({episode:this.episodeCount,reward:t,loss:this.lastTrainingLoss||0,qValue:a,epsilon:this.qlearning.hyperparams.epsilon})}if(e.experiences&&e.experiences.length>0)for(const s of e.experiences)this.qlearning.replayBuffer.addExperience(new Float32Array(s.state),s.action,s.reward,new Float32Array(s.nextState),s.done);await new Promise(e=>setTimeout(e,2))}}let o=0;const h=s.reduce((e,t)=>e+(t?.experiences?.length||0),0);if(this.qlearning.replayBuffer.size()>=this.qlearning.hyperparams.batchSize){const e=t,i=Math.max(1,Math.ceil(h/32)),s=Math.min(e*i,h);for(let t=0;t<s;t++){o+=this.qlearning._trainBatch()||0;t%2===0&&await new Promise(e=>setTimeout(e,0))}this.lastTrainingLoss=s>0?o/s:0}const l=Date.now()-i;this.performanceTracker.endEpisode(r,l);const d=Date.now();this.episodeTimings||(this.episodeTimings={lastEpisodeTime:d,episodeCount:0,recentEpisodes:[],lastLogTime:d});const c=l/e;for(let u=0;u<e;u++)this.episodeTimings.recentEpisodes.push(c),this.episodeTimings.episodeCount++;for(this.episodeTimings.lastEpisodeTime=d;this.episodeTimings.recentEpisodes.length>10;)this.episodeTimings.recentEpisodes.shift();if(this.episodeTimings.episodeCount%5==0){this.episodeTimings.recentEpisodes.reduce((e,t)=>e+t,0),this.episodeTimings.recentEpisodes.length}this.qlearning.stepCount%this.qlearning.hyperparams.targetUpdateFreq===0&&this.qlearning.updateTargetNetwork();s.length,s.length;await new Promise(e=>setTimeout(e,50)),this.isTraining&&this.startNextEpisodeOrBatch()}catch(e){this.startNewEpisode()}}startNewEpisode(){this.trainingStep=0,this.episodeEnded=!1,this.performanceTracker.startEpisode(),this.episodeStartTime=Date.now(),this.previousState=null,this.previousAction=void 0,this.previousReward=0,this.previousDone=!1,this.lastTrainingLoss=0,this.robot.reset({angle:.2*(Math.random()-.5),angularVelocity:.5*(Math.random()-.5),position:0,velocity:0})}handleEpisodeEnd(e){const t=this.robot.getStats().totalReward,i=Date.now()-this.episodeStartTime;if(this.performanceTracker.endEpisode(this.trainingStep,i),t>this.bestScore&&(this.bestScore=t),"training"===this.demoMode&&this.isTraining){this.episodeCount++;const e=Date.now();this.episodeTimings||(this.episodeTimings={lastEpisodeTime:e,episodeCount:0,recentEpisodes:[],lastLogTime:e});const i=e-this.episodeTimings.lastEpisodeTime;if(this.episodeTimings.recentEpisodes.push(i),this.episodeTimings.lastEpisodeTime=e,this.episodeTimings.episodeCount++,this.episodeTimings.recentEpisodes.length>10&&this.episodeTimings.recentEpisodes.shift(),this.episodeTimings.episodeCount%5==0){this.episodeTimings.recentEpisodes.reduce((e,t)=>e+t,0),this.episodeTimings.recentEpisodes.length,this.episodeStartTime,this.trainingSpeed}if(this.updateTrainingModelDisplay(),this.updatePerformanceMetricsDisplay(),this.performanceCharts&&this.qlearning){const e=this.robot?this.robot.historyTimesteps:1,i=new Float32Array(2*e).fill(0),s=this.qlearning.getAllQValues(i),a=Array.from(s).reduce((e,t)=>e+t,0)/s.length;this.performanceCharts.updateMetrics({episode:this.episodeCount,reward:t,loss:this.lastTrainingLoss||0,qValue:a,epsilon:this.qlearning.hyperparams.epsilon})}setTimeout(()=>{try{if(this.isTraining)this.startNextEpisodeOrBatch();else{const e=document.getElementById("start-training"),t=document.getElementById("pause-training");e&&(e.disabled=!1),t&&(t.disabled=!0,t.textContent="Pause Training"),this.updateTrainingModelDisplay()}}catch(e){this.isTraining=!1,this.isPaused=!1,this.demoMode="freerun";const t=document.getElementById("start-training"),i=document.getElementById("pause-training");t&&(t.disabled=!1),i&&(i.disabled=!0,i.textContent="Pause Training"),this.updateOnScreenControlsVisibility(),this.updateTrainingModelDisplay(),alert("Training stopped due to an error. Please check the console and try starting training again.")}},100)}else setTimeout(()=>{this.robot.reset({angle:.2*(Math.random()-.5),angularVelocity:0,position:0,velocity:0}),this.trainingStep=0},1e3)}async switchDemoMode(e){"training"===this.demoMode&&"training"!==e&&(this.isTraining=!1,this.isPaused=!1,document.getElementById("start-training").disabled=!1,document.getElementById("pause-training").disabled=!0,document.getElementById("pause-training").textContent="Pause Training"),"manual"===this.demoMode&&"manual"!==e&&(this.manualControl.enabled=!1,this.manualControl.leftPressed=!1,this.manualControl.rightPressed=!1,this.manualControl.manualTorque=0),this.demoMode=e,"manual"===e&&(this.manualControl.enabled=!0),this.updatePDControllerUI(),this.updateUserControlUI(),this.updateRewardTypeUI(),this.updateOnScreenControlsVisibility(),"training"!==e&&"evaluation"!==e||this.qlearning||await this.initializeQLearning(),this.resetEnvironment()}_shouldTrainThisStep(e,t){return t<=10||(t<=50?e%2==0:t<=100?e%4==0:t<=500?e%10==0:e%20==0)}setTrainingSpeed(e){this.trainingSpeed=Math.max(.1,Math.min(1e3,e)),this.targetPhysicsStepsPerFrame=Math.round(this.trainingSpeed),this.isInitialized&&"interval"===this.smartRenderingManager.renderingMode&&this.startSimulation()}setDebugSpeed(e){this.debugSpeed=Math.max(.1,Math.min(2,e))}setParallelMode(e){this.parallelModeEnabled=e}testModel(){this.qlearning?(this.isTraining&&this.pauseTraining(),this.demoMode="freerun",this.isTraining=!1,this.isPaused=!1,this.pdControllerEnabled=!1,this.userControlOnlyEnabled=!1,this.updateFreeRunSpeedUI(),this.updatePDControllerUI(),this.updateUserControlOnlyUI(),this.robot&&this.robot.reset({angle:.1*(Math.random()-.5),angularVelocity:0,position:0,velocity:0})):alert("No model available for testing!\n\nPlease train a model first or load a saved model.")}updateFreeRunSpeedUI(){const e=document.getElementById("debug-speed"),t=document.querySelector('label[for="debug-speed"]');if(e&&t){const i="freerun"===this.demoMode;e.disabled=!i,e.style.opacity=i?"1":"0.5",t.style.opacity=i?"1":"0.5"}this.updateOnScreenControlsVisibility()}setupOnScreenControls(){document.getElementById("control-left")?.addEventListener("mousedown",()=>{this.userControlEnabled&&(this.manualControl.leftPressed=!0,this.updateManualTorque())}),document.getElementById("control-left")?.addEventListener("mouseup",()=>{this.userControlEnabled&&(this.manualControl.leftPressed=!1,this.updateManualTorque())}),document.getElementById("control-left")?.addEventListener("mouseleave",()=>{this.userControlEnabled&&(this.manualControl.leftPressed=!1,this.updateManualTorque())}),document.getElementById("control-right")?.addEventListener("mousedown",()=>{this.userControlEnabled&&(this.manualControl.rightPressed=!0,this.updateManualTorque())}),document.getElementById("control-right")?.addEventListener("mouseup",()=>{this.userControlEnabled&&(this.manualControl.rightPressed=!1,this.updateManualTorque())}),document.getElementById("control-right")?.addEventListener("mouseleave",()=>{this.userControlEnabled&&(this.manualControl.rightPressed=!1,this.updateManualTorque())}),document.getElementById("control-left")?.addEventListener("touchstart",e=>{e.preventDefault(),this.userControlEnabled&&(this.manualControl.leftPressed=!0,this.updateManualTorque())}),document.getElementById("control-left")?.addEventListener("touchend",e=>{e.preventDefault(),this.userControlEnabled&&(this.manualControl.leftPressed=!1,this.updateManualTorque())}),document.getElementById("control-right")?.addEventListener("touchstart",e=>{e.preventDefault(),this.userControlEnabled&&(this.manualControl.rightPressed=!0,this.updateManualTorque())}),document.getElementById("control-right")?.addEventListener("touchend",e=>{e.preventDefault(),this.userControlEnabled&&(this.manualControl.rightPressed=!1,this.updateManualTorque())}),document.getElementById("control-reset")?.addEventListener("click",()=>{this.resetRobotPosition()})}updateOnScreenControlsVisibility(){const e=document.getElementById("on-screen-controls");if(e){const t="freerun"===this.demoMode;e.style.display=t?"flex":"none"}}updateNetworkArchitecture(e){this.currentNetworkArchitecture="number"==typeof e?{layers:[e],inputSize:2,outputSize:3,getParameterCount:__name(()=>2*e+e+(3*e+3),"getParameterCount")}:e,this.qlearning&&(this.qlearning.hyperparams.hiddenSize=this.currentNetworkArchitecture.layers[0]||8,this.qlearning.hyperparams.networkArchitecture=this.currentNetworkArchitecture)}updateLearningRate(e){this.qlearning&&(this.qlearning.hyperparams.learningRate=e)}updateEpsilon(e){this.qlearning&&(this.qlearning.hyperparams.epsilon=e)}updateGamma(e){this.qlearning&&(this.qlearning.hyperparams.gamma=e)}updateEpsilonMin(e){this.qlearning&&(this.qlearning.hyperparams.epsilonMin=e)}updateEpsilonDecay(e){this.qlearning&&(this.qlearning.hyperparams.epsilonDecay=e)}updateBatchSize(e){this.qlearning&&(this.qlearning.hyperparams.batchSize=e)}updateTargetUpdateFreq(e){this.qlearning&&(this.qlearning.hyperparams.targetUpdateFreq=e)}updateMaxEpisodes(e){this.qlearning&&(this.qlearning.hyperparams.maxEpisodes=e)}updateMaxStepsPerEpisode(e){this.qlearning&&(this.qlearning.hyperparams.maxStepsPerEpisode=e,this.isTraining&&!this.isPaused&&!this.episodeEnded&&this.trainingStep>=e&&"training"===this.demoMode&&(this.episodeEnded=!0,setTimeout(()=>{this.episodeEnded&&this.handleEpisodeEnd({state:this.robot.getState(),reward:this.currentReward,done:!0})},0)))}updateRobotMass(e){if(this.robot){const t=this.robot.getConfig();t.mass=e,this.robot.updateConfig(t)}}updateRobotHeight(e){if(this.robot){const t=this.robot.getConfig();t.centerOfMassHeight=e,this.robot.updateConfig(t)}}updateMotorStrength(e){if(this.robot){const t=this.robot.getConfig();t.motorStrength=e,this.robot.updateConfig(t)}}updateWheelFriction(e){if(this.robot){const t=this.robot.getConfig();t.wheelFriction=e,this.robot.updateConfig(t)}}updateMaxAngle(e){if(this.robot){const t=this.robot.getConfig();t.maxAngle=e,this.robot.updateConfig(t)}}updateMotorTorqueRange(e){if(this.robot){const t=this.robot.getConfig();t.motorTorqueRange=e,this.robot.updateConfig(t)}}updateManualTorque(){const e=this.robot?.getConfig()?.motorStrength||5;this.manualControl.leftPressed&&this.manualControl.rightPressed?(this.manualControl.manualTorque=0,this.debugLastAction="Left+Right (Cancel)"):this.manualControl.leftPressed?(this.manualControl.manualTorque=.7*-e,this.debugLastAction="Left"):this.manualControl.rightPressed?(this.manualControl.manualTorque=.7*e,this.debugLastAction="Right"):(this.manualControl.manualTorque=0,this.debugLastAction="None")}getManualTorque(){return this.manualControl.manualTorque}togglePDController(){"training"===this.demoMode&&this.isTraining||"evaluation"===this.demoMode||("freerun"!==this.demoMode||!this.pdControllerEnabled||this.qlearning?(this.pdControllerEnabled=!this.pdControllerEnabled,this.updatePDControllerUI(),this.resetRobotPosition()):alert("No model loaded!\n\nTo use Model Control, you need to:\n• Train a model (Start Training)\n• Load a saved model (Model Management)\n• Import a pre-trained model\n\nPD Controller will remain active."))}toggleUserControlOnly(){"training"===this.demoMode&&this.isTraining||"evaluation"===this.demoMode||(this.userControlOnlyEnabled=!this.userControlOnlyEnabled,this.updateUserControlOnlyUI(),this.resetRobotPosition())}updatePDControllerUI(){const e=document.getElementById("toggle-pd-controller"),t=document.getElementById("pd-controller-text"),i=document.getElementById("pd-controller-status");if(!e||!t||!i)return;"training"===this.demoMode&&this.isTraining||"evaluation"===this.demoMode?(e.disabled=!0,t.textContent="PD Controller",i.textContent="(Disabled during training/testing)",i.style.color="#666",this.pdControllerEnabled=!1):(e.disabled=!1,"freerun"===this.demoMode?this.pdControllerEnabled?(t.textContent="Switch to Model Control",i.textContent="(PD Controller Active)",i.style.color="#00ff88"):(t.textContent="Switch to PD Controller",i.textContent=this.qlearning?"(Model Control Active)":"(No Control Active)",i.style.color=this.qlearning?"#2196F3":"#888"):(t.textContent=this.pdControllerEnabled?"Disable PD Controller":"Enable PD Controller",i.textContent=this.pdControllerEnabled?"(Active)":"(Disabled)",i.style.color=this.pdControllerEnabled?"#00ff88":"#888"),i.style.marginLeft="0")}updateUserControlOnlyUI(){const e=document.getElementById("toggle-user-control-only"),t=document.getElementById("user-control-text"),i=document.getElementById("user-control-status");if(!e||!t||!i)return;"training"===this.demoMode&&this.isTraining||"evaluation"===this.demoMode?(e.disabled=!0,t.textContent="User Control Only",i.textContent="(Disabled during training/testing)",i.style.color="#666",this.userControlOnlyEnabled=!1):(e.disabled=!1,t.textContent=this.userControlOnlyEnabled?"Disable User Control Only":"Enable User Control Only",i.textContent=this.userControlOnlyEnabled?"(Active)":"(Disabled)",i.style.color=this.userControlOnlyEnabled?"#ffaa00":"#888",i.style.marginLeft="0")}setRewardFunction(e){if(!this.robot)return;this.robot.setRewardType(e);const t=document.getElementById("offset-range-container");t&&(t.style.display="offset-adaptive"===e?"block":"none")}resetRobotPosition(){if(this.robot){let e=0;if("freerun"===this.demoMode&&Math.abs(this.resetAngleDegrees)>0){e=(this.resetAngleDegrees||0)*Math.PI/180}this.robot.reset({angle:e,angularVelocity:0,position:0,velocity:0})}}saveModelToLocalStorage(){if(!this.qlearning||!this.qlearning.isInitialized)return void alert("No trained model to save. Please train the model first.");const e=new Date,t=`TwoWheelBot_DQN_${e.toISOString().replace(/[:.]/g,"-").slice(0,-5)}`,i=this.qlearning.save(),s={name:t,timestamp:e.toISOString(),type:"DQN",architecture:this.qlearning.getStats(),timestepConfig:{historyTimesteps:this.robot?this.robot.historyTimesteps:1,inputSize:this.qlearning.qNetwork?this.qlearning.qNetwork.getArchitecture().inputSize:2},episodesTrained:this.episodeCount,bestScore:this.bestScore,trainingCompleted:this.qlearning.trainingCompleted,consecutiveMaxEpisodes:this.qlearning.consecutiveMaxEpisodes,modelData:i};try{localStorage.setItem(`model_${t}`,JSON.stringify(s));let e=JSON.parse(localStorage.getItem("savedModelsList")||"[]");e.includes(t)||(e.push(t),localStorage.setItem("savedModelsList",JSON.stringify(e))),this.currentModelName=t,this.modelHasUnsavedChanges=!1,this.updateModelDisplay(t,s),this.refreshModelList(),alert(`Model saved successfully as:\n${t}`)}catch(a){alert("Failed to save model: "+a.message)}}refreshModelList(){const e=JSON.parse(localStorage.getItem("savedModelsList")||"[]"),t=document.getElementById("saved-models-list"),i=document.getElementById("no-saved-models");t&&i&&(t.innerHTML="",0!==e.length?(i.style.display="none",e.forEach(e=>{try{const i=JSON.parse(localStorage.getItem(`model_${e}`));if(!i)return;const s=this.createModelListItem(e,i);t.appendChild(s)}catch(i){}})):i.style.display="block")}createModelListItem(e,t){const i=this.currentModelName===e,s=document.createElement("div");s.className="model-item "+(i?"current":""),s.id=`model-item-${e}`;const a=document.createElement("div");a.className="model-item-header";const r=document.createElement("div");r.className="model-item-name",r.innerHTML=e,i&&(r.innerHTML+='<span class="current-badge">LOADED</span>');const n=document.createElement("div");if(n.className="model-item-actions",i){const e=document.createElement("button");e.textContent="Unload",e.onclick=()=>this.unloadModel(),n.appendChild(e)}else{const t=document.createElement("button");t.textContent="Load",t.className="primary",t.onclick=()=>this.loadModelByName(e),n.appendChild(t)}const o=document.createElement("button");o.textContent="Delete",o.className="danger",o.onclick=()=>this.deleteModel(e),n.appendChild(o),a.appendChild(r),a.appendChild(n);const h=document.createElement("div");h.className="model-item-details";const l=t.modelData?.qNetworkWeights?.architecture,d=t.episodesTrained||0,c=t.bestScore||0,u=t.timestamp?new Date(t.timestamp).toLocaleString():"Unknown",p=t.trainingCompleted?"Yes":"No";return h.innerHTML=`\n            <div class="model-item-detail"><strong>Architecture:</strong> ${l?`${l.inputSize}-${l.hiddenSize}-${l.outputSize}`:"Unknown"}</div>\n            <div class="model-item-detail"><strong>Episodes:</strong> ${d} | <strong>Best Score:</strong> ${c.toFixed(0)}</div>\n            <div class="model-item-detail"><strong>Training Complete:</strong> ${p}</div>\n            <div class="model-item-detail"><strong>Saved:</strong> ${u}</div>\n        `,s.appendChild(a),s.appendChild(h),s}async loadModelByName(e){try{const t=JSON.parse(localStorage.getItem(`model_${e}`));if(!t||!t.modelData)return void alert("Model data is corrupted or missing.");await this.loadModel(t),this.refreshModelList(),alert(`Model loaded successfully:\n${e}`)}catch(t){alert("Failed to load model: "+t.message)}}unloadModel(){confirm("Are you sure you want to unload the current model?\nAny unsaved changes will be lost.")&&(this.qlearning&&this.qlearning.reset(),this.currentModelName="No model loaded",this.modelHasUnsavedChanges=!1,this.episodeCount=0,this.bestScore=0,this.updateModelDisplay("No model loaded",null),this.refreshModelList())}deleteModel(e){const t=this.currentModelName===e;if(confirm(t?`Are you sure you want to delete the currently loaded model "${e}"?\nThis action cannot be undone.`:`Are you sure you want to delete "${e}"?\nThis action cannot be undone.`))try{localStorage.removeItem(`model_${e}`);let i=JSON.parse(localStorage.getItem("savedModelsList")||"[]");i=i.filter(t=>t!==e),localStorage.setItem("savedModelsList",JSON.stringify(i)),t&&(this.currentModelName="No model loaded",this.modelHasUnsavedChanges=!1,this.updateModelDisplay("No model loaded",null)),this.refreshModelList(),alert(`Model "${e}" has been deleted.`)}catch(i){alert("Failed to delete model: "+i.message)}}async loadModel(e){const t=e.modelData?.qNetworkWeights?.architecture;if(!t)throw new Error("Invalid model data: missing architecture information");let i=!1;if(this.qlearning&&this.qlearning.isInitialized){const e=this.qlearning.qNetwork.getArchitecture();e.inputSize===t.inputSize&&e.hiddenSize===t.hiddenSize&&e.outputSize===t.outputSize||(i=!0)}if(e.timestepConfig){const t=e.timestepConfig.historyTimesteps||1;this.robot&&this.robot.setHistoryTimesteps(t);const i=document.getElementById("history-timesteps"),s=document.getElementById("history-timesteps-value");i&&(i.value=t,s.textContent=t)}this.qlearning&&!i||(this.uiControls&&this.uiControls.setParameter("hiddenNeurons",t.hiddenSize),await this.initializeQLearning({hiddenSize:t.hiddenSize})),await this.qlearning.load(e.modelData),this.episodeCount=e.episodesTrained||0,this.bestScore=e.bestScore||0,this.currentModelName=e.name,this.modelHasUnsavedChanges=!1,this.updateModelDisplay(e.name,e)}exportModelToCpp(){if(!this.qlearning||!this.qlearning.isInitialized)return void alert("No trained model to export. Please train the model first.");const e=(new Date).toISOString().replace(/[:.]/g,"-").slice(0,-5),t=`two_wheel_bot_dqn_${e}.cpp`,i=this.qlearning.qNetwork.getWeights(),s=this.qlearning.qNetwork.getArchitecture();let a=this.generateCppCode(i,s,e);const r=new Blob([a],{type:"text/plain"}),n=URL.createObjectURL(r),o=document.createElement("a");o.href=n,o.download=t,document.body.appendChild(o),o.click(),document.body.removeChild(o),URL.revokeObjectURL(n),alert(`Model exported as C++ file:\n${t}`)}importModelFromCpp(){const e=document.getElementById("cpp-file-input"),t=__name(i=>{const s=i.target.files[0];if(!s)return;const a=new FileReader;a.onload=async e=>{try{const t=e.target.result,i=this.parseCppModel(t,s.name);await this.loadImportedModel(i);JSON.parse(localStorage.getItem("savedModelsList")||"[]");alert(`Model imported successfully from:\n${s.name}\n\nModel name: ${i.name}`)}catch(t){alert("Failed to import model: "+t.message)}},a.readAsText(s),e.value="",e.removeEventListener("change",t)},"handleFileSelect");e.addEventListener("change",t),e.click()}parseCppModel(e,t){const i=e.match(/static const int INPUT_SIZE = (\d+);/),s=e.match(/static const int HIDDEN_SIZE = (\d+);/),a=e.match(/static const int OUTPUT_SIZE = (\d+);/);if(!i||!s||!a)throw new Error("Could not extract network architecture from C++ file");const r=parseInt(i[1]),n=parseInt(s[1]),o=parseInt(a[1]),h=this.extractWeightsArray(e,"weightsInputHidden"),l=this.extractWeightsArray(e,"biasHidden"),d=this.extractWeightsArray(e,"weightsHiddenOutput"),c=this.extractWeightsArray(e,"biasOutput");if(h.length!==r*n)throw new Error(`Expected ${r*n} input-to-hidden weights, got ${h.length}`);if(l.length!==n)throw new Error(`Expected ${n} hidden biases, got ${l.length}`);if(d.length!==n*o)throw new Error(`Expected ${n*o} hidden-to-output weights, got ${d.length}`);if(c.length!==o)throw new Error(`Expected ${o} output biases, got ${c.length}`);const u=t.match(/(\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2})/)||e.match(/Generated: (\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2})/);return{name:`Imported_DQN_${u?u[1]:(new Date).toISOString().replace(/[:.]/g,"-").slice(0,-5)}`,architecture:{inputSize:r,hiddenSize:n,outputSize:o},weights:{architecture:{inputSize:r,hiddenSize:n,outputSize:o,parameterCount:h.length+l.length+d.length+c.length},weightsInputHidden:Array.from(h),biasHidden:Array.from(l),weightsHiddenOutput:Array.from(d),biasOutput:Array.from(c),initMethod:"imported"},filename:t,importDate:(new Date).toISOString()}}extractWeightsArray(e,t){const i=new RegExp(`const float ${t}\\[.*?\\] = \\{([^}]+)\\};`,"s"),s=e.match(i);if(!s)throw new Error(`Could not find ${t} array in C++ file`);return s[1].split(",").map(e=>e.trim()).filter(e=>e.length>0).map(e=>{const t=e.replace(/f$/,""),i=parseFloat(t);if(isNaN(i))throw new Error(`Invalid weight value: ${e}`);return i})}async loadImportedModel(e){this.qlearning||await this.initializeQLearning();const t=this.qlearning.qNetwork.getArchitecture(),i=e.architecture;if(t.inputSize!==i.inputSize||t.hiddenSize!==i.hiddenSize||t.outputSize!==i.outputSize){if(!confirm(`Architecture mismatch:\nCurrent: ${t.inputSize}-${t.hiddenSize}-${t.outputSize}\nImported: ${i.inputSize}-${i.hiddenSize}-${i.outputSize}\n\nRecreate network with imported architecture?`))throw new Error("Import cancelled - architecture mismatch");await this.initializeQLearning({hiddenSize:i.hiddenSize})}this.qlearning.qNetwork.setWeights(e.weights),this.qlearning.targetNetwork=this.qlearning.qNetwork.clone(),this.episodeCount=0,this.trainingStep=0,this.bestScore=0,this.currentModelName=e.name,this.modelHasUnsavedChanges=!1;const s={hyperparams:this.qlearning.hyperparams,qNetworkWeights:e.weights,targetNetworkWeights:e.weights,episode:0,stepCount:0,metrics:{episodes:0,totalSteps:0,averageReward:0,bestReward:0},actions:this.qlearning.actions},a={name:e.name,timestamp:e.importDate,type:"Imported DQN",architecture:i,episodesTrained:0,bestScore:0,trainingCompleted:!1,consecutiveMaxEpisodes:0,modelData:s,importedFrom:e.filename};try{localStorage.setItem(`model_${e.name}`,JSON.stringify(a));let t=JSON.parse(localStorage.getItem("savedModelsList")||"[]");t.includes(e.name)||(t.push(e.name),localStorage.setItem("savedModelsList",JSON.stringify(t)))}catch(r){}this.updateModelDisplay(e.name,a),this.refreshModelList()}generateCppCode(e,t,i){const{inputSize:s,hiddenSize:a,outputSize:r}=t;return`/**\n * Two-Wheel Balancing Robot DQN Model\n * Generated: ${i}\n * Architecture: ${s}-${a}-${r}\n * \n * This file contains the trained neural network weights for deployment\n * on embedded systems (Arduino, ESP32, STM32, etc.)\n */\n\n#include <math.h>\n\nclass TwoWheelBotDQN {\nprivate:\n    static const int INPUT_SIZE = ${s};\n    static const int HIDDEN_SIZE = ${a};\n    static const int OUTPUT_SIZE = ${r};\n    \n    // Network weights (stored in program memory to save RAM)\n    const float weightsInputHidden[INPUT_SIZE * HIDDEN_SIZE] = {\n        ${this.formatWeights(e.weightsInputHidden,8)}\n    };\n    \n    const float biasHidden[HIDDEN_SIZE] = {\n        ${this.formatWeights(e.biasHidden,8)}\n    };\n    \n    const float weightsHiddenOutput[HIDDEN_SIZE * OUTPUT_SIZE] = {\n        ${this.formatWeights(e.weightsHiddenOutput,8)}\n    };\n    \n    const float biasOutput[OUTPUT_SIZE] = {\n        ${this.formatWeights(e.biasOutput,8)}\n    };\n    \n    // Activation function (ReLU)\n    float relu(float x) {\n        return x > 0 ? x : 0;\n    }\n    \npublic:\n    /**\n     * Get action from current state\n     * @param angle Robot angle in radians\n     * @param angularVelocity Angular velocity in rad/s\n     * @return Action index (0=left, 1=brake, 2=right)\n     */\n    int getAction(float angle, float angularVelocity) {\n        // Normalize inputs\n        float input[INPUT_SIZE];\n        input[0] = constrain(angle / (M_PI / 3), -1.0, 1.0);\n        input[1] = constrain(angularVelocity / 10.0, -1.0, 1.0);\n        \n        // Hidden layer computation\n        float hidden[HIDDEN_SIZE];\n        for (int h = 0; h < HIDDEN_SIZE; h++) {\n            hidden[h] = biasHidden[h];\n            for (int i = 0; i < INPUT_SIZE; i++) {\n                hidden[h] += input[i] * weightsInputHidden[i * HIDDEN_SIZE + h];\n            }\n            hidden[h] = relu(hidden[h]);\n        }\n        \n        // Output layer computation\n        float output[OUTPUT_SIZE];\n        float maxValue = -1e10;\n        int bestAction = 0;\n        \n        for (int o = 0; o < OUTPUT_SIZE; o++) {\n            output[o] = biasOutput[o];\n            for (int h = 0; h < HIDDEN_SIZE; h++) {\n                output[o] += hidden[h] * weightsHiddenOutput[h * OUTPUT_SIZE + o];\n            }\n            \n            // Track best action\n            if (output[o] > maxValue) {\n                maxValue = output[o];\n                bestAction = o;\n            }\n        }\n        \n        return bestAction;\n    }\n    \n    /**\n     * Get motor torque for action\n     * @param action Action index\n     * @return Motor torque (-1.0 to 1.0)\n     */\n    float getMotorTorque(int action) {\n        const float actions[3] = {-1.0, 0.0, 1.0};\n        return actions[action];\n    }\n    \nprivate:\n    float constrain(float value, float min, float max) {\n        if (value < min) return min;\n        if (value > max) return max;\n        return value;\n    }\n};\n\n// Usage example:\n// TwoWheelBotDQN bot;\n// int action = bot.getAction(angle, angularVelocity);\n// float torque = bot.getMotorTorque(action);\n`}formatWeights(e,t){const i=[];for(let s=0;s<e.length;s+=t){const a=e.slice(s,s+t).map(e=>e.toFixed(6)+"f").join(", ");i.push("        "+a)}return i.join(",\n")}resetModelParameters(){this.qlearning&&this.qlearning.isInitialized?confirm("Are you sure you want to reset all model parameters? This will lose all training progress.")&&(this.qlearning.reset(),this.episodeCount=0,this.trainingStep=0,this.bestScore=0,this.currentModelName="No model loaded",this.modelHasUnsavedChanges=!1,this.updateModelDisplay("Untrained Model",null),alert("Model parameters have been reset.")):alert("No model to reset. Please initialize training first.")}updateModelDisplay(e,t){const i=document.getElementById("current-model-name"),s=document.getElementById("model-stats");if(i&&(i.textContent=e||"No model loaded"),s&&t){const e=[];if(t.episodesTrained&&e.push(`Episodes: ${t.episodesTrained}`),t.bestScore&&e.push(`Best Score: ${t.bestScore.toFixed(1)}`),t.trainingCompleted&&e.push("✓ Training Completed"),t.timestamp){const i=new Date(t.timestamp);e.push(`Saved: ${i.toLocaleDateString()} ${i.toLocaleTimeString()}`)}s.textContent=e.join(" | ")}else s&&(s.textContent="")}updateTrainingModelDisplay(){const e=document.getElementById("current-model-name"),t=document.getElementById("model-stats");if(e){let t=this.currentModelName;this.modelHasUnsavedChanges&&!t.includes("(unsaved)")&&(t+=" (unsaved)"),e.textContent=t}if(t){const e=[];e.push(`Episodes: ${this.episodeCount}`),this.bestScore&&this.bestScore>-1/0&&e.push(`Best: ${this.bestScore.toFixed(1)}`),this.qlearning&&(this.qlearning.trainingCompleted?e.push("✓ Completed"):this.qlearning.consecutiveMaxEpisodes>0&&e.push(`Progress: ${this.qlearning.consecutiveMaxEpisodes}/20`),this.isTraining&&!this.isPaused?e.push("🔴 Training"):this.isPaused&&e.push("⏸️ Paused")),t.textContent=e.join(" | ")}}}let u=null;function setupCustomSliders(){const e=document.getElementById("offset-angle-error"),t=document.getElementById("offset-angle-error-value");e&&t&&e.addEventListener("input",e=>{const i=parseFloat(e.target.value),s=i*Math.PI/180;t.textContent=`${i.toFixed(1)}°`,u&&u.robot&&(u.robot.angleOffset=s)});const i=document.getElementById("reset-angle"),s=document.getElementById("reset-angle-value");i&&s&&i.addEventListener("input",e=>{const t=parseFloat(e.target.value);s.textContent=`${t.toFixed(1)}°`,u&&(u.resetAngleDegrees=t)});const a=document.getElementById("offset-range"),r=document.getElementById("offset-range-value");a&&r&&a.addEventListener("input",e=>{const t=parseFloat(e.target.value);r.textContent=`${t.toFixed(1)}°`,u&&(u.maxOffsetRangeDegrees=t,u.robot&&u.robot.setTrainingOffsetRange(t))})}document.addEventListener("DOMContentLoaded",async()=>{try{u=new TwoWheelBotRL,await u.initialize(),setupCustomSliders()}catch(e){}}),__name(setupCustomSliders,"setupCustomSliders"),window.addEventListener("beforeunload",()=>{u&&u.destroy()}),window.TwoWheelBotRL=TwoWheelBotRL;
//# sourceMappingURL=index-ByTvQ14G.js.map
