{"version":3,"file":"index-ByTvQ14G.js","sources":["../../src/network/shaders/webgpu-polyfill.js","../../src/visualization/Renderer.js","../../src/visualization/Charts.js","../../src/network/NetworkPresets.js","../../src/physics/StateHistory.js","../../src/physics/BalancingRobot.js","../../src/network/NeuralNetwork.js","../../src/network/MatrixUtils.js","../../src/network/CPUBackend.js","../../src/training/QLearning.js","../../src/network/shaders/ShaderManager.js","../../src/network/shaders/BufferManager.js","../../src/network/shaders/WebGPUNeuralNetwork.js","../../src/network/WebGPUBackend.js","../../src/training/ParallelTraining.js","../../src/training/PerformanceTracker.js","../../src/main.js"],"sourcesContent":["/**\n * WebGPU Polyfill for Safe Constants Access\n * \n * This module ensures WebGPU constants are available even when WebGPU is not.\n * It should be imported before any other WebGPU-related modules.\n */\n\n// Check if WebGPU constants are already defined\nif (typeof globalThis.GPUBufferUsage === 'undefined') {\n    // Define WebGPU constants as fallbacks based on the WebGPU specification\n    globalThis.GPUBufferUsage = {\n        MAP_READ: 0x0001,\n        MAP_WRITE: 0x0002,\n        COPY_SRC: 0x0004,\n        COPY_DST: 0x0008,\n        INDEX: 0x0010,\n        VERTEX: 0x0020,\n        UNIFORM: 0x0040,\n        STORAGE: 0x0080,\n        INDIRECT: 0x0100,\n        QUERY_RESOLVE: 0x0200\n    };\n}\n\nif (typeof globalThis.GPUMapMode === 'undefined') {\n    globalThis.GPUMapMode = {\n        READ: 0x0001,\n        WRITE: 0x0002\n    };\n}\n\nif (typeof globalThis.GPUShaderStage === 'undefined') {\n    globalThis.GPUShaderStage = {\n        VERTEX: 0x1,\n        FRAGMENT: 0x2,\n        COMPUTE: 0x4\n    };\n}\n\n// Export a flag to indicate whether we're using polyfilled values\nexport const isPolyfilled = !navigator.gpu;\n\n// Export the constants for convenience\nexport const BufferUsage = globalThis.GPUBufferUsage;\nexport const MapMode = globalThis.GPUMapMode;\nexport const ShaderStage = globalThis.GPUShaderStage;\n\nconsole.log('WebGPU polyfill loaded:', isPolyfilled ? 'Using polyfilled constants' : 'Using native WebGPU constants');","/**\n * 2D Visualization Renderer for Two-Wheel Balancing Robot RL Application\n * \n * High-performance HTML5 Canvas-based renderer for real-time training visualization\n * Features:\n * - Real-time robot visualization (pendulum + wheels)\n * - Physics state display (angle, velocity, position)\n * - Motor torque indicators\n * - Training metrics overlay\n * - 60 FPS rendering with coordinate transformation\n * - Responsive canvas management\n */\n\n/**\n * Coordinate system transformer for physics <-> screen space conversion\n */\nexport class CoordinateTransform {\n    constructor(canvasWidth, canvasHeight) {\n        this.canvasWidth = canvasWidth;\n        this.canvasHeight = canvasHeight;\n        \n        // Physics coordinate system (meters)\n        this.physicsScale = 400; // pixels per meter\n        this.centerX = canvasWidth / 2;\n        this.centerY = canvasHeight * 0.7; // Ground line at 70% down\n        this.zoomLevel = 1.0; // Zoom level multiplier\n        \n        this.minX = -canvasWidth / (2 * this.physicsScale);\n        this.maxX = canvasWidth / (2 * this.physicsScale);\n        this.minY = -canvasHeight / (2 * this.physicsScale);\n        this.maxY = canvasHeight / (2 * this.physicsScale);\n    }\n    \n    /**\n     * Convert physics coordinates to screen coordinates\n     * @param {number} x - Physics X coordinate (meters)\n     * @param {number} y - Physics Y coordinate (meters)\n     * @returns {Object} {x, y} screen coordinates\n     */\n    physicsToScreen(x, y) {\n        return {\n            x: this.centerX + x * this.physicsScale * this.zoomLevel,\n            y: this.centerY - y * this.physicsScale * this.zoomLevel // Flip Y axis\n        };\n    }\n    \n    /**\n     * Convert screen coordinates to physics coordinates\n     * @param {number} screenX - Screen X coordinate\n     * @param {number} screenY - Screen Y coordinate\n     * @returns {Object} {x, y} physics coordinates\n     */\n    screenToPhysics(screenX, screenY) {\n        return {\n            x: (screenX - this.centerX) / (this.physicsScale * this.zoomLevel),\n            y: (this.centerY - screenY) / (this.physicsScale * this.zoomLevel)\n        };\n    }\n    \n    /**\n     * Update transform for canvas resize\n     * @param {number} canvasWidth - New canvas width\n     * @param {number} canvasHeight - New canvas height\n     */\n    resize(canvasWidth, canvasHeight) {\n        this.canvasWidth = canvasWidth;\n        this.canvasHeight = canvasHeight;\n        this.centerX = canvasWidth / 2;\n        this.centerY = canvasHeight * 0.7;\n        \n        this.minX = -canvasWidth / (2 * this.physicsScale);\n        this.maxX = canvasWidth / (2 * this.physicsScale);\n        this.minY = -canvasHeight / (2 * this.physicsScale);\n        this.maxY = canvasHeight / (2 * this.physicsScale);\n    }\n    \n    /**\n     * Convert length from physics to screen units\n     * @param {number} length - Length in meters\n     * @returns {number} Length in pixels\n     */\n    scaleLength(length) {\n        return length * this.physicsScale * this.zoomLevel;\n    }\n    \n    /**\n     * Get physics coordinate bounds\n     * @returns {Object} {minX, maxX, minY, maxY} physics bounds in meters\n     */\n    getPhysicsBounds() {\n        return {\n            minX: this.minX,\n            maxX: this.maxX,\n            minY: this.minY,\n            maxY: this.maxY\n        };\n    }\n}\n\n/**\n * Performance monitor for tracking rendering performance\n */\nexport class PerformanceMonitor {\n    constructor() {\n        this.frameCount = 0;\n        this.lastTime = performance.now();\n        this.fps = 60;\n        this.frameTime = 16.67; // milliseconds\n        this.avgFrameTime = 16.67;\n        this.maxFrameTime = 16.67;\n        this.minFrameTime = 16.67;\n        \n        // Performance history for averaging\n        this.frameTimes = [];\n        this.historySize = 60; // 1 second of frames at 60fps\n    }\n    \n    /**\n     * Update performance metrics\n     */\n    update() {\n        const currentTime = performance.now();\n        this.frameTime = currentTime - this.lastTime;\n        this.lastTime = currentTime;\n        \n        // Update frame times history\n        this.frameTimes.push(this.frameTime);\n        if (this.frameTimes.length > this.historySize) {\n            this.frameTimes.shift();\n        }\n        \n        // Calculate metrics\n        this.avgFrameTime = this.frameTimes.reduce((sum, t) => sum + t, 0) / this.frameTimes.length;\n        this.fps = 1000 / this.avgFrameTime;\n        this.maxFrameTime = Math.max(...this.frameTimes);\n        this.minFrameTime = Math.min(...this.frameTimes);\n    }\n    \n    /**\n     * Get performance summary\n     * @returns {Object} Performance metrics\n     */\n    getMetrics() {\n        return {\n            fps: Math.round(this.fps),\n            avgFrameTime: this.avgFrameTime.toFixed(2),\n            maxFrameTime: this.maxFrameTime.toFixed(2),\n            minFrameTime: this.minFrameTime.toFixed(2)\n        };\n    }\n    \n    /**\n     * Check if rendering is running smoothly\n     * @returns {boolean} True if performance is good\n     */\n    isPerformanceGood() {\n        return this.fps >= 55 && this.maxFrameTime < 25; // 55+ FPS, max 25ms frame time\n    }\n}\n\n/**\n * Main 2D renderer for the balancing robot visualization\n */\nexport class Renderer {\n    constructor(canvas, config = {}) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        \n        // Configuration\n        this.config = {\n            backgroundColor: config.backgroundColor || '#0a0a0a',\n            gridColor: config.gridColor || '#1a1a1a',\n            robotColor: config.robotColor || '#00d4ff',\n            wheelColor: config.wheelColor || '#ffffff',\n            torqueColor: config.torqueColor || '#ff6b35',\n            textColor: config.textColor || '#ffffff',\n            showGrid: config.showGrid !== false,\n            showDebugInfo: config.showDebugInfo !== false,\n            showPerformance: config.showPerformance !== false,\n            targetFPS: config.targetFPS || 60,\n            ...config\n        };\n        \n        // Coordinate transformation\n        this.transform = new CoordinateTransform(canvas.width, canvas.height);\n        \n        // Performance monitoring\n        this.performance = new PerformanceMonitor();\n        \n        // Rendering state\n        this.isRendering = false;\n        this.animationId = null;\n        this.lastRenderTime = 0;\n        this.frameInterval = 1000 / this.config.targetFPS;\n        \n        // Robot visualization state\n        this.robotState = null;\n        this.robotConfig = null;\n        this.motorTorque = 0;\n        \n        // Training visualization state\n        this.trainingMetrics = {\n            episode: 0,\n            step: 0,\n            reward: 0,\n            totalReward: 0,\n            bestReward: 0,\n            epsilon: 0,\n            isTraining: false,\n            trainingMode: 'idle'\n        };\n        \n        // UI elements state\n        this.showRobotInfo = true;\n        this.showTrainingInfo = true;\n        this.showPerformanceInfo = true;\n        \n        console.log('Renderer initialized:', canvas.width, 'x', canvas.height);\n    }\n    \n    /**\n     * Start the rendering loop\n     */\n    start() {\n        if (this.isRendering) return;\n        \n        this.isRendering = true;\n        this.lastRenderTime = performance.now();\n        \n        const renderLoop = (currentTime) => {\n            if (!this.isRendering) return;\n            \n            // Frame rate limiting\n            const deltaTime = currentTime - this.lastRenderTime;\n            if (deltaTime >= this.frameInterval) {\n                this.render();\n                this.performance.update();\n                this.lastRenderTime = currentTime - (deltaTime % this.frameInterval);\n            }\n            \n            this.animationId = requestAnimationFrame(renderLoop);\n        };\n        \n        this.animationId = requestAnimationFrame(renderLoop);\n        console.log('Renderer started with target FPS:', this.config.targetFPS);\n    }\n    \n    /**\n     * Stop the rendering loop\n     */\n    stop() {\n        this.isRendering = false;\n        if (this.animationId) {\n            cancelAnimationFrame(this.animationId);\n            this.animationId = null;\n        }\n        console.log('Renderer stopped');\n    }\n    \n    /**\n     * Handle canvas resize\n     * @param {number} width - New canvas width\n     * @param {number} height - New canvas height\n     */\n    resize(width, height) {\n        this.canvas.width = width;\n        this.canvas.height = height;\n        this.transform.resize(width, height);\n        console.log('Renderer resized to:', width, 'x', height);\n    }\n    \n    /**\n     * Get physics coordinate bounds (for position-based episode termination)\n     * @returns {Object} {minX, maxX, minY, maxY} physics bounds in meters\n     */\n    getPhysicsBounds() {\n        return this.transform.getPhysicsBounds();\n    }\n    \n    /**\n     * Update robot state for visualization\n     * @param {Object} state - Robot state from physics simulation\n     * @param {Object} config - Robot configuration\n     * @param {number} motorTorque - Current motor torque\n     */\n    updateRobot(state, config, motorTorque = 0) {\n        this.robotState = state;\n        this.robotConfig = config;\n        this.motorTorque = motorTorque;\n        console.log('Robot updated:', state, config);\n    }\n    \n    /**\n     * Update training metrics for visualization\n     * @param {Object} metrics - Training metrics object\n     */\n    updateTraining(metrics) {\n        this.trainingMetrics = { ...this.trainingMetrics, ...metrics };\n    }\n    \n    /**\n     * Main render function\n     */\n    render() {\n        // Clear canvas\n        this.clear();\n        \n        // Draw environment\n        this.drawEnvironment();\n        \n        // Draw robot if state is available\n        if (this.robotState && this.robotConfig) {\n            this.drawRobot();\n        } else {\n            // Debug: Show why robot is not being drawn\n            if (!this.robotState) {\n                console.log('Robot not drawn: robotState is null');\n            }\n            if (!this.robotConfig) {\n                console.log('Robot not drawn: robotConfig is null');\n            }\n        }\n        \n        // Draw UI overlays\n        this.drawUI();\n    }\n    \n    /**\n     * Clear the canvas\n     */\n    clear() {\n        this.ctx.fillStyle = this.config.backgroundColor;\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n    \n    /**\n     * Draw environment (ground, grid, reference lines)\n     */\n    drawEnvironment() {\n        // Draw grid if enabled\n        if (this.config.showGrid) {\n            this.drawGrid();\n        }\n        \n        // Draw ground line\n        this.drawGround();\n        \n        // Draw coordinate axes for reference\n        this.drawAxes();\n    }\n    \n    /**\n     * Draw background grid\n     */\n    drawGrid() {\n        this.ctx.strokeStyle = this.config.gridColor;\n        this.ctx.lineWidth = 1;\n        this.ctx.globalAlpha = 0.3;\n        \n        const gridSpacing = this.transform.scaleLength(0.5); // 0.5m grid\n        \n        // Vertical lines\n        for (let x = this.transform.centerX % gridSpacing; x < this.canvas.width; x += gridSpacing) {\n            this.ctx.beginPath();\n            this.ctx.moveTo(x, 0);\n            this.ctx.lineTo(x, this.canvas.height);\n            this.ctx.stroke();\n        }\n        \n        // Horizontal lines\n        for (let y = this.transform.centerY % gridSpacing; y < this.canvas.height; y += gridSpacing) {\n            this.ctx.beginPath();\n            this.ctx.moveTo(0, y);\n            this.ctx.lineTo(this.canvas.width, y);\n            this.ctx.stroke();\n        }\n        \n        this.ctx.globalAlpha = 1.0;\n    }\n    \n    /**\n     * Draw realistic ground surface\n     */\n    drawGround() {\n        const groundY = this.transform.centerY;\n        \n        // Ground surface - more visible with texture pattern\n        this.ctx.fillStyle = '#2a2a2a'; // Dark gray surface\n        this.ctx.fillRect(0, groundY, this.canvas.width, this.canvas.height - groundY);\n        \n        // Add a textured pattern to make rolling more visible\n        // Draw repeated chevron/arrow pattern on the ground\n        this.ctx.strokeStyle = '#404040';\n        this.ctx.lineWidth = 2;\n        this.ctx.lineCap = 'round';\n        \n        const patternSpacing = 60; // Distance between pattern elements\n        const patternHeight = 15;  // Height of chevron pattern\n        \n        // Calculate pattern offset based on camera/view position\n        const startX = -patternSpacing;\n        const endX = this.canvas.width + patternSpacing;\n        \n        for (let x = startX; x < endX; x += patternSpacing) {\n            // Draw chevron/arrow pattern pointing right\n            this.ctx.beginPath();\n            this.ctx.moveTo(x, groundY + 5);\n            this.ctx.lineTo(x + patternHeight, groundY + 5 + patternHeight/2);\n            this.ctx.lineTo(x, groundY + 5 + patternHeight);\n            this.ctx.stroke();\n            \n            // Add small tick marks for finer measurement\n            for (let i = 1; i < 4; i++) {\n                const tickX = x + (patternSpacing * i / 4);\n                this.ctx.beginPath();\n                this.ctx.moveTo(tickX, groundY + 2);\n                this.ctx.lineTo(tickX, groundY + 8);\n                this.ctx.stroke();\n            }\n        }\n        \n        // Ground line - top edge (more prominent)\n        this.ctx.strokeStyle = '#606060';\n        this.ctx.lineWidth = 3;\n        this.ctx.beginPath();\n        this.ctx.moveTo(0, groundY);\n        this.ctx.lineTo(this.canvas.width, groundY);\n        this.ctx.stroke();\n        \n        // Add subtle grid lines on ground for distance reference\n        this.ctx.strokeStyle = 'rgba(64, 64, 64, 0.5)';\n        this.ctx.lineWidth = 1;\n        const wheelCircumference = 2 * Math.PI * (this.robotConfig?.wheelRadius || 0.12);\n        const circumferencePixels = this.transform.scaleLength(wheelCircumference);\n        \n        // Draw lines at wheel circumference intervals\n        const centerX = this.transform.centerX;\n        const robotPos = this.robotState?.position || 0;\n        const robotScreenX = this.transform.physicsToScreen(robotPos, 0).x;\n        \n        // Calculate offset to align with wheel position\n        const offset = robotScreenX % circumferencePixels;\n        \n        for (let x = offset; x < this.canvas.width; x += circumferencePixels) {\n            this.ctx.beginPath();\n            this.ctx.moveTo(x, groundY);\n            this.ctx.lineTo(x, groundY + 30);\n            this.ctx.stroke();\n        }\n        \n        for (let x = offset - circumferencePixels; x >= 0; x -= circumferencePixels) {\n            this.ctx.beginPath();\n            this.ctx.moveTo(x, groundY);\n            this.ctx.lineTo(x, groundY + 30);\n            this.ctx.stroke();\n        }\n        \n        // Draw wheel contact point marker (optional debug visualization)\n        if (this.robotState && this.config.showDebugInfo) {\n            const contactX = this.transform.physicsToScreen(this.robotState.position, 0).x;\n            const contactY = this.transform.centerY;\n            \n            this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';\n            this.ctx.lineWidth = 1;\n            this.ctx.beginPath();\n            this.ctx.moveTo(contactX - 10, contactY);\n            this.ctx.lineTo(contactX + 10, contactY);\n            this.ctx.stroke();\n        }\n    }\n    \n    /**\n     * Draw coordinate system axes\n     */\n    drawAxes() {\n        this.ctx.strokeStyle = this.config.textColor;\n        this.ctx.lineWidth = 1;\n        this.ctx.globalAlpha = 0.5;\n        \n        // Center lines\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.transform.centerX, 0);\n        this.ctx.lineTo(this.transform.centerX, this.canvas.height);\n        this.ctx.moveTo(0, this.transform.centerY);\n        this.ctx.lineTo(this.canvas.width, this.transform.centerY);\n        this.ctx.stroke();\n        \n        this.ctx.globalAlpha = 1.0;\n    }\n    \n    /**\n     * Draw the robot (pendulum + wheels + torque indicators)\n     */\n    drawRobot() {\n        if (!this.robotState || !this.robotConfig) return;\n        \n        const { angle, position } = this.robotState;\n        const { centerOfMassHeight } = this.robotConfig;\n        \n        // Debug: Log that we're drawing the robot\n        console.log('Drawing robot at position:', position, 'angle:', angle);\n        \n        // FIXED: Wheels sit on ground (center is above ground by radius)\n        // Body extends upward from wheel center\n        const wheelRadius = this.robotConfig?.wheelRadius || 0.12; // Use actual radius from config\n        const wheelPos = this.transform.physicsToScreen(position, wheelRadius);\n        const bodyTopPos = this.transform.physicsToScreen(\n            position + Math.sin(angle) * centerOfMassHeight,\n            wheelRadius + Math.cos(angle) * centerOfMassHeight\n        );\n        \n        // Draw robot body (pendulum extending upward from wheels)\n        this.drawRobotBody(wheelPos, bodyTopPos);\n        \n        // Draw wheels at ground level\n        this.drawWheels(wheelPos);\n        \n        // Draw motor torque indicators\n        this.drawTorqueIndicators(wheelPos);\n        \n        // Draw angle indicator\n        this.drawAngleIndicator(wheelPos, angle);\n    }\n    \n    /**\n     * Draw robot body (side view - inverted pendulum balancing robot)\n     * @param {Object} wheelPos - Wheel position at ground level {x, y}\n     * @param {Object} topPos - Top position of pendulum {x, y}\n     */\n    drawRobotBody(wheelPos, topPos) {\n        const bodyWidth = this.transform.scaleLength(0.24); // Robot body width (increased)\n        const bodyHeight = Math.sqrt(Math.pow(topPos.x - wheelPos.x, 2) + Math.pow(topPos.y - wheelPos.y, 2));\n        const angle = Math.atan2(topPos.x - wheelPos.x, wheelPos.y - topPos.y);\n        \n        // Main robot body - rectangular chassis extending upward from wheels\n        this.ctx.save();\n        this.ctx.translate(wheelPos.x, wheelPos.y);\n        this.ctx.rotate(angle);\n        \n        // Robot body - main chassis (extends upward from wheel position)\n        this.ctx.fillStyle = '#2a4d3a'; // Dark green\n        this.ctx.fillRect(-bodyWidth/2, -bodyHeight, bodyWidth, bodyHeight * 0.9);\n        \n        // Robot body outline\n        this.ctx.strokeStyle = '#1a3d2a';\n        this.ctx.lineWidth = 2;\n        this.ctx.strokeRect(-bodyWidth/2, -bodyHeight, bodyWidth, bodyHeight * 0.9);\n        \n        // Center of mass indicator - bright marker at top of pendulum\n        this.ctx.fillStyle = '#ff4444';\n        this.ctx.beginPath();\n        this.ctx.arc(0, -bodyHeight * 0.9, 15, 0, Math.PI * 2);\n        this.ctx.fill();\n        \n        this.ctx.restore();\n        \n        // Axle connection - small cylinder connecting to wheel\n        this.ctx.fillStyle = '#606060';\n        this.ctx.beginPath();\n        this.ctx.arc(wheelPos.x, wheelPos.y, 4, 0, Math.PI * 2);\n        this.ctx.fill();\n    }\n    \n    /**\n     * Draw robot wheel (side view - single wheel visible)\n     * @param {Object} wheelPos - Wheel position at ground level {x, y}\n     */\n    drawWheels(wheelPos) {\n        // Use actual wheel radius from physics configuration\n        const physicsWheelRadius = this.robotConfig?.wheelRadius || 0.12;\n        const wheelRadius = this.transform.scaleLength(physicsWheelRadius);\n        \n        // Main wheel body - dark gray with metallic look\n        this.ctx.fillStyle = '#404040';\n        this.ctx.beginPath();\n        this.ctx.arc(wheelPos.x, wheelPos.y, wheelRadius, 0, Math.PI * 2);\n        this.ctx.fill();\n        \n        // Wheel rim - lighter gray\n        this.ctx.strokeStyle = '#606060';\n        this.ctx.lineWidth = 3;\n        this.ctx.beginPath();\n        this.ctx.arc(wheelPos.x, wheelPos.y, wheelRadius, 0, Math.PI * 2);\n        this.ctx.stroke();\n        \n        // Tire tread - black outer ring\n        this.ctx.strokeStyle = '#202020';\n        this.ctx.lineWidth = 6;\n        this.ctx.beginPath();\n        this.ctx.arc(wheelPos.x, wheelPos.y, wheelRadius - 2, 0, Math.PI * 2);\n        this.ctx.stroke();\n        \n        // Wheel hub - central circle\n        this.ctx.fillStyle = '#707070';\n        this.ctx.beginPath();\n        this.ctx.arc(wheelPos.x, wheelPos.y, wheelRadius * 0.3, 0, Math.PI * 2);\n        this.ctx.fill();\n        \n        // Rotating spokes for motion indication\n        // Use actual wheel angle from physics for correct visual rotation\n        // When robot moves right (positive velocity), wheel rotates clockwise\n        // When robot moves left (negative velocity), wheel rotates counter-clockwise  \n        const wheelRotation = (this.robotState.wheelAngle || 0);\n        const spokeAngle = wheelRotation;\n        \n        this.ctx.strokeStyle = '#808080';\n        this.ctx.lineWidth = 2;\n        this.ctx.lineCap = 'round';\n        \n        // Draw 4 spokes\n        for (let i = 0; i < 4; i++) {\n            const angle = spokeAngle + (i * Math.PI / 2);\n            const innerRadius = wheelRadius * 0.4;\n            const outerRadius = wheelRadius * 0.8;\n            \n            this.ctx.beginPath();\n            this.ctx.moveTo(\n                wheelPos.x + Math.cos(angle) * innerRadius,\n                wheelPos.y + Math.sin(angle) * innerRadius\n            );\n            this.ctx.lineTo(\n                wheelPos.x + Math.cos(angle) * outerRadius,\n                wheelPos.y + Math.sin(angle) * outerRadius\n            );\n            this.ctx.stroke();\n        }\n        \n        // Add a reference mark on the wheel to make rotation more obvious\n        // Draw a colored dot on the wheel edge\n        const markerAngle = spokeAngle;\n        const markerRadius = wheelRadius * 0.9;\n        this.ctx.fillStyle = '#ff4444'; // Red marker\n        this.ctx.beginPath();\n        this.ctx.arc(\n            wheelPos.x + Math.cos(markerAngle) * markerRadius,\n            wheelPos.y + Math.sin(markerAngle) * markerRadius,\n            4, 0, Math.PI * 2\n        );\n        this.ctx.fill();\n        \n        // Add a secondary marker 180 degrees opposite for better visual feedback\n        const oppositeMarkerAngle = spokeAngle + Math.PI;\n        this.ctx.fillStyle = '#4444ff'; // Blue marker\n        this.ctx.beginPath();\n        this.ctx.arc(\n            wheelPos.x + Math.cos(oppositeMarkerAngle) * markerRadius,\n            wheelPos.y + Math.sin(oppositeMarkerAngle) * markerRadius,\n            3, 0, Math.PI * 2\n        );\n        this.ctx.fill();\n    }\n    \n    /**\n     * Draw motor torque indicators\n     * @param {Object} wheelPos - Wheel position at ground level {x, y}\n     */\n    drawTorqueIndicators(wheelPos) {\n        if (Math.abs(this.motorTorque) < 0.1) return; // Don't show for very small torques\n        \n        const maxTorque = this.robotConfig?.motorStrength || 5.0;\n        const torqueRatio = Math.abs(this.motorTorque) / maxTorque;\n        const indicatorLength = torqueRatio * 80;\n        \n        // Color based on torque direction and magnitude\n        const intensity = Math.min(1.0, torqueRatio);\n        if (this.motorTorque > 0) {\n            this.ctx.strokeStyle = `rgba(255, 107, 53, ${intensity})` // Orange for positive torque\n        } else {\n            this.ctx.strokeStyle = `rgba(53, 107, 255, ${intensity})` // Blue for negative torque\n        }\n        \n        this.ctx.lineWidth = 4;\n        this.ctx.lineCap = 'round';\n        \n        // Draw torque arrow\n        const arrowY = wheelPos.y - 30;\n        const arrowStartX = wheelPos.x - indicatorLength/2;\n        const arrowEndX = wheelPos.x + indicatorLength/2;\n        \n        this.ctx.beginPath();\n        this.ctx.moveTo(arrowStartX, arrowY);\n        this.ctx.lineTo(arrowEndX, arrowY);\n        this.ctx.stroke();\n        \n        // Arrow head indicating direction\n        const headSize = 8;\n        if (this.motorTorque > 0) {\n            // Right arrow\n            this.ctx.beginPath();\n            this.ctx.moveTo(arrowEndX, arrowY);\n            this.ctx.lineTo(arrowEndX - headSize, arrowY - headSize/2);\n            this.ctx.moveTo(arrowEndX, arrowY);\n            this.ctx.lineTo(arrowEndX - headSize, arrowY + headSize/2);\n            this.ctx.stroke();\n        } else {\n            // Left arrow\n            this.ctx.beginPath();\n            this.ctx.moveTo(arrowStartX, arrowY);\n            this.ctx.lineTo(arrowStartX + headSize, arrowY - headSize/2);\n            this.ctx.moveTo(arrowStartX, arrowY);\n            this.ctx.lineTo(arrowStartX + headSize, arrowY + headSize/2);\n            this.ctx.stroke();\n        }\n    }\n    \n    /**\n     * Draw angle indicator arc\n     * @param {Object} wheelPos - Wheel position at ground level {x, y}\n     * @param {number} angle - Current angle in radians\n     */\n    drawAngleIndicator(wheelPos, angle) {\n        const arcRadius = 50;\n        \n        this.ctx.strokeStyle = this.config.robotColor;\n        this.ctx.lineWidth = 2;\n        this.ctx.globalAlpha = 0.7;\n        \n        // Draw angle arc\n        this.ctx.beginPath();\n        this.ctx.arc(wheelPos.x, wheelPos.y, arcRadius, -Math.PI/2, -Math.PI/2 + angle, angle < 0);\n        this.ctx.stroke();\n        \n        this.ctx.globalAlpha = 1.0;\n    }\n    \n    /**\n     * Draw UI overlays (text, metrics, debug info)\n     */\n    drawUI() {\n        if (this.showRobotInfo) {\n            this.drawRobotInfo();\n        }\n        \n        if (this.showTrainingInfo) {\n            this.drawTrainingInfo();\n        }\n        \n        if (this.showPerformanceInfo) {\n            this.drawPerformanceInfo();\n        }\n    }\n    \n    /**\n     * Draw robot state information\n     */\n    drawRobotInfo() {\n        if (!this.robotState) return;\n        \n        const { angle, angularVelocity, position, velocity } = this.robotState;\n        \n        this.ctx.fillStyle = this.config.textColor;\n        this.ctx.font = '18px monospace';\n        this.ctx.textAlign = 'left';\n        \n        const infoX = 20;\n        let infoY = 30;\n        const lineHeight = 18;\n        \n        // Background for better readability\n        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n        this.ctx.fillRect(infoX - 10, infoY - 15, 200, 110);\n        \n        this.ctx.fillStyle = this.config.textColor;\n        this.ctx.fillText('Robot State:', infoX, infoY);\n        infoY += lineHeight;\n        \n        this.ctx.fillText(`Angle: ${(angle * 180 / Math.PI).toFixed(1)}°`, infoX, infoY);\n        infoY += lineHeight;\n        \n        this.ctx.fillText(`Angular Vel: ${angularVelocity.toFixed(2)} rad/s`, infoX, infoY);\n        infoY += lineHeight;\n        \n        this.ctx.fillText(`Position: ${position.toFixed(2)} m`, infoX, infoY);\n        infoY += lineHeight;\n        \n        this.ctx.fillText(`Velocity: ${velocity.toFixed(2)} m/s`, infoX, infoY);\n        infoY += lineHeight;\n        \n        this.ctx.fillText(`Motor Torque: ${this.motorTorque.toFixed(2)} N⋅m`, infoX, infoY);\n    }\n    \n    /**\n     * Draw training information\n     */\n    drawTrainingInfo() {\n        const metrics = this.trainingMetrics;\n        \n        this.ctx.fillStyle = this.config.textColor;\n        this.ctx.font = '18px monospace';\n        this.ctx.textAlign = 'right';\n        \n        const infoX = this.canvas.width - 20;\n        let infoY = 30;\n        const lineHeight = 18;\n        \n        // Background for better readability\n        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n        this.ctx.fillRect(infoX - 190, infoY - 15, 200, 130);\n        \n        this.ctx.fillStyle = this.config.textColor;\n        this.ctx.fillText('Training Status:', infoX, infoY);\n        infoY += lineHeight;\n        \n        this.ctx.fillText(`Mode: ${metrics.trainingMode}`, infoX, infoY);\n        infoY += lineHeight;\n        \n        this.ctx.fillText(`Episode: ${metrics.episode}`, infoX, infoY);\n        infoY += lineHeight;\n        \n        this.ctx.fillText(`Step: ${metrics.step}`, infoX, infoY);\n        infoY += lineHeight;\n        \n        this.ctx.fillText(`Reward: ${metrics.reward.toFixed(1)}`, infoX, infoY);\n        infoY += lineHeight;\n        \n        this.ctx.fillText(`Best: ${metrics.bestReward.toFixed(1)}`, infoX, infoY);\n        infoY += lineHeight;\n        \n        this.ctx.fillText(`Epsilon: ${metrics.epsilon.toFixed(3)}`, infoX, infoY);\n    }\n    \n    /**\n     * Draw performance information\n     */\n    drawPerformanceInfo() {\n        const perfMetrics = this.performance.getMetrics();\n        \n        this.ctx.fillStyle = this.config.textColor;\n        this.ctx.font = '16px monospace';\n        this.ctx.textAlign = 'left';\n        \n        const infoX = 20;\n        const infoY = this.canvas.height - 20;\n        \n        // Background for better readability\n        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n        this.ctx.fillRect(infoX - 10, infoY - 35, 200, 45);\n        \n        // Color code FPS based on performance\n        const fpsColor = this.performance.isPerformanceGood() ? '#00ff88' : '#ff4444';\n        this.ctx.fillStyle = fpsColor;\n        this.ctx.fillText(`FPS: ${perfMetrics.fps}`, infoX, infoY - 20);\n        \n        this.ctx.fillStyle = this.config.textColor;\n        this.ctx.fillText(`Frame: ${perfMetrics.avgFrameTime}ms (${perfMetrics.minFrameTime}-${perfMetrics.maxFrameTime})`, infoX, infoY);\n    }\n    \n    /**\n     * Toggle UI element visibility\n     * @param {string} element - Element to toggle ('robot', 'training', 'performance')\n     */\n    toggleUI(element) {\n        switch (element) {\n            case 'robot':\n                this.showRobotInfo = !this.showRobotInfo;\n                break;\n            case 'training':\n                this.showTrainingInfo = !this.showTrainingInfo;\n                break;\n            case 'performance':\n                this.showPerformanceInfo = !this.showPerformanceInfo;\n                break;\n        }\n    }\n    \n    /**\n     * Update renderer configuration\n     * @param {Object} newConfig - Configuration updates\n     */\n    updateConfig(newConfig) {\n        this.config = { ...this.config, ...newConfig };\n    }\n    \n    /**\n     * Get renderer statistics\n     * @returns {Object} Renderer stats\n     */\n    getStats() {\n        return {\n            isRendering: this.isRendering,\n            canvasSize: { width: this.canvas.width, height: this.canvas.height },\n            performance: this.performance.getMetrics(),\n            targetFPS: this.config.targetFPS,\n            hasRobotState: !!this.robotState,\n            config: this.config\n        };\n    }\n    \n    /**\n     * Zoom in by 0.1 (clamped to max 3.0)\n     */\n    zoomIn() {\n        this.transform.zoomLevel = Math.min(3.0, this.transform.zoomLevel + 0.1);\n    }\n    \n    /**\n     * Zoom out by 0.1 (clamped to min 0.5)\n     */\n    zoomOut() {\n        this.transform.zoomLevel = Math.max(0.5, this.transform.zoomLevel - 0.1);\n    }\n    \n    /**\n     * Reset zoom to 1.0\n     */\n    resetZoom() {\n        this.transform.zoomLevel = 1.0;\n    }\n    \n    /**\n     * Get current zoom level\n     * @returns {number} Current zoom level\n     */\n    getZoomLevel() {\n        return this.transform.zoomLevel;\n    }\n    \n    /**\n     * Cleanup renderer resources\n     */\n    destroy() {\n        this.stop();\n        this.canvas = null;\n        this.ctx = null;\n        this.transform = null;\n        this.performance = null;\n        console.log('Renderer destroyed');\n    }\n}\n\n/**\n * Utility function to create a renderer with default configuration\n * @param {HTMLCanvasElement} canvas - Canvas element\n * @param {Object} config - Configuration overrides\n * @returns {Renderer} New renderer instance\n */\nexport function createRenderer(canvas, config = {}) {\n    return new Renderer(canvas, config);\n}\n\n/**\n * Utility function to create a high-performance renderer\n * @param {HTMLCanvasElement} canvas - Canvas element\n * @returns {Renderer} High-performance renderer\n */\nexport function createHighPerformanceRenderer(canvas) {\n    return new Renderer(canvas, {\n        targetFPS: 60,\n        showGrid: false,\n        showDebugInfo: true,\n        showPerformance: true\n    });\n}\n\n/**\n * Utility function to create a debug renderer with all visualizations\n * @param {HTMLCanvasElement} canvas - Canvas element\n * @returns {Renderer} Debug renderer\n */\nexport function createDebugRenderer(canvas) {\n    return new Renderer(canvas, {\n        targetFPS: 30,\n        showGrid: true,\n        showDebugInfo: true,\n        showPerformance: true,\n        gridColor: '#2a2a2a'\n    });\n}","/**\n * Performance Charts Module for Two-Wheel Balancing Robot RL Application\n * \n * Provides real-time charting capabilities for training metrics visualization\n * Features:\n * - Episode rewards tracking\n * - Training loss curve visualization\n * - Q-value estimates display\n * - Exploration rate (epsilon) tracking\n * - Canvas-based rendering for optimal performance\n * - Rolling window of last 100 data points\n */\n\n/**\n * Base chart class for common chart functionality\n */\nexport class BaseChart {\n    constructor(canvas, config = {}) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        \n        this.config = {\n            backgroundColor: config.backgroundColor || '#1a1a1a',\n            gridColor: config.gridColor || '#404040',\n            lineColor: config.lineColor || '#00d4ff',\n            textColor: config.textColor || '#ffffff',\n            axisColor: config.axisColor || '#666666',\n            padding: config.padding || 40,\n            maxDataPoints: config.maxDataPoints || 100,\n            title: config.title || '',\n            yLabel: config.yLabel || '',\n            xLabel: config.xLabel || 'Episodes',\n            showGrid: config.showGrid !== false,\n            ...config\n        };\n        \n        this.data = [];\n        this.minY = 0;\n        this.maxY = 1;\n        this.autoScale = config.autoScale !== false;\n    }\n    \n    /**\n     * Add new data point to the chart\n     * @param {number} value - Y value to add\n     * @param {number} x - X value (optional, uses data length if not provided)\n     */\n    addData(value, x = null) {\n        const dataPoint = {\n            x: x !== null ? x : this.data.length,\n            y: value\n        };\n        \n        this.data.push(dataPoint);\n        \n        // Keep only last N data points for performance\n        if (this.data.length > this.config.maxDataPoints) {\n            this.data.shift();\n        }\n        \n        // Update Y scale if auto-scaling\n        if (this.autoScale && this.data.length > 0) {\n            this.minY = Math.min(...this.data.map(d => d.y));\n            this.maxY = Math.max(...this.data.map(d => d.y));\n            \n            // Add some padding to Y range\n            const range = this.maxY - this.minY;\n            const padding = range * 0.1;\n            this.minY -= padding;\n            this.maxY += padding;\n            \n            // Ensure minimum range\n            if (range < 0.1) {\n                this.minY -= 0.05;\n                this.maxY += 0.05;\n            }\n        }\n    }\n    \n    /**\n     * Clear all data points\n     */\n    clear() {\n        this.data = [];\n        this.minY = 0;\n        this.maxY = 1;\n    }\n    \n    /**\n     * Convert data coordinates to canvas coordinates\n     * @param {number} x - Data X coordinate\n     * @param {number} y - Data Y coordinate\n     * @returns {Object} Canvas coordinates {x, y}\n     */\n    dataToCanvas(x, y) {\n        const chartWidth = this.canvas.width - 2 * this.config.padding;\n        const chartHeight = this.canvas.height - 2 * this.config.padding;\n        \n        let canvasX = this.config.padding;\n        if (this.data.length > 1) {\n            const minX = Math.min(...this.data.map(d => d.x));\n            const maxX = Math.max(...this.data.map(d => d.x));\n            const xRange = maxX - minX;\n            if (xRange > 0) {\n                canvasX = this.config.padding + ((x - minX) / xRange) * chartWidth;\n            }\n        }\n        \n        const yRange = this.maxY - this.minY;\n        let canvasY = this.canvas.height - this.config.padding;\n        if (yRange > 0) {\n            canvasY = this.canvas.height - this.config.padding - ((y - this.minY) / yRange) * chartHeight;\n        }\n        \n        return { x: canvasX, y: canvasY };\n    }\n    \n    /**\n     * Draw the chart background and grid\n     */\n    drawBackground() {\n        // Clear canvas\n        this.ctx.fillStyle = this.config.backgroundColor;\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        \n        // Draw chart area background\n        this.ctx.fillStyle = '#0a0a0a';\n        this.ctx.fillRect(\n            this.config.padding,\n            this.config.padding,\n            this.canvas.width - 2 * this.config.padding,\n            this.canvas.height - 2 * this.config.padding\n        );\n        \n        if (this.config.showGrid) {\n            this.drawGrid();\n        }\n        \n        this.drawAxes();\n        this.drawLabels();\n    }\n    \n    /**\n     * Draw grid lines\n     */\n    drawGrid() {\n        this.ctx.strokeStyle = this.config.gridColor;\n        this.ctx.lineWidth = 1;\n        this.ctx.globalAlpha = 0.3;\n        \n        const chartWidth = this.canvas.width - 2 * this.config.padding;\n        const chartHeight = this.canvas.height - 2 * this.config.padding;\n        \n        // Vertical grid lines\n        const numVerticalLines = 10;\n        for (let i = 0; i <= numVerticalLines; i++) {\n            const x = this.config.padding + (i / numVerticalLines) * chartWidth;\n            this.ctx.beginPath();\n            this.ctx.moveTo(x, this.config.padding);\n            this.ctx.lineTo(x, this.canvas.height - this.config.padding);\n            this.ctx.stroke();\n        }\n        \n        // Horizontal grid lines\n        const numHorizontalLines = 8;\n        for (let i = 0; i <= numHorizontalLines; i++) {\n            const y = this.config.padding + (i / numHorizontalLines) * chartHeight;\n            this.ctx.beginPath();\n            this.ctx.moveTo(this.config.padding, y);\n            this.ctx.lineTo(this.canvas.width - this.config.padding, y);\n            this.ctx.stroke();\n        }\n        \n        this.ctx.globalAlpha = 1.0;\n    }\n    \n    /**\n     * Draw chart axes\n     */\n    drawAxes() {\n        this.ctx.strokeStyle = this.config.axisColor;\n        this.ctx.lineWidth = 2;\n        \n        // X axis\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.config.padding, this.canvas.height - this.config.padding);\n        this.ctx.lineTo(this.canvas.width - this.config.padding, this.canvas.height - this.config.padding);\n        this.ctx.stroke();\n        \n        // Y axis\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.config.padding, this.config.padding);\n        this.ctx.lineTo(this.config.padding, this.canvas.height - this.config.padding);\n        this.ctx.stroke();\n    }\n    \n    /**\n     * Draw chart labels and title\n     */\n    drawLabels() {\n        this.ctx.fillStyle = this.config.textColor;\n        this.ctx.font = '12px monospace';\n        this.ctx.textAlign = 'center';\n        \n        // Title\n        if (this.config.title) {\n            this.ctx.font = '14px monospace';\n            this.ctx.fillText(this.config.title, this.canvas.width / 2, 20);\n            this.ctx.font = '12px monospace';\n        }\n        \n        // X axis label\n        if (this.config.xLabel) {\n            this.ctx.fillText(this.config.xLabel, this.canvas.width / 2, this.canvas.height - 5);\n        }\n        \n        // Y axis label (rotated)\n        if (this.config.yLabel) {\n            this.ctx.save();\n            this.ctx.translate(15, this.canvas.height / 2);\n            this.ctx.rotate(-Math.PI / 2);\n            this.ctx.fillText(this.config.yLabel, 0, 0);\n            this.ctx.restore();\n        }\n        \n        // Y axis scale\n        this.ctx.textAlign = 'right';\n        this.ctx.font = '10px monospace';\n        const numYLabels = 5;\n        for (let i = 0; i <= numYLabels; i++) {\n            const value = this.minY + (this.maxY - this.minY) * (1 - i / numYLabels);\n            const y = this.config.padding + (i / numYLabels) * (this.canvas.height - 2 * this.config.padding);\n            this.ctx.fillText(value.toFixed(2), this.config.padding - 5, y + 3);\n        }\n    }\n    \n    /**\n     * Draw the data line\n     */\n    drawLine() {\n        if (this.data.length < 2) return;\n        \n        this.ctx.strokeStyle = this.config.lineColor;\n        this.ctx.lineWidth = 2;\n        this.ctx.lineCap = 'round';\n        this.ctx.lineJoin = 'round';\n        \n        this.ctx.beginPath();\n        const firstPoint = this.dataToCanvas(this.data[0].x, this.data[0].y);\n        this.ctx.moveTo(firstPoint.x, firstPoint.y);\n        \n        for (let i = 1; i < this.data.length; i++) {\n            const point = this.dataToCanvas(this.data[i].x, this.data[i].y);\n            this.ctx.lineTo(point.x, point.y);\n        }\n        \n        this.ctx.stroke();\n        \n        // Draw data points\n        this.ctx.fillStyle = this.config.lineColor;\n        for (const dataPoint of this.data) {\n            const point = this.dataToCanvas(dataPoint.x, dataPoint.y);\n            this.ctx.beginPath();\n            this.ctx.arc(point.x, point.y, 2, 0, Math.PI * 2);\n            this.ctx.fill();\n        }\n    }\n    \n    /**\n     * Render the complete chart\n     */\n    render() {\n        this.drawBackground();\n        this.drawLine();\n    }\n    \n    /**\n     * Set custom Y scale range\n     * @param {number} min - Minimum Y value\n     * @param {number} max - Maximum Y value\n     */\n    setYRange(min, max) {\n        this.minY = min;\n        this.maxY = max;\n        this.autoScale = false;\n    }\n    \n    /**\n     * Get current data statistics\n     * @returns {Object} Statistics about current data\n     */\n    getStats() {\n        if (this.data.length === 0) {\n            return { count: 0, min: 0, max: 0, avg: 0, last: 0 };\n        }\n        \n        const values = this.data.map(d => d.y);\n        return {\n            count: this.data.length,\n            min: Math.min(...values),\n            max: Math.max(...values),\n            avg: values.reduce((sum, v) => sum + v, 0) / values.length,\n            last: values[values.length - 1]\n        };\n    }\n}\n\n/**\n * Main performance charts manager\n */\nexport class PerformanceCharts {\n    constructor(container, config = {}) {\n        this.container = container;\n        this.config = {\n            chartHeight: config.chartHeight || 150,\n            chartSpacing: config.chartSpacing || 10,\n            updateInterval: config.updateInterval || 100, // ms\n            ...config\n        };\n        \n        this.charts = {};\n        this.isRendering = false;\n        this.lastUpdate = 0;\n        \n        this.initializeCharts();\n        console.log('PerformanceCharts initialized');\n    }\n    \n    /**\n     * Initialize all chart canvases and chart instances\n     */\n    initializeCharts() {\n        // Create chart container structure\n        this.container.innerHTML = `\n            <div class=\"charts-header\">\n                <h3>Performance Metrics</h3>\n                <button id=\"clear-charts\" style=\"float: right; padding: 4px 8px; font-size: 0.8rem;\">Clear</button>\n            </div>\n            <div class=\"charts-grid\">\n                <div class=\"chart-item\">\n                    <canvas id=\"rewards-chart\"></canvas>\n                </div>\n                <div class=\"chart-item\">\n                    <canvas id=\"loss-chart\"></canvas>\n                </div>\n                <div class=\"chart-item\">\n                    <canvas id=\"qvalue-chart\"></canvas>\n                </div>\n                <div class=\"chart-item\">\n                    <canvas id=\"epsilon-chart\"></canvas>\n                </div>\n            </div>\n        `;\n        \n        // Add CSS styles\n        const style = document.createElement('style');\n        style.textContent = `\n            .charts-header {\n                padding: 10px;\n                background-color: #2d2d2d;\n                border-bottom: 1px solid #404040;\n                color: #00d4ff;\n                font-size: 1rem;\n                display: flex;\n                justify-content: space-between;\n                align-items: center;\n            }\n            .charts-grid {\n                display: flex;\n                flex-direction: column;\n                gap: ${this.config.chartSpacing}px;\n                padding: 10px;\n                background-color: #1a1a1a;\n            }\n            .chart-item {\n                background-color: #0a0a0a;\n                border: 1px solid #404040;\n                border-radius: 4px;\n            }\n            .chart-item canvas {\n                display: block;\n                width: 100%;\n                height: ${this.config.chartHeight}px;\n            }\n        `;\n        document.head.appendChild(style);\n        \n        // Initialize canvas elements and charts\n        this.initializeChart('rewards', 'Episode Rewards', 'Reward', '#00ff88');\n        this.initializeChart('loss', 'Training Loss', 'Loss', '#ff6b35');\n        this.initializeChart('qvalue', 'Q-Value Estimates', 'Q-Value', '#ffaa00');\n        this.initializeChart('epsilon', 'Exploration Rate', 'Epsilon', '#aa00ff');\n        \n        // Setup event handlers\n        document.getElementById('clear-charts').addEventListener('click', () => {\n            this.clearAllCharts();\n        });\n    }\n    \n    /**\n     * Initialize a specific chart\n     * @param {string} name - Chart name/ID\n     * @param {string} title - Chart title\n     * @param {string} yLabel - Y-axis label\n     * @param {string} color - Line color\n     */\n    initializeChart(name, title, yLabel, color) {\n        const canvas = document.getElementById(`${name}-chart`);\n        if (!canvas) return;\n        \n        // Set canvas size\n        const rect = canvas.getBoundingClientRect();\n        canvas.width = rect.width;\n        canvas.height = this.config.chartHeight;\n        \n        // Create chart instance\n        this.charts[name] = new BaseChart(canvas, {\n            title: title,\n            yLabel: yLabel,\n            lineColor: color,\n            padding: 30\n        });\n        \n        console.log(`Initialized ${name} chart`);\n    }\n    \n    /**\n     * Start the rendering loop\n     */\n    start() {\n        if (this.isRendering) return;\n        \n        this.isRendering = true;\n        this.lastUpdate = performance.now();\n        \n        const renderLoop = (currentTime) => {\n            if (!this.isRendering) return;\n            \n            // Limit update frequency\n            const deltaTime = currentTime - this.lastUpdate;\n            if (deltaTime >= this.config.updateInterval) {\n                this.renderAllCharts();\n                this.lastUpdate = currentTime;\n            }\n            \n            requestAnimationFrame(renderLoop);\n        };\n        \n        requestAnimationFrame(renderLoop);\n        console.log('PerformanceCharts rendering started');\n    }\n    \n    /**\n     * Stop the rendering loop\n     */\n    stop() {\n        this.isRendering = false;\n        console.log('PerformanceCharts rendering stopped');\n    }\n    \n    /**\n     * Render all charts\n     */\n    renderAllCharts() {\n        Object.values(this.charts).forEach(chart => {\n            chart.render();\n        });\n    }\n    \n    /**\n     * Update episode reward data\n     * @param {number} episode - Episode number\n     * @param {number} reward - Total episode reward\n     */\n    updateRewards(episode, reward) {\n        if (this.charts.rewards) {\n            this.charts.rewards.addData(reward, episode);\n        }\n    }\n    \n    /**\n     * Update training loss data\n     * @param {number} episode - Episode number\n     * @param {number} loss - Training loss value\n     */\n    updateLoss(episode, loss) {\n        if (this.charts.loss) {\n            this.charts.loss.addData(loss, episode);\n        }\n    }\n    \n    /**\n     * Update Q-value estimates\n     * @param {number} episode - Episode number\n     * @param {number} qValue - Average Q-value estimate\n     */\n    updateQValue(episode, qValue) {\n        if (this.charts.qvalue) {\n            this.charts.qvalue.addData(qValue, episode);\n        }\n    }\n    \n    /**\n     * Update exploration rate (epsilon)\n     * @param {number} episode - Episode number\n     * @param {number} epsilon - Current epsilon value\n     */\n    updateEpsilon(episode, epsilon) {\n        if (this.charts.epsilon) {\n            this.charts.epsilon.addData(epsilon, episode);\n        }\n    }\n    \n    /**\n     * Update multiple metrics at once\n     * @param {Object} metrics - Metrics object containing multiple values\n     */\n    updateMetrics(metrics) {\n        const episode = metrics.episode || 0;\n        \n        if (metrics.reward !== undefined) {\n            this.updateRewards(episode, metrics.reward);\n        }\n        if (metrics.loss !== undefined) {\n            this.updateLoss(episode, metrics.loss);\n        }\n        if (metrics.qValue !== undefined) {\n            this.updateQValue(episode, metrics.qValue);\n        }\n        if (metrics.epsilon !== undefined) {\n            this.updateEpsilon(episode, metrics.epsilon);\n        }\n    }\n    \n    /**\n     * Clear all chart data\n     */\n    clearAllCharts() {\n        Object.values(this.charts).forEach(chart => {\n            chart.clear();\n        });\n        console.log('All charts cleared');\n    }\n    \n    /**\n     * Resize all charts (call when container size changes)\n     */\n    resize() {\n        Object.entries(this.charts).forEach(([name, chart]) => {\n            const canvas = chart.canvas;\n            const rect = canvas.getBoundingClientRect();\n            canvas.width = rect.width;\n            canvas.height = this.config.chartHeight;\n        });\n        console.log('Charts resized');\n    }\n    \n    /**\n     * Get statistics for all charts\n     * @returns {Object} Statistics for each chart\n     */\n    getStats() {\n        const stats = {};\n        Object.entries(this.charts).forEach(([name, chart]) => {\n            stats[name] = chart.getStats();\n        });\n        return stats;\n    }\n    \n    /**\n     * Export chart data as JSON\n     * @returns {Object} Chart data for all charts\n     */\n    exportData() {\n        const data = {};\n        Object.entries(this.charts).forEach(([name, chart]) => {\n            data[name] = chart.data;\n        });\n        return data;\n    }\n    \n    /**\n     * Import chart data from JSON\n     * @param {Object} data - Chart data to import\n     */\n    importData(data) {\n        Object.entries(data).forEach(([name, chartData]) => {\n            if (this.charts[name]) {\n                this.charts[name].data = chartData;\n            }\n        });\n        console.log('Chart data imported');\n    }\n    \n    /**\n     * Cleanup resources\n     */\n    destroy() {\n        this.stop();\n        this.charts = {};\n        this.container.innerHTML = '';\n        console.log('PerformanceCharts destroyed');\n    }\n}\n\n/**\n * Utility function to create performance charts\n * @param {HTMLElement} container - Container element for charts\n * @param {Object} config - Configuration options\n * @returns {PerformanceCharts} New charts instance\n */\nexport function createPerformanceCharts(container, config = {}) {\n    return new PerformanceCharts(container, config);\n}\n\n/**\n * Utility function to create a single chart\n * @param {HTMLCanvasElement} canvas - Canvas element\n * @param {Object} config - Chart configuration\n * @returns {BaseChart} New chart instance\n */\nexport function createChart(canvas, config = {}) {\n    return new BaseChart(canvas, config);\n}","/**\n * Network Architecture Presets for Different Bot Models\n * \n * This module provides predefined network configurations optimized for different\n * types of balancing robots and control scenarios. Each preset includes architecture\n * specifications, hyperparameters, and deployment constraints.\n */\n\n/**\n * Base network architecture configuration\n */\nexport class NetworkArchitecture {\n    constructor(config) {\n        this.name = config.name || 'Custom';\n        this.description = config.description || '';\n        this.inputSize = config.inputSize || 2;\n        this.outputSize = config.outputSize || 3;\n        this.layers = config.layers || [8]; // Hidden layer sizes\n        this.activations = config.activations || ['relu'];\n        this.maxParameters = config.maxParameters || 200;\n        this.memoryConstraint = config.memoryConstraint || 1024; // KB\n        this.targetFrequency = config.targetFrequency || 50; // Hz\n        this.deployment = config.deployment || 'web'; // web, embedded, mobile\n    }\n\n    /**\n     * Get total parameter count for this architecture\n     */\n    getParameterCount() {\n        let totalParams = 0;\n        let prevSize = this.inputSize;\n        \n        for (const layerSize of this.layers) {\n            // Weights + biases for each layer\n            totalParams += (prevSize * layerSize) + layerSize;\n            prevSize = layerSize;\n        }\n        \n        // Final output layer\n        totalParams += (prevSize * this.outputSize) + this.outputSize;\n        \n        return totalParams;\n    }\n\n    /**\n     * Validate architecture constraints\n     */\n    validate() {\n        const errors = [];\n        \n        if (this.layers.length === 0) {\n            errors.push('At least one hidden layer is required');\n        }\n        \n        if (this.layers.length > 8) {\n            errors.push('Maximum 8 layers supported');\n        }\n        \n        for (const [i, size] of this.layers.entries()) {\n            if (size < 1 || size > 256) {\n                errors.push(`Layer ${i + 1}: Size must be between 1 and 256, got ${size}`);\n            }\n        }\n        \n        const paramCount = this.getParameterCount();\n        if (paramCount > this.maxParameters) {\n            errors.push(`Parameter count ${paramCount} exceeds limit ${this.maxParameters}`);\n        }\n        \n        return {\n            valid: errors.length === 0,\n            errors: errors,\n            parameterCount: paramCount\n        };\n    }\n\n    /**\n     * Create a copy of this architecture\n     */\n    clone() {\n        return new NetworkArchitecture({\n            name: this.name,\n            description: this.description,\n            inputSize: this.inputSize,\n            outputSize: this.outputSize,\n            layers: [...this.layers],\n            activations: [...this.activations],\n            maxParameters: this.maxParameters,\n            memoryConstraint: this.memoryConstraint,\n            targetFrequency: this.targetFrequency,\n            deployment: this.deployment\n        });\n    }\n}\n\n/**\n * Predefined network architectures for different bot models\n */\nexport const NetworkPresets = {\n    // Minimal architecture for very constrained embedded systems\n    MICRO: new NetworkArchitecture({\n        name: 'Micro Bot',\n        description: 'Ultra-minimal for 8-bit microcontrollers (< 32KB RAM)',\n        layers: [4],\n        maxParameters: 50,\n        memoryConstraint: 32,\n        targetFrequency: 20,\n        deployment: 'embedded'\n    }),\n    \n    // Lightweight architecture for basic balancing\n    NANO: new NetworkArchitecture({\n        name: 'Nano Bot',\n        description: 'Lightweight for basic two-wheel balancing (Arduino Nano)',\n        layers: [6],\n        maxParameters: 80,\n        memoryConstraint: 64,\n        targetFrequency: 30,\n        deployment: 'embedded'\n    }),\n    \n    // Current default architecture\n    CLASSIC: new NetworkArchitecture({\n        name: 'Classic Bot',\n        description: 'Standard two-wheel balancing robot (ESP32/STM32)',\n        layers: [8],\n        maxParameters: 150,\n        memoryConstraint: 256,\n        targetFrequency: 50,\n        deployment: 'embedded'\n    }),\n    \n    // Enhanced architecture for better performance\n    ENHANCED: new NetworkArchitecture({\n        name: 'Enhanced Bot',\n        description: 'Improved control with deeper network (Raspberry Pi)',\n        layers: [12, 8],\n        maxParameters: 400,\n        memoryConstraint: 512,\n        targetFrequency: 50,\n        deployment: 'embedded'\n    }),\n    \n    // Advanced architecture for complex behaviors\n    ADVANCED: new NetworkArchitecture({\n        name: 'Advanced Bot',\n        description: 'Multi-layer network for complex maneuvers',\n        layers: [16, 12, 8],\n        maxParameters: 800,\n        memoryConstraint: 1024,\n        targetFrequency: 100,\n        deployment: 'embedded'\n    }),\n    \n    // High-performance architecture for research\n    RESEARCH: new NetworkArchitecture({\n        name: 'Research Bot',\n        description: 'Deep network for research and experimentation',\n        layers: [32, 24, 16, 8],\n        maxParameters: 2000,\n        memoryConstraint: 4096,\n        targetFrequency: 100,\n        deployment: 'web'\n    }),\n    \n    // Maximum architecture for web-based training\n    MAXIMUM: new NetworkArchitecture({\n        name: 'Maximum Bot',\n        description: 'Largest network for intensive web training',\n        layers: [64, 48, 32, 24, 16],\n        maxParameters: 10000,\n        memoryConstraint: 16384,\n        targetFrequency: 200,\n        deployment: 'web'\n    }),\n    \n    // DQN Standard architecture matching PyTorch tutorial\n    DQN_STANDARD: new NetworkArchitecture({\n        name: 'DQN Standard',\n        description: 'PyTorch DQN tutorial standard (proven hyperparameters)',\n        layers: [128],\n        maxParameters: 1000,\n        memoryConstraint: 2048,\n        targetFrequency: 100,\n        deployment: 'web'\n    }),\n    \n    // Custom starting point\n    CUSTOM: new NetworkArchitecture({\n        name: 'Custom',\n        description: 'User-defined architecture',\n        layers: [8],\n        maxParameters: 1000,\n        memoryConstraint: 2048,\n        targetFrequency: 50,\n        deployment: 'web'\n    })\n};\n\n/**\n * Get preset by name\n */\nexport function getPreset(name) {\n    return NetworkPresets[name.toUpperCase()];\n}\n\n/**\n * Get all preset names\n */\nexport function getPresetNames() {\n    return Object.keys(NetworkPresets);\n}\n\n/**\n * Get presets suitable for a specific deployment target\n */\nexport function getPresetsForDeployment(deployment) {\n    return Object.entries(NetworkPresets)\n        .filter(([name, preset]) => preset.deployment === deployment)\n        .map(([name, preset]) => ({ name, preset }));\n}\n\n/**\n * Create a custom architecture with validation\n */\nexport function createCustomArchitecture(config) {\n    const arch = new NetworkArchitecture(config);\n    const validation = arch.validate();\n    \n    if (!validation.valid) {\n        throw new Error(`Invalid architecture: ${validation.errors.join(', ')}`);\n    }\n    \n    return arch;\n}\n\n/**\n * Architecture optimization utilities\n */\nexport class ArchitectureOptimizer {\n    /**\n     * Suggest optimal architecture for given constraints\n     */\n    static suggestArchitecture(constraints) {\n        const {\n            maxParameters = 200,\n            minLayers = 1,\n            maxLayers = 3,\n            targetAccuracy = 0.8,\n            deployment = 'embedded'\n        } = constraints;\n        \n        // Find presets that fit constraints\n        const suitablePresets = Object.entries(NetworkPresets)\n            .filter(([name, preset]) => {\n                return preset.getParameterCount() <= maxParameters &&\n                       preset.layers.length >= minLayers &&\n                       preset.layers.length <= maxLayers &&\n                       preset.deployment === deployment;\n            })\n            .sort((a, b) => b[1].getParameterCount() - a[1].getParameterCount());\n        \n        if (suitablePresets.length > 0) {\n            return suitablePresets[0][1];\n        }\n        \n        // Generate custom architecture\n        const layers = [];\n        let remainingParams = maxParameters - 6; // Reserve for output layer\n        let currentLayer = Math.min(16, Math.floor(remainingParams / 10));\n        \n        for (let i = 0; i < maxLayers && remainingParams > 0; i++) {\n            const layerSize = Math.max(4, Math.min(currentLayer, Math.floor(remainingParams / (maxLayers - i))));\n            layers.push(layerSize);\n            remainingParams -= layerSize * (i === 0 ? 2 : layers[i-1]);\n            currentLayer = Math.max(4, Math.floor(currentLayer * 0.7));\n        }\n        \n        return new NetworkArchitecture({\n            name: 'Auto-Generated',\n            description: `Optimized for ${maxParameters} parameters`,\n            layers: layers,\n            maxParameters: maxParameters,\n            deployment: deployment\n        });\n    }\n    \n    /**\n     * Optimize existing architecture for better performance\n     */\n    static optimizeArchitecture(architecture, performance) {\n        const optimized = architecture.clone();\n        \n        // Simple optimization heuristics based on performance\n        if (performance.accuracy < 0.6) {\n            // Increase capacity\n            optimized.layers = optimized.layers.map(size => Math.min(256, Math.floor(size * 1.2)));\n        } else if (performance.accuracy > 0.9 && performance.speed < 50) {\n            // Reduce capacity for speed\n            optimized.layers = optimized.layers.map(size => Math.max(4, Math.floor(size * 0.8)));\n        }\n        \n        return optimized;\n    }\n}\n\n/**\n * Export utilities for backward compatibility\n */\nexport function validateArchitecture(inputSize, layers, outputSize, maxParams = 200) {\n    const arch = new NetworkArchitecture({\n        inputSize,\n        outputSize,\n        layers: Array.isArray(layers) ? layers : [layers],\n        maxParameters: maxParams\n    });\n    \n    return arch.validate();\n}\n\nexport function calculateParameterCount(inputSize, layers, outputSize) {\n    const arch = new NetworkArchitecture({\n        inputSize,\n        outputSize,\n        layers: Array.isArray(layers) ? layers : [layers]\n    });\n    \n    return arch.getParameterCount();\n}","/**\n * StateHistory class for managing a rolling buffer of past robot states\n * Used for multi-timestep neural network inputs to capture temporal patterns\n */\nexport class StateHistory {\n    /**\n     * Create a new StateHistory buffer\n     * @param {number} maxTimesteps - Maximum number of timesteps to store (1-8)\n     */\n    constructor(maxTimesteps = 1) {\n        this.maxTimesteps = Math.max(1, Math.min(8, maxTimesteps));\n        this.history = [];\n        this.currentTimesteps = 1; // Start with single timestep\n        \n        // Initialize with empty buffer - will be filled by robot on first reset\n    }\n    \n    /**\n     * Update the number of timesteps to use\n     * @param {number} timesteps - Number of timesteps (1-8)\n     */\n    setTimesteps(timesteps) {\n        this.currentTimesteps = Math.max(1, Math.min(8, timesteps));\n        \n        // If history is empty or we need more history than we have, pad with the last known state or zeros\n        while (this.history.length < this.currentTimesteps) {\n            if (this.history.length > 0) {\n                // Duplicate the last known state\n                const lastState = this.history[this.history.length - 1];\n                this.history.push({ \n                    angle: lastState.angle, \n                    angularVelocity: lastState.angularVelocity,\n                    timestamp: Date.now()\n                });\n            } else {\n                // No history yet, use zeros as fallback\n                this.history.push({ \n                    angle: 0, \n                    angularVelocity: 0,\n                    timestamp: Date.now()\n                });\n            }\n        }\n    }\n    \n    /**\n     * Add a new state to the history buffer\n     * @param {number} angle - Current angle (or measured angle with offset)\n     * @param {number} angularVelocity - Current angular velocity\n     */\n    addState(angle, angularVelocity) {\n        // Add new state to the front\n        this.history.unshift({\n            angle: angle,\n            angularVelocity: angularVelocity,\n            timestamp: Date.now()\n        });\n        \n        // Keep only the maximum number of timesteps\n        if (this.history.length > this.maxTimesteps) {\n            this.history.pop();\n        }\n    }\n    \n    /**\n     * Get normalized inputs for neural network\n     * @param {number} maxAngle - Maximum angle for normalization\n     * @returns {Float32Array} Flattened array of [angle, angVel] for each timestep\n     */\n    getNormalizedInputs(maxAngle = Math.PI / 3) {\n        // Create array with size = currentTimesteps * 2 (angle + angular velocity per timestep)\n        const inputSize = this.currentTimesteps * 2;\n        const inputs = new Float32Array(inputSize);\n        \n        // Fill the array with normalized values\n        for (let i = 0; i < this.currentTimesteps; i++) {\n            let angle = 0;\n            let angularVelocity = 0;\n            \n            // Use history if available, otherwise use zeros (padding)\n            if (i < this.history.length) {\n                angle = this.history[i].angle;\n                angularVelocity = this.history[i].angularVelocity;\n            }\n            \n            // Normalize and clamp values\n            const normalizedAngle = Math.max(-1, Math.min(1, angle / maxAngle));\n            const normalizedAngularVelocity = Math.max(-1, Math.min(1, angularVelocity / 10));\n            \n            // Store in flattened array: [angle0, angVel0, angle1, angVel1, ...]\n            inputs[i * 2] = normalizedAngle;\n            inputs[i * 2 + 1] = normalizedAngularVelocity;\n        }\n        \n        return inputs;\n    }\n    \n    /**\n     * Get raw history for debugging/visualization\n     * @returns {Array} Array of state objects\n     */\n    getHistory() {\n        return this.history.slice(0, this.currentTimesteps);\n    }\n    \n    /**\n     * Reset the history buffer\n     */\n    reset() {\n        this.history = [];\n        // Clear the buffer - it will be filled with actual states by the caller\n        // This allows the robot to pre-fill with appropriate initial states\n    }\n    \n    /**\n     * Get statistics about the history\n     * @returns {Object} Statistics object\n     */\n    getStats() {\n        const validHistory = this.history.slice(0, this.currentTimesteps);\n        \n        // Calculate average angle and angular velocity\n        let avgAngle = 0;\n        let avgAngularVelocity = 0;\n        let angleVariance = 0;\n        \n        for (const state of validHistory) {\n            avgAngle += state.angle;\n            avgAngularVelocity += state.angularVelocity;\n        }\n        \n        avgAngle /= validHistory.length;\n        avgAngularVelocity /= validHistory.length;\n        \n        // Calculate variance for angle (useful for detecting oscillations)\n        for (const state of validHistory) {\n            angleVariance += Math.pow(state.angle - avgAngle, 2);\n        }\n        angleVariance /= validHistory.length;\n        \n        return {\n            currentTimesteps: this.currentTimesteps,\n            historyLength: validHistory.length,\n            averageAngle: avgAngle,\n            averageAngularVelocity: avgAngularVelocity,\n            angleVariance: angleVariance,\n            angleStdDev: Math.sqrt(angleVariance)\n        };\n    }\n}","/**\n * Physics simulation for a two-wheel balancing robot using inverted pendulum model\n * \n * This implementation provides:\n * - RobotState class for state representation\n * - BalancingRobot class with configurable physics parameters\n * - Fixed timestep simulation (20ms / 50Hz)\n * - Reward function for reinforcement learning\n * - Parameter validation and boundary conditions\n */\n\nimport { StateHistory } from './StateHistory.js';\n\n/**\n * Represents the complete state of the balancing robot\n */\nexport class RobotState {\n    /**\n     * @param {number} angle - Robot tilt angle in radians (0 = upright, positive = tilting forward)\n     * @param {number} angularVelocity - Angular velocity in rad/s\n     * @param {number} position - Horizontal position in meters\n     * @param {number} velocity - Horizontal velocity in m/s\n     * @param {number} wheelAngle - Wheel rotation angle in radians\n     * @param {number} wheelVelocity - Wheel angular velocity in rad/s\n     */\n    constructor(angle = 0, angularVelocity = 0, position = 0, velocity = 0, wheelAngle = 0, wheelVelocity = 0) {\n        this.angle = angle;\n        this.angularVelocity = angularVelocity;\n        this.position = position;\n        this.velocity = velocity;\n        this.wheelAngle = wheelAngle;        // Wheel rotation angle in radians\n        this.wheelVelocity = wheelVelocity;     // Wheel angular velocity in rad/s\n    }\n\n    /**\n     * Create a copy of this state\n     * @returns {RobotState} New state instance with same values\n     */\n    clone() {\n        return new RobotState(this.angle, this.angularVelocity, this.position, this.velocity, this.wheelAngle, this.wheelVelocity);\n    }\n\n    /**\n     * Get normalized state for neural network input\n     * @param {number} maxAngle - Maximum angle for normalization (passed from robot instance)\n     * @returns {Float32Array} [normalizedAngle, normalizedAngularVelocity]\n     */\n    getNormalizedInputs(maxAngle = Math.PI / 3) {\n        // Normalize angle to [-1, 1] range using configurable max angle and clamp\n        const normalizedAngle = Math.max(-1, Math.min(1, this.angle / maxAngle));\n        // Normalize angular velocity to [-1, 1] range (assuming max is 10 rad/s) and clamp\n        const normalizedAngularVelocity = Math.max(-1, Math.min(1, this.angularVelocity / 10));\n        \n        return new Float32Array([normalizedAngle, normalizedAngularVelocity]);\n    }\n\n    /**\n     * Check if the robot has failed (fallen over)\n     * @param {number} maxAngle - Maximum angle before failure (passed from robot instance)\n     * @returns {boolean} True if robot has fallen\n     */\n    hasFailed(maxAngle = Math.PI / 3) {\n        return Math.abs(this.angle) > maxAngle;\n    }\n}\n\n/**\n * Physics simulation for a two-wheel balancing robot\n * Implements inverted pendulum dynamics with motor control\n */\nexport class BalancingRobot {\n    /**\n     * @param {Object} config - Robot configuration parameters\n     * @param {number} config.mass - Robot mass in kg (0.5 - 3.0, default: 1.0)\n     * @param {number} config.centerOfMassHeight - Height of center of mass in meters (0.2 - 1.0, default: 0.5)\n     * @param {number} config.motorStrength - Maximum motor torque in N⋅m (2 - 20, default: 5)\n     * @param {number} config.friction - Friction coefficient (0 - 1, default: 0.1)\n     * @param {number} config.damping - Angular damping coefficient (0 - 1, default: 0.05)\n     * @param {number} config.timestep - Physics timestep in seconds (default: 0.02 = 20ms)\n     * @param {number} config.maxAngle - Maximum tilt angle before failure in radians (π/180 - π/3, 1-60°, default: π/6 ≈ 30°)\n     * @param {number} config.motorTorqueRange - Motor torque action range in N⋅m (0.5 - 10.0, default: 8.0)\n     */\n    constructor(config = {}) {\n        // Validate and set parameters with defaults\n        this.mass = this._validateParameter(config.mass, 1.0, 0.5, 3.0, 'mass');\n        this.centerOfMassHeight = this._validateParameter(config.centerOfMassHeight, 0.4, 0.2, 1.0, 'centerOfMassHeight');\n        this.motorStrength = this._validateParameter(config.motorStrength, 5.0, 2.0, 20.0, 'motorStrength');\n        this.friction = this._validateParameter(config.friction, 0.02, 0.0, 1.0, 'friction');\n        this.damping = this._validateParameter(config.damping, 0.01, 0.0, 1.0, 'damping');\n        this.timestep = this._validateParameter(config.timestep, 0.02, 0.001, 0.1, 'timestep');\n        this.wheelRadius = this._validateParameter(config.wheelRadius, 0.12, 0.02, 0.20, 'wheelRadius');\n        this.wheelMass = this._validateParameter(config.wheelMass, 0.2, 0.1, 1.0, 'wheelMass');\n        this.wheelFriction = this._validateParameter(config.wheelFriction, 0.3, 0.0, 1.0, 'wheelFriction');\n        \n        // Configurable angle and motor limits\n        this.maxAngle = this._validateParameter(config.maxAngle, Math.PI / 6, Math.PI / 180, Math.PI / 3, 'maxAngle'); // Default 30 degrees, range 1-60 degrees\n        this.motorTorqueRange = this._validateParameter(config.motorTorqueRange, 8.0, 0.5, 10.0, 'motorTorqueRange'); // Default ±8.0 Nm\n        \n        // Reward function type: 'simple' (CartPole-style) or 'complex' (angle-proportional)\n        this.rewardType = config.rewardType || 'simple';\n\n        // Angle offset simulation for offset-adaptive reward learning\n        this.angleOffset = this._validateParameter(config.angleOffset, 0.0, -Math.PI/6, Math.PI/6, 'angleOffset');\n        this.offsetVariation = this._validateParameter(config.offsetVariation, 0.01, 0.0, 0.1, 'offsetVariation');\n        this.offsetChangeRate = this._validateParameter(config.offsetChangeRate, 0.001, 0.0, 0.01, 'offsetChangeRate');\n        this.trainingOffsetRange = this._validateParameter(config.trainingOffsetRange, 0.0, 0.0, Math.PI/6, 'trainingOffsetRange');\n        \n        // Offset-adaptive reward learning parameters\n        this.balancePointEstimate = 0.0; // Running estimate of the true balance point\n        this.balancePointConfidence = 0.0; // Confidence in the estimate (0-1)\n        this.adaptationRate = 0.02; // How fast to adapt balance point estimate\n\n        // Physical constants\n        this.gravity = 9.81; // m/s²\n        // For a uniform rod of length L rotating about one end: I = (1/3) * m * L^2\n        // But for a point mass at height h: I = m * h^2\n        // Use point mass approximation for inverted pendulum\n        this.momentOfInertia = this.mass * this.centerOfMassHeight * this.centerOfMassHeight;\n        \n        // Wheel moment of inertia (for solid cylinder: I = 0.5 * m * r^2)\n        this.wheelInertia = 0.5 * this.wheelMass * this.wheelRadius * this.wheelRadius;\n\n        // Initialize state\n        this.state = new RobotState();\n        this.currentMotorTorque = 0;\n        this.previousMotorTorque = 0; // Track previous torque for energy efficiency calculation\n        \n        // State history for multi-timestep inputs\n        this.historyTimesteps = this._validateParameter(config.historyTimesteps, 1, 1, 8, 'historyTimesteps');\n        this.stateHistory = new StateHistory(8); // Always create with max capacity\n        this.stateHistory.setTimesteps(this.historyTimesteps);\n        \n        // Statistics\n        this.stepCount = 0;\n        this.totalReward = 0;\n    }\n\n    /**\n     * Validate a parameter is within acceptable bounds\n     * @private\n     */\n    _validateParameter(value, defaultValue, min, max, name) {\n        if (value === undefined || value === null) {\n            return defaultValue;\n        }\n        if (typeof value !== 'number' || isNaN(value)) {\n            console.warn(`Invalid ${name}: ${value}, using default: ${defaultValue}`);\n            return defaultValue;\n        }\n        if (value < min || value > max) {\n            console.warn(`${name} out of range [${min}, ${max}]: ${value}, clamping`);\n            return Math.max(min, Math.min(max, value));\n        }\n        return value;\n    }\n\n    /**\n     * Reset the robot to initial state\n     * @param {Object} initialState - Optional initial state values\n     */\n    reset(initialState = {}) {\n        this.state = new RobotState(\n            this._normalizeAngle(initialState.angle || 0),\n            initialState.angularVelocity || 0,\n            initialState.position || 0,\n            initialState.velocity || 0,\n            initialState.wheelAngle || 0,\n            initialState.wheelVelocity || 0\n        );\n        this.currentMotorTorque = 0;\n        this.previousMotorTorque = 0;\n        this.stepCount = 0;\n        this.totalReward = 0;\n        \n        // Apply random offset for offset-adaptive training\n        if (this.rewardType === 'offset-adaptive' && this.trainingOffsetRange > 0) {\n            // Generate random offset within ±trainingOffsetRange\n            const randomOffsetRadians = (Math.random() - 0.5) * 2 * this.trainingOffsetRange;\n            this.angleOffset = randomOffsetRadians;\n            console.log(`Training: Applied random offset: ${(randomOffsetRadians * 180 / Math.PI).toFixed(2)}°`);\n        }\n        \n        // Reset state history\n        this.stateHistory.reset();\n        \n        // Pre-fill history buffer with initial state for multi-timestep models\n        // This ensures the model gets proper inputs immediately after reset\n        const measuredAngle = this.getMeasuredAngle();\n        const initialAngularVelocity = this.state.angularVelocity;\n        \n        // Fill the entire history buffer with the initial state\n        // This is important for multi-timestep models to work correctly in free run\n        for (let i = 0; i < this.stateHistory.maxTimesteps; i++) {\n            this.stateHistory.addState(measuredAngle, initialAngularVelocity);\n        }\n    }\n\n    /**\n     * Apply motor torque and update physics simulation\n     * @param {number} motorTorque - Motor torque in N⋅m (clamped to ±motorStrength)\n     * @returns {Object} {state: RobotState, reward: number, done: boolean}\n     */\n    step(motorTorque) {\n        // Check if robot has already failed before physics update\n        if (this.state.hasFailed(this.maxAngle)) {\n            return {\n                state: this.state.clone(),\n                reward: this.rewardType === 'simple' ? 0.0 : -10.0,\n                done: true\n            };\n        }\n\n        // Store previous torque for energy efficiency calculation\n        this.previousMotorTorque = this.currentMotorTorque;\n        \n        // Scale motor torque by the configurable range, then clamp to motor strength\n        const scaledTorque = motorTorque * this.motorTorqueRange;\n        this.currentMotorTorque = Math.max(-this.motorStrength, Math.min(this.motorStrength, scaledTorque));\n\n        // Store previous state for reward calculation\n        const prevState = this.state.clone();\n\n        // Update physics using Euler integration\n        this._updatePhysics();\n\n        // Normalize angle to [-π, π] range\n        this.state.angle = this._normalizeAngle(this.state.angle);\n\n        // Calculate reward\n        const reward = this._calculateReward(prevState, this.currentMotorTorque);\n        this.totalReward += reward;\n\n        // Check if episode is done after physics update\n        const done = this.state.hasFailed(this.maxAngle);\n\n        this.stepCount++;\n\n        return {\n            state: this.state.clone(),\n            reward: reward,\n            done: done\n        };\n    }\n\n    /**\n     * Update physics simulation using Euler integration\n     * @private\n     */\n    _updatePhysics() {\n        const dt = this.timestep;\n        \n        // Calculate pendulum torques\n        const gravityTorque = this.mass * this.gravity * this.centerOfMassHeight * Math.sin(this.state.angle);\n        const dampingTorque = -this.damping * this.state.angularVelocity;\n        \n        // Motor torque acts on wheels, creating opposite reaction on pendulum (Newton's 3rd law)\n        const pendulumTorque = -this.currentMotorTorque + gravityTorque + dampingTorque;\n        \n        // Calculate angular acceleration of pendulum\n        const angularAcceleration = pendulumTorque / this.momentOfInertia;\n        \n        // Update pendulum angular motion\n        this.state.angularVelocity += angularAcceleration * dt;\n        this.state.angle += this.state.angularVelocity * dt;\n        \n        // Simplified wheel dynamics - direct coupling for visual clarity\n        // Motor torque creates force through wheels\n        const motorForce = this.currentMotorTorque / this.wheelRadius;\n\n        // Ground friction force (opposing motion)\n        const normalForce = this.mass * this.gravity;\n        const frictionForce = -this.friction * this.state.velocity * normalForce;\n\n        // Total horizontal force\n        const totalForce = motorForce + frictionForce;\n\n        // Update horizontal motion\n        const horizontalAcceleration = totalForce / this.mass;\n        this.state.velocity += horizontalAcceleration * dt;\n        this.state.position += this.state.velocity * dt;\n\n        // Update wheel rotation to exactly match movement (no slip)\n        // For perfect rolling: distance = radius * angle\n        const distanceTraveled = this.state.velocity * dt;\n        const wheelRotationChange = distanceTraveled / this.wheelRadius;\n        this.state.wheelAngle += wheelRotationChange;\n\n        // Keep wheel angle in reasonable range to prevent overflow\n        while (this.state.wheelAngle > Math.PI * 2) this.state.wheelAngle -= Math.PI * 2;\n        while (this.state.wheelAngle < -Math.PI * 2) this.state.wheelAngle += Math.PI * 2;\n\n        // Set wheel velocity to match (for consistency)\n        this.state.wheelVelocity = this.state.velocity / this.wheelRadius;\n        \n        // Update angle offset simulation (for offset-adaptive reward)\n        this._updateAngleOffset(dt);\n        \n        // Add current state to history\n        // Always use measured angle (includes sensor offset) for realistic simulation\n        const measuredAngle = this.getMeasuredAngle();\n        this.stateHistory.addState(measuredAngle, this.state.angularVelocity);\n    }\n\n    /**\n     * Calculate reward function for reinforcement learning\n     * @private\n     * @param {RobotState} prevState - Previous state for comparison\n     * @param {number} motorTorque - Action taken (motor torque applied)\n     * @returns {number} Reward value\n     */\n    _calculateReward(prevState, motorTorque) {\n        if (this.rewardType === 'simple') {\n            // CARTPOLE-STYLE REWARD: Binary reward\n            // Robot is upright = +1, Robot falls = 0\n            if (this.state.hasFailed(this.maxAngle)) {\n                return 0.0; // No reward for falling\n            }\n            return 1.0; // Reward for staying upright\n        } else if (this.rewardType === 'complex') {\n            // COMPLEX REWARD: Angle-proportional reward with failure penalty\n            if (this.state.hasFailed(this.maxAngle)) {\n                return -10.0; // Penalty for falling in complex mode\n            }\n            \n            const angleError = Math.abs(this.state.angle);\n            \n            // Proportional reward: 1.0 when upright, 0.0 when at failure angle\n            const uprightReward = 1.0 - (angleError / this.maxAngle);\n            \n            return uprightReward;\n        } else if (this.rewardType === 'efficient') {\n            // ENERGY EFFICIENT REWARD: Proportional + energy penalty\n            if (this.state.hasFailed(this.maxAngle)) {\n                return -10.0; // Penalty for falling\n            }\n            \n            const angleError = Math.abs(this.state.angle);\n            \n            // Base proportional reward: 1.0 when upright, 0.0 when at failure angle\n            const uprightReward = 1.0 - (angleError / this.maxAngle);\n            \n            // Energy efficiency penalties\n            const maxTorque = this.motorStrength;\n            \n            // Safety check for division by zero\n            if (maxTorque <= 0) {\n                console.warn('Invalid motor strength for energy efficient reward, falling back to proportional');\n                return uprightReward;\n            }\n            \n            // 1. Torque magnitude penalty (encourage minimal torque usage)\n            const torqueMagnitude = Math.abs(this.currentMotorTorque);\n            const torquePenalty = 0.1 * (torqueMagnitude / maxTorque); // 0.1 weight for torque penalty\n            \n            // 2. Torque change penalty (discourage chattering/rapid changes)\n            const torqueChange = Math.abs(this.currentMotorTorque - this.previousMotorTorque);\n            const chatterPenalty = 0.05 * (torqueChange / maxTorque); // 0.05 weight for chatter penalty\n            \n            // 3. Smoothness bonus for small torque changes (encourage stability)\n            const smoothnessBonus = torqueChange < (0.1 * maxTorque) ? 0.02 : 0.0; // Small bonus for smooth control\n            \n            // Combine rewards: upright reward - energy penalties + smoothness bonus\n            const totalReward = uprightReward - torquePenalty - chatterPenalty + smoothnessBonus;\n            \n            // Safety checks for numerical stability\n            if (!isFinite(totalReward)) {\n                console.warn('Non-finite reward calculated, falling back to proportional');\n                return uprightReward;\n            }\n            \n            // Ensure reward doesn't go below a reasonable minimum\n            return Math.max(totalReward, -1.0);\n        } else if (this.rewardType === 'offset-adaptive') {\n            // OFFSET-ADAPTIVE REWARD: Simplified approach that rewards balancing regardless of sensor offset\n            if (this.state.hasFailed(this.maxAngle)) {\n                return -10.0; // Penalty for falling\n            }\n            \n            // Use TRUE angle (without offset) for reward calculation\n            // This allows the robot to learn to balance despite sensor offset\n            const trueAngleError = Math.abs(this.state.angle);\n            \n            // Base reward: proportional to how close to true upright the robot is\n            const uprightReward = 1.0 - (trueAngleError / this.maxAngle);\n            \n            // Stability bonus: reward for low angular velocity (smooth control)\n            const angularVelMagnitude = Math.abs(this.state.angularVelocity);\n            const maxStableVel = 3.0; // rad/s - threshold for \"stable\"\n            const stabilityBonus = Math.max(0, 0.2 * (1.0 - angularVelMagnitude / maxStableVel));\n            \n            // Small bonus for staying balanced for longer (encourages persistence)\n            const persistenceBonus = 0.1;\n            \n            const totalReward = uprightReward + stabilityBonus + persistenceBonus;\n            \n            return Math.max(totalReward, -1.0);\n        } else {\n            // DEFAULT: Fall back to simple reward\n            console.warn(`Unknown reward type: ${this.rewardType}, falling back to simple reward`);\n            if (this.state.hasFailed(this.maxAngle)) {\n                return 0.0;\n            }\n            return 1.0;\n        }\n    }\n\n    /**\n     * Update angle offset simulation over time\n     * @private\n     */\n    _updateAngleOffset(dt) {\n        // Slowly drift the angle offset to simulate sensor drift or weight changes\n        const driftAmount = (Math.random() - 0.5) * this.offsetChangeRate * dt;\n        this.angleOffset += driftAmount;\n        \n        // Add small random variation to simulate measurement noise\n        const noise = (Math.random() - 0.5) * this.offsetVariation;\n        this.angleOffset += noise * dt;\n        \n        // Clamp offset within reasonable bounds\n        this.angleOffset = Math.max(-Math.PI/6, Math.min(Math.PI/6, this.angleOffset));\n    }\n    \n    /**\n     * Get measured angle (true angle + offset)\n     */\n    getMeasuredAngle() {\n        return this.state.angle + this.angleOffset;\n    }\n    \n    /**\n     * Set training offset range for offset-adaptive learning\n     * @param {number} rangeDegrees - Maximum offset range in degrees (0-15)\n     */\n    setTrainingOffsetRange(rangeDegrees) {\n        this.trainingOffsetRange = Math.max(0, Math.min(15, rangeDegrees)) * Math.PI / 180; // Convert to radians and clamp\n        console.log(`Training offset range set to: ±${rangeDegrees.toFixed(1)}°`);\n    }\n    \n    /**\n     * Update balance point estimate based on recent performance\n     * @private\n     */\n    _updateBalancePointEstimate(measuredAngle) {\n        // Only update if the robot is relatively stable (low angular velocity)\n        const isStable = Math.abs(this.state.angularVelocity) < 1.0;\n        \n        if (isStable) {\n            // Moving average towards the current measured angle when stable\n            const alpha = this.adaptationRate;\n            this.balancePointEstimate = (1 - alpha) * this.balancePointEstimate + alpha * measuredAngle;\n            \n            // Increase confidence gradually when stable\n            this.balancePointConfidence = Math.min(1.0, this.balancePointConfidence + 0.001);\n        } else {\n            // Decrease confidence when unstable\n            this.balancePointConfidence = Math.max(0.0, this.balancePointConfidence - 0.002);\n        }\n        \n        // Ensure estimate stays within reasonable bounds\n        this.balancePointEstimate = Math.max(-this.maxAngle/2, \n                                           Math.min(this.maxAngle/2, this.balancePointEstimate));\n    }\n\n    /**\n     * Normalize angle to [-π, π] range\n     * @private\n     */\n    _normalizeAngle(angle) {\n        while (angle > Math.PI) angle -= 2 * Math.PI;\n        while (angle < -Math.PI) angle += 2 * Math.PI;\n        return angle;\n    }\n\n    /**\n     * Get current robot state\n     * @returns {RobotState} Current state\n     */\n    getState() {\n        return this.state.clone();\n    }\n\n    /**\n     * Get normalized inputs for neural network\n     * @returns {Float32Array} Normalized state inputs\n     */\n    getNormalizedInputs() {\n        // Use state history for multi-timestep inputs\n        if (this.historyTimesteps > 1) {\n            return this.stateHistory.getNormalizedInputs(this.maxAngle);\n        }\n        \n        // Single timestep behavior (backward compatibility)\n        // Always use measured angle (with offset) for realistic sensor simulation\n        const measuredAngle = this.getMeasuredAngle();\n        const normalizedAngle = Math.max(-1, Math.min(1, measuredAngle / this.maxAngle));\n        const normalizedAngularVelocity = Math.max(-1, Math.min(1, this.state.angularVelocity / 10));\n        return new Float32Array([normalizedAngle, normalizedAngularVelocity]);\n    }\n    \n    /**\n     * Set the number of history timesteps to use\n     * @param {number} timesteps - Number of timesteps (1-8)\n     */\n    setHistoryTimesteps(timesteps) {\n        this.historyTimesteps = Math.max(1, Math.min(8, timesteps));\n        this.stateHistory.setTimesteps(this.historyTimesteps);\n    }\n\n    /**\n     * Get robot configuration parameters\n     * @returns {Object} Configuration object\n     */\n    getConfig() {\n        return {\n            mass: this.mass,\n            centerOfMassHeight: this.centerOfMassHeight,\n            motorStrength: this.motorStrength,\n            friction: this.friction,\n            damping: this.damping,\n            timestep: this.timestep,\n            wheelRadius: this.wheelRadius,\n            wheelMass: this.wheelMass,\n            wheelFriction: this.wheelFriction,\n            rewardType: this.rewardType,\n            maxAngle: this.maxAngle,\n            motorTorqueRange: this.motorTorqueRange\n        };\n    }\n\n    /**\n     * Update robot configuration parameters\n     * @param {Object} config - New configuration parameters\n     */\n    updateConfig(config) {\n        if (config.mass !== undefined) {\n            this.mass = this._validateParameter(config.mass, this.mass, 0.5, 3.0, 'mass');\n            // Recalculate moment of inertia when mass or height changes\n            this.momentOfInertia = this.mass * this.centerOfMassHeight * this.centerOfMassHeight;\n        }\n        if (config.centerOfMassHeight !== undefined) {\n            this.centerOfMassHeight = this._validateParameter(config.centerOfMassHeight, this.centerOfMassHeight, 0.2, 1.0, 'centerOfMassHeight');\n            // Recalculate moment of inertia when mass or height changes\n            this.momentOfInertia = this.mass * this.centerOfMassHeight * this.centerOfMassHeight;\n        }\n        if (config.motorStrength !== undefined) {\n            this.motorStrength = this._validateParameter(config.motorStrength, this.motorStrength, 2.0, 20.0, 'motorStrength');\n        }\n        if (config.friction !== undefined) {\n            this.friction = this._validateParameter(config.friction, this.friction, 0.0, 1.0, 'friction');\n        }\n        if (config.damping !== undefined) {\n            this.damping = this._validateParameter(config.damping, this.damping, 0.0, 1.0, 'damping');\n        }\n        if (config.timestep !== undefined) {\n            this.timestep = this._validateParameter(config.timestep, this.timestep, 0.001, 0.1, 'timestep');\n        }\n        if (config.wheelRadius !== undefined) {\n            this.wheelRadius = this._validateParameter(config.wheelRadius, this.wheelRadius, 0.02, 0.20, 'wheelRadius');\n            this.wheelInertia = 0.5 * this.wheelMass * this.wheelRadius * this.wheelRadius;\n        }\n        if (config.wheelMass !== undefined) {\n            this.wheelMass = this._validateParameter(config.wheelMass, this.wheelMass, 0.1, 1.0, 'wheelMass');\n            this.wheelInertia = 0.5 * this.wheelMass * this.wheelRadius * this.wheelRadius;\n        }\n        if (config.wheelFriction !== undefined) {\n            this.wheelFriction = this._validateParameter(config.wheelFriction, this.wheelFriction, 0.0, 1.0, 'wheelFriction');\n        }\n        if (config.maxAngle !== undefined) {\n            this.maxAngle = this._validateParameter(config.maxAngle, this.maxAngle, Math.PI / 180, Math.PI / 3, 'maxAngle');\n        }\n        if (config.motorTorqueRange !== undefined) {\n            this.motorTorqueRange = this._validateParameter(config.motorTorqueRange, this.motorTorqueRange, 0.5, 10.0, 'motorTorqueRange');\n        }\n        \n        console.log('Robot configuration updated:', this.getConfig());\n    }\n\n    /**\n     * Get simulation statistics\n     * @returns {Object} Statistics object\n     */\n    getStats() {\n        const stats = {\n            stepCount: this.stepCount,\n            totalReward: this.totalReward,\n            currentMotorTorque: this.currentMotorTorque,\n            simulationTime: this.stepCount * this.timestep\n        };\n        \n        // Add offset-adaptive specific stats\n        if (this.rewardType === 'offset-adaptive') {\n            stats.angleOffset = this.angleOffset;\n            stats.balancePointEstimate = this.balancePointEstimate;\n            stats.balancePointConfidence = this.balancePointConfidence;\n            stats.measuredAngle = this.getMeasuredAngle();\n            stats.trueAngle = this.state.angle;\n        }\n        \n        return stats;\n    }\n\n    /**\n     * Set reward function type\n     * @param {string} type - 'simple' (CartPole-style), 'complex' (angle-proportional), 'efficient' (energy-aware), or 'offset-adaptive' (learns balance point)\n     */\n    setRewardType(type) {\n        if (type === 'simple' || type === 'complex' || type === 'efficient' || type === 'offset-adaptive') {\n            this.rewardType = type;\n            console.log(`Reward function changed to: ${type}`);\n        } else {\n            console.warn(`Invalid reward type: ${type}. Use 'simple', 'complex', 'efficient', or 'offset-adaptive'`);\n        }\n    }\n    \n    /**\n     * Get current reward type\n     * @returns {string} Current reward type ('simple', 'complex', 'efficient', or 'offset-adaptive')\n     */\n    getRewardType() {\n        return this.rewardType;\n    }\n    \n    /**\n     * Check if simulation is stable (no NaN or infinite values)\n     * @returns {boolean} True if simulation is stable\n     */\n    isStable() {\n        return (\n            isFinite(this.state.angle) &&\n            isFinite(this.state.angularVelocity) &&\n            isFinite(this.state.position) &&\n            isFinite(this.state.velocity) &&\n            isFinite(this.currentMotorTorque)\n        );\n    }\n}\n\n/**\n * Utility function to create a robot with default parameters\n * @param {Object} overrides - Parameter overrides\n * @returns {BalancingRobot} New robot instance\n */\nexport function createDefaultRobot(overrides = {}) {\n    return new BalancingRobot(overrides);\n}\n\n/**\n * Utility function to create a lightweight robot for fast training\n * @returns {BalancingRobot} Robot configured for training speed\n */\nexport function createTrainingRobot() {\n    return new BalancingRobot({\n        mass: 1.0,\n        centerOfMassHeight: 0.3,\n        motorStrength: 3.0,\n        friction: 0.02,\n        damping: 0.01,\n        timestep: 0.02\n    });\n}\n\n/**\n * Utility function to create a realistic robot for demonstration\n * @returns {BalancingRobot} Robot configured for realism\n */\nexport function createRealisticRobot() {\n    return new BalancingRobot({\n        mass: 1.5,\n        centerOfMassHeight: 0.4,\n        motorStrength: 4.0,\n        friction: 0.1,\n        damping: 0.05,\n        timestep: 0.02\n    });\n}","/**\n * Neural Network Interface for Two-Wheel Balancing Robot RL\n * \n * This interface defines the standard API for neural network implementations\n * supporting both CPU and WebGPU backends for the balancing robot application.\n * \n * Architecture:\n * - Input: Robot state (angle, angular velocity) - 2 values\n * - Hidden: 4-16 neurons with ReLU activation (configurable)\n * - Output: Action probabilities (left motor, right motor, brake) - 3 values\n * - Total parameters: <200 for embedded deployment\n */\n\n/**\n * Abstract base class for neural network implementations\n */\nexport class NeuralNetwork {\n    constructor() {\n        if (this.constructor === NeuralNetwork) {\n            throw new Error('NeuralNetwork is an abstract class and cannot be instantiated directly');\n        }\n    }\n\n    /**\n     * Create a neural network with specified architecture\n     * @param {number} inputSize - Number of input neurons (2 for robot state)\n     * @param {number} hiddenSize - Number of hidden neurons (4-16)\n     * @param {number} outputSize - Number of output neurons (3 for actions)\n     * @param {Object} options - Additional configuration options\n     * @returns {Promise<void>} Promise that resolves when network is created\n     */\n    async createNetwork(inputSize, hiddenSize, outputSize, options = {}) {\n        throw new Error('createNetwork method must be implemented by subclass');\n    }\n\n    /**\n     * Perform forward pass through the network\n     * @param {Float32Array} input - Input values (angle, angular velocity)\n     * @returns {Promise<Float32Array>|Float32Array} Output probabilities for actions\n     */\n    forward(input) {\n        throw new Error('forward method must be implemented by subclass');\n    }\n\n    /**\n     * Get the total number of parameters in the network\n     * @returns {number} Total parameter count\n     */\n    getParameterCount() {\n        throw new Error('getParameterCount method must be implemented by subclass');\n    }\n\n    /**\n     * Get network weights for serialization/export\n     * @returns {Object} Object containing weights and biases\n     */\n    getWeights() {\n        throw new Error('getWeights method must be implemented by subclass');\n    }\n\n    /**\n     * Set network weights from serialized data\n     * @param {Object} weights - Object containing weights and biases\n     */\n    setWeights(weights) {\n        throw new Error('setWeights method must be implemented by subclass');\n    }\n\n    /**\n     * Get network architecture information\n     * @returns {Object} Architecture details\n     */\n    getArchitecture() {\n        throw new Error('getArchitecture method must be implemented by subclass');\n    }\n\n    /**\n     * Validate input dimensions\n     * @param {Float32Array} input - Input to validate\n     * @throws {Error} If input dimensions are invalid\n     */\n    validateInput(input) {\n        if (!(input instanceof Float32Array)) {\n            throw new Error('Input must be a Float32Array');\n        }\n        if (input.length !== this.inputSize) {\n            throw new Error(`Input size mismatch. Expected ${this.inputSize}, got ${input.length}`);\n        }\n        \n        // Check for NaN and infinite values in input\n        for (let i = 0; i < input.length; i++) {\n            if (!isFinite(input[i])) {\n                console.warn(`Invalid input value at index ${i}: ${input[i]}, clamping to valid range`);\n                input[i] = Math.max(-1, Math.min(1, isNaN(input[i]) ? 0 : input[i]));\n            }\n        }\n    }\n\n    /**\n     * Validate output dimensions\n     * @param {Float32Array} output - Output to validate\n     * @throws {Error} If output dimensions are invalid\n     */\n    validateOutput(output) {\n        if (!(output instanceof Float32Array)) {\n            throw new Error('Output must be a Float32Array');\n        }\n        if (output.length !== this.outputSize) {\n            throw new Error(`Output size mismatch. Expected ${this.outputSize}, got ${output.length}`);\n        }\n        \n        // Check for NaN and infinite values\n        for (let i = 0; i < output.length; i++) {\n            if (!isFinite(output[i])) {\n                console.warn(`Invalid output value at index ${i}: ${output[i]}, replacing with 0`);\n                output[i] = 0;\n            }\n        }\n    }\n}\n\n/**\n * Network configuration constants\n */\nexport const NetworkConfig = {\n    // Architecture constraints\n    INPUT_SIZE: 2,          // Base robot state: angle, angular velocity (can be 2-16 for multi-timestep)\n    OUTPUT_SIZE: 3,         // Actions: left motor, right motor, brake\n    MIN_HIDDEN_SIZE: 4,     // Minimum hidden layer size\n    MAX_HIDDEN_SIZE: 256,   // Maximum hidden layer size (updated for DQN standards)\n    MAX_PARAMETERS: 50000,  // Maximum total parameters (updated for DQN web training)\n    \n    // Activation functions\n    ACTIVATION: {\n        RELU: 'relu',\n        LINEAR: 'linear'\n    },\n    \n    // Weight initialization methods\n    INITIALIZATION: {\n        XAVIER: 'xavier',\n        HE: 'he',\n        RANDOM: 'random'\n    }\n};\n\n/**\n * Utility function to calculate parameter count for given architecture\n * @param {number} inputSize - Number of input neurons\n * @param {number} hiddenSize - Number of hidden neurons\n * @param {number} outputSize - Number of output neurons\n * @returns {number} Total parameter count\n */\nexport function calculateParameterCount(inputSize, hiddenSize, outputSize) {\n    // Input to hidden: weights + biases\n    const inputToHidden = (inputSize * hiddenSize) + hiddenSize;\n    \n    // Hidden to output: weights + biases\n    const hiddenToOutput = (hiddenSize * outputSize) + outputSize;\n    \n    return inputToHidden + hiddenToOutput;\n}\n\n/**\n * Validate network architecture constraints (legacy - fixed input size)\n * @param {number} inputSize - Number of input neurons\n * @param {number} hiddenSize - Number of hidden neurons\n * @param {number} outputSize - Number of output neurons\n * @throws {Error} If architecture is invalid\n * @deprecated Use validateVariableArchitecture for multi-timestep support\n */\nexport function validateArchitecture(inputSize, hiddenSize, outputSize) {\n    if (inputSize !== NetworkConfig.INPUT_SIZE) {\n        throw new Error(`Input size must be ${NetworkConfig.INPUT_SIZE}, got ${inputSize}`);\n    }\n    \n    if (outputSize !== NetworkConfig.OUTPUT_SIZE) {\n        throw new Error(`Output size must be ${NetworkConfig.OUTPUT_SIZE}, got ${outputSize}`);\n    }\n    \n    if (hiddenSize < NetworkConfig.MIN_HIDDEN_SIZE || hiddenSize > NetworkConfig.MAX_HIDDEN_SIZE) {\n        throw new Error(`Hidden size must be between ${NetworkConfig.MIN_HIDDEN_SIZE} and ${NetworkConfig.MAX_HIDDEN_SIZE}, got ${hiddenSize}`);\n    }\n    \n    const paramCount = calculateParameterCount(inputSize, hiddenSize, outputSize);\n    if (paramCount > NetworkConfig.MAX_PARAMETERS) {\n        throw new Error(`Parameter count ${paramCount} exceeds maximum ${NetworkConfig.MAX_PARAMETERS}`);\n    }\n}","/**\n * Matrix Utilities for Neural Network Computations\n * \n * Efficient matrix operations using Float32Array for optimal performance\n * in both CPU and preparation for WebGPU implementations.\n */\n\n/**\n * Perform matrix multiplication: C = A * B + bias\n * @param {Float32Array} A - Input matrix (flattened, row-major)\n * @param {Float32Array} B - Weight matrix (flattened, row-major)\n * @param {Float32Array} bias - Bias vector\n * @param {number} aRows - Number of rows in A\n * @param {number} aCols - Number of columns in A (must equal bRows)\n * @param {number} bCols - Number of columns in B\n * @returns {Float32Array} Result matrix C\n */\nexport function matrixMultiply(A, B, bias, aRows, aCols, bCols) {\n    if (A.length !== aRows * aCols) {\n        throw new Error(`Matrix A size mismatch. Expected ${aRows * aCols}, got ${A.length}`);\n    }\n    if (B.length !== aCols * bCols) {\n        throw new Error(`Matrix B size mismatch. Expected ${aCols * bCols}, got ${B.length}`);\n    }\n    if (bias && bias.length !== bCols) {\n        throw new Error(`Bias size mismatch. Expected ${bCols}, got ${bias.length}`);\n    }\n    \n    const result = new Float32Array(aRows * bCols);\n    \n    // Optimized matrix multiplication with optional bias\n    for (let i = 0; i < aRows; i++) {\n        for (let j = 0; j < bCols; j++) {\n            let sum = 0;\n            for (let k = 0; k < aCols; k++) {\n                sum += A[i * aCols + k] * B[k * bCols + j];\n            }\n            // Add bias if provided\n            if (bias) {\n                sum += bias[j];\n            }\n            result[i * bCols + j] = sum;\n        }\n    }\n    \n    return result;\n}\n\n/**\n * Perform vector-matrix multiplication for single input: y = x * W + b\n * Optimized version for single sample forward pass\n * @param {Float32Array} input - Input vector\n * @param {Float32Array} weights - Weight matrix (flattened, row-major)\n * @param {Float32Array} bias - Bias vector\n * @param {number} inputSize - Size of input vector\n * @param {number} outputSize - Size of output vector\n * @returns {Float32Array} Result vector\n */\nexport function vectorMatrixMultiply(input, weights, bias, inputSize, outputSize) {\n    if (input.length !== inputSize) {\n        throw new Error(`Input size mismatch. Expected ${inputSize}, got ${input.length}`);\n    }\n    if (weights.length !== inputSize * outputSize) {\n        throw new Error(`Weight matrix size mismatch. Expected ${inputSize * outputSize}, got ${weights.length}`);\n    }\n    if (bias.length !== outputSize) {\n        throw new Error(`Bias size mismatch. Expected ${outputSize}, got ${bias.length}`);\n    }\n    \n    const result = new Float32Array(outputSize);\n    \n    // Optimized vector-matrix multiplication\n    for (let j = 0; j < outputSize; j++) {\n        let sum = bias[j]; // Start with bias\n        for (let i = 0; i < inputSize; i++) {\n            sum += input[i] * weights[i * outputSize + j];\n        }\n        result[j] = sum;\n    }\n    \n    return result;\n}\n\n/**\n * Apply ReLU activation function element-wise\n * @param {Float32Array} input - Input array\n * @returns {Float32Array} Output array with ReLU applied\n */\nexport function relu(input) {\n    const result = new Float32Array(input.length);\n    for (let i = 0; i < input.length; i++) {\n        result[i] = Math.max(0, input[i]);\n    }\n    return result;\n}\n\n/**\n * Apply ReLU activation function in-place\n * @param {Float32Array} input - Input array to modify\n */\nexport function reluInPlace(input) {\n    for (let i = 0; i < input.length; i++) {\n        if (input[i] < 0) {\n            input[i] = 0;\n        }\n    }\n}\n\n/**\n * Copy array (useful for avoiding in-place modifications)\n * @param {Float32Array} input - Input array\n * @returns {Float32Array} Copy of input array\n */\nexport function copyArray(input) {\n    return new Float32Array(input);\n}\n\n/**\n * Initialize weights using Xavier/Glorot initialization\n * Optimal for sigmoid and tanh activations\n * @param {number} inputSize - Number of input neurons\n * @param {number} outputSize - Number of output neurons\n * @returns {Float32Array} Initialized weight matrix\n */\nexport function xavierInit(inputSize, outputSize) {\n    const limit = Math.sqrt(6.0 / (inputSize + outputSize));\n    const weights = new Float32Array(inputSize * outputSize);\n    \n    for (let i = 0; i < weights.length; i++) {\n        weights[i] = (Math.random() * 2 - 1) * limit;\n    }\n    \n    return weights;\n}\n\n/**\n * Initialize weights using He initialization\n * Optimal for ReLU activations\n * @param {number} inputSize - Number of input neurons\n * @param {number} outputSize - Number of output neurons\n * @returns {Float32Array} Initialized weight matrix\n */\nexport function heInit(inputSize, outputSize) {\n    const stddev = Math.sqrt(2.0 / inputSize);\n    const weights = new Float32Array(inputSize * outputSize);\n    \n    for (let i = 0; i < weights.length; i++) {\n        // Box-Muller transform for normal distribution\n        const u1 = Math.random();\n        const u2 = Math.random();\n        const normal = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\n        weights[i] = normal * stddev;\n    }\n    \n    return weights;\n}\n\n/**\n * Initialize bias vector with zeros\n * @param {number} size - Size of bias vector\n * @returns {Float32Array} Zero-initialized bias vector\n */\nexport function zeroInit(size) {\n    return new Float32Array(size);\n}\n\n/**\n * Initialize bias vector with small random values\n * @param {number} size - Size of bias vector\n * @param {number} scale - Scale factor for random values (default: 0.01)\n * @returns {Float32Array} Small random initialized bias vector\n */\nexport function smallRandomInit(size, scale = 0.01) {\n    const bias = new Float32Array(size);\n    for (let i = 0; i < size; i++) {\n        bias[i] = (Math.random() * 2 - 1) * scale;\n    }\n    return bias;\n}\n\n/**\n * Validate matrix dimensions for multiplication\n * @param {number} aRows - Rows in matrix A\n * @param {number} aCols - Columns in matrix A\n * @param {number} bRows - Rows in matrix B\n * @param {number} bCols - Columns in matrix B\n * @throws {Error} If dimensions are incompatible\n */\nexport function validateMatrixDimensions(aRows, aCols, bRows, bCols) {\n    if (aCols !== bRows) {\n        throw new Error(`Matrix dimensions incompatible for multiplication: (${aRows}x${aCols}) * (${bRows}x${bCols})`);\n    }\n}\n\n/**\n * Performance utilities for benchmarking\n */\nexport const Performance = {\n    /**\n     * Time a function execution\n     * @param {Function} fn - Function to time\n     * @param {...any} args - Arguments to pass to function\n     * @returns {Object} Result and execution time\n     */\n    time(fn, ...args) {\n        const start = performance.now();\n        const result = fn(...args);\n        const end = performance.now();\n        return {\n            result,\n            time: end - start\n        };\n    },\n    \n    /**\n     * Run multiple iterations and return average time\n     * @param {Function} fn - Function to benchmark\n     * @param {number} iterations - Number of iterations\n     * @param {...any} args - Arguments to pass to function\n     * @returns {Object} Average time and total iterations\n     */\n    benchmark(fn, iterations, ...args) {\n        let totalTime = 0;\n        let lastResult = null;\n        \n        for (let i = 0; i < iterations; i++) {\n            const start = performance.now();\n            lastResult = fn(...args);\n            const end = performance.now();\n            totalTime += (end - start);\n        }\n        \n        return {\n            averageTime: totalTime / iterations,\n            totalTime,\n            iterations,\n            lastResult\n        };\n    }\n};","/**\n * CPU Backend for Neural Network Implementation\n * \n * Efficient CPU-based neural network for two-wheel balancing robot RL.\n * Optimized for performance with Float32Array operations and designed\n * for embedded deployment constraints (<200 parameters).\n */\n\nimport { NeuralNetwork, NetworkConfig, validateArchitecture, calculateParameterCount } from './NeuralNetwork.js';\nimport { \n    vectorMatrixMultiply, \n    relu, \n    copyArray, \n    heInit, \n    xavierInit, \n    zeroInit,\n    Performance \n} from './MatrixUtils.js';\n\n/**\n * CPU-based neural network implementation\n * Architecture: Input(2-16) -> Hidden(4-256, ReLU) -> Output(3, Linear)\n * Supports variable input sizes for multi-timestep learning\n */\nexport class CPUBackend extends NeuralNetwork {\n    constructor() {\n        super();\n        \n        // Network architecture\n        this.inputSize = 0;\n        this.hiddenSize = 0;\n        this.outputSize = 0;\n        this.parameterCount = 0;\n        \n        // Network weights and biases\n        this.weightsInputHidden = null;  // Input to hidden layer weights\n        this.biasHidden = null;          // Hidden layer biases\n        this.weightsHiddenOutput = null; // Hidden to output layer weights\n        this.biasOutput = null;          // Output layer biases\n        \n        // Temporary arrays for forward pass (reused for efficiency)\n        this.hiddenActivation = null;\n        this.outputActivation = null;\n        \n        // Configuration\n        this.initMethod = NetworkConfig.INITIALIZATION.HE; // Default for ReLU\n        this.isInitialized = false;\n    }\n\n    /**\n     * Create and initialize the neural network\n     * @param {number} inputSize - Number of input neurons (2-16 for multi-timestep support)\n     * @param {number} hiddenSize - Number of hidden neurons (4-256)\n     * @param {number} outputSize - Number of output neurons (must be 3)\n     * @param {Object} options - Configuration options\n     * @param {string} options.initMethod - Weight initialization method ('he', 'xavier', 'random')\n     * @param {number} options.seed - Random seed for reproducible initialization\n     * @returns {Promise<void>} Promise that resolves when network is created\n     */\n    async createNetwork(inputSize, hiddenSize, outputSize, options = {}) {\n        // Validate basic constraints (but allow variable input size)\n        this._validateVariableArchitecture(inputSize, hiddenSize, outputSize);\n        \n        // Set architecture\n        this.inputSize = inputSize;\n        this.hiddenSize = hiddenSize;\n        this.outputSize = outputSize;\n        this.parameterCount = calculateParameterCount(inputSize, hiddenSize, outputSize);\n        \n        // Set initialization method\n        this.initMethod = options.initMethod || NetworkConfig.INITIALIZATION.HE;\n        \n        // Initialize weights and biases\n        this._initializeWeights();\n        \n        // Allocate temporary arrays for forward pass\n        this.hiddenActivation = new Float32Array(hiddenSize);\n        this.outputActivation = new Float32Array(outputSize);\n        \n        this.isInitialized = true;\n        \n        console.log(`CPU Neural Network created: ${inputSize}-${hiddenSize}-${outputSize} (${this.parameterCount} parameters)`);\n    }\n\n    /**\n     * Perform forward pass through the network\n     * @param {Float32Array} input - Input values (multi-timestep robot state)\n     * @returns {Float32Array} Output probabilities for actions\n     */\n    forward(input) {\n        if (!this.isInitialized) {\n            throw new Error('Network not initialized. Call createNetwork() first.');\n        }\n        \n        // Validate input\n        this.validateInput(input);\n        \n        // Forward pass: Input -> Hidden (with ReLU)\n        const hiddenLinear = vectorMatrixMultiply(\n            input, \n            this.weightsInputHidden, \n            this.biasHidden,\n            this.inputSize, \n            this.hiddenSize\n        );\n        \n        // Apply ReLU activation to hidden layer\n        for (let i = 0; i < this.hiddenSize; i++) {\n            this.hiddenActivation[i] = Math.max(0, hiddenLinear[i]);\n        }\n        \n        // Forward pass: Hidden -> Output (linear)\n        const output = vectorMatrixMultiply(\n            this.hiddenActivation,\n            this.weightsHiddenOutput,\n            this.biasOutput,\n            this.hiddenSize,\n            this.outputSize\n        );\n        \n        // Validate and return output with Q-value clamping\n        this.validateOutput(output);\n        \n        // Clamp Q-values to prevent explosive growth\n        for (let i = 0; i < output.length; i++) {\n            output[i] = Math.max(-100.0, Math.min(100.0, output[i]));\n        }\n        \n        return output;\n    }\n\n    /**\n     * Get the most recent hidden layer activations from forward pass\n     * @returns {Float32Array} Hidden layer activations\n     */\n    getHiddenActivations() {\n        if (!this.isInitialized) {\n            throw new Error('Network not initialized');\n        }\n        if (!this.hiddenActivation) {\n            throw new Error('No forward pass performed yet');\n        }\n        return this.hiddenActivation.slice();\n    }\n\n    /**\n     * Get the total number of parameters in the network\n     * @returns {number} Total parameter count\n     */\n    getParameterCount() {\n        return this.parameterCount;\n    }\n\n    /**\n     * Get network weights for serialization/export\n     * @returns {Object} Object containing weights and biases\n     */\n    getWeights() {\n        if (!this.isInitialized) {\n            throw new Error('Network not initialized');\n        }\n        \n        return {\n            architecture: {\n                inputSize: this.inputSize,\n                hiddenSize: this.hiddenSize,\n                outputSize: this.outputSize,\n                parameterCount: this.parameterCount\n            },\n            weightsInputHidden: Array.from(this.weightsInputHidden),\n            biasHidden: Array.from(this.biasHidden),\n            weightsHiddenOutput: Array.from(this.weightsHiddenOutput),\n            biasOutput: Array.from(this.biasOutput),\n            initMethod: this.initMethod\n        };\n    }\n\n    /**\n     * Set network weights from serialized data\n     * @param {Object} weights - Object containing weights and biases\n     */\n    setWeights(weights) {\n        if (!weights.architecture) {\n            throw new Error('Invalid weights object: missing architecture');\n        }\n        \n        const arch = weights.architecture;\n        \n        // Validate architecture compatibility\n        if (!this.isInitialized) {\n            // Initialize with the architecture from weights\n            this.inputSize = arch.inputSize;\n            this.hiddenSize = arch.hiddenSize;\n            this.outputSize = arch.outputSize;\n            this.parameterCount = arch.parameterCount;\n            \n            this.hiddenActivation = new Float32Array(this.hiddenSize);\n            this.outputActivation = new Float32Array(this.outputSize);\n            this.isInitialized = true;\n        } else {\n            // Verify compatibility\n            if (arch.inputSize !== this.inputSize || \n                arch.hiddenSize !== this.hiddenSize || \n                arch.outputSize !== this.outputSize) {\n                throw new Error('Weight architecture incompatible with current network');\n            }\n        }\n        \n        // Set weights and biases\n        this.weightsInputHidden = new Float32Array(weights.weightsInputHidden);\n        this.biasHidden = new Float32Array(weights.biasHidden);\n        this.weightsHiddenOutput = new Float32Array(weights.weightsHiddenOutput);\n        this.biasOutput = new Float32Array(weights.biasOutput);\n        this.initMethod = weights.initMethod || this.initMethod;\n    }\n\n    /**\n     * Get network architecture information\n     * @returns {Object} Architecture details\n     */\n    getArchitecture() {\n        return {\n            inputSize: this.inputSize,\n            hiddenSize: this.hiddenSize,\n            outputSize: this.outputSize,\n            parameterCount: this.parameterCount,\n            activations: {\n                hidden: 'relu',\n                output: 'linear'\n            },\n            initMethod: this.initMethod,\n            backend: 'cpu',\n            isInitialized: this.isInitialized\n        };\n    }\n\n    /**\n     * Benchmark forward pass performance\n     * @param {number} iterations - Number of iterations to benchmark\n     * @returns {Object} Performance statistics\n     */\n    benchmark(iterations = 1000) {\n        if (!this.isInitialized) {\n            throw new Error('Network not initialized');\n        }\n        \n        // Create test input matching current network input size\n        const testInput = new Float32Array(this.inputSize);\n        // Fill with sample robot state values, repeating the pattern for all timesteps\n        for (let i = 0; i < this.inputSize; i += 2) {\n            testInput[i] = 0.1;      // Sample angle\n            testInput[i + 1] = -0.05; // Sample angular velocity\n        }\n        \n        return Performance.benchmark(\n            (input) => this.forward(input),\n            iterations,\n            testInput\n        );\n    }\n\n    /**\n     * Initialize network weights and biases\n     * @private\n     */\n    _initializeWeights() {\n        switch (this.initMethod) {\n            case NetworkConfig.INITIALIZATION.HE:\n                // He initialization - optimal for ReLU\n                this.weightsInputHidden = heInit(this.inputSize, this.hiddenSize);\n                this.weightsHiddenOutput = heInit(this.hiddenSize, this.outputSize);\n                break;\n                \n            case NetworkConfig.INITIALIZATION.XAVIER:\n                // Xavier initialization - good for sigmoid/tanh\n                this.weightsInputHidden = xavierInit(this.inputSize, this.hiddenSize);\n                this.weightsHiddenOutput = xavierInit(this.hiddenSize, this.outputSize);\n                break;\n                \n            default:\n                throw new Error(`Unknown initialization method: ${this.initMethod}`);\n        }\n        \n        // Initialize biases\n        // Small positive bias for hidden layer to ensure some initial activation with ReLU\n        this.biasHidden = new Float32Array(this.hiddenSize);\n        for (let i = 0; i < this.hiddenSize; i++) {\n            this.biasHidden[i] = 0.01; // Small positive bias\n        }\n        \n        // Zero bias for output layer (common practice for final layer)\n        this.biasOutput = zeroInit(this.outputSize);\n    }\n\n    /**\n     * Get memory usage information\n     * @returns {Object} Memory usage statistics\n     */\n    getMemoryUsage() {\n        if (!this.isInitialized) {\n            return { totalBytes: 0, breakdown: {} };\n        }\n        \n        const bytesPerFloat = 4; // Float32Array uses 4 bytes per element\n        \n        const breakdown = {\n            weightsInputHidden: this.weightsInputHidden.length * bytesPerFloat,\n            biasHidden: this.biasHidden.length * bytesPerFloat,\n            weightsHiddenOutput: this.weightsHiddenOutput.length * bytesPerFloat,\n            biasOutput: this.biasOutput.length * bytesPerFloat,\n            hiddenActivation: this.hiddenActivation.length * bytesPerFloat,\n            outputActivation: this.outputActivation.length * bytesPerFloat\n        };\n        \n        const totalBytes = Object.values(breakdown).reduce((sum, bytes) => sum + bytes, 0);\n        \n        return {\n            totalBytes,\n            totalKB: totalBytes / 1024,\n            breakdown,\n            parameterBytes: (this.parameterCount * bytesPerFloat),\n            parameterKB: (this.parameterCount * bytesPerFloat) / 1024\n        };\n    }\n\n    /**\n     * Create a copy of the network\n     * @returns {CPUBackend} Deep copy of this network\n     */\n    clone() {\n        const clone = new CPUBackend();\n        \n        if (this.isInitialized) {\n            // Use He initialization for cloned network instead of preserving 'imported' method\n            const cloneInitMethod = (this.initMethod === 'imported') ? \n                NetworkConfig.INITIALIZATION.HE : this.initMethod;\n                \n            clone.createNetwork(this.inputSize, this.hiddenSize, this.outputSize, {\n                initMethod: cloneInitMethod\n            });\n            clone.setWeights(this.getWeights());\n        }\n        \n        return clone;\n    }\n\n    /**\n     * Reset network weights to initial random values\n     */\n    resetWeights() {\n        if (!this.isInitialized) {\n            throw new Error('Network not initialized');\n        }\n        \n        // Save original initialization method\n        const originalInitMethod = this.initMethod;\n        \n        // Use He initialization for reset if current method is not supported\n        if (this.initMethod === 'imported' || !this.initMethod || \n            (this.initMethod !== NetworkConfig.INITIALIZATION.HE && \n             this.initMethod !== NetworkConfig.INITIALIZATION.XAVIER)) {\n            this.initMethod = NetworkConfig.INITIALIZATION.HE;\n        }\n        \n        this._initializeWeights();\n        \n        // Restore original initialization method\n        this.initMethod = originalInitMethod;\n    }\n\n    /**\n     * Validate network architecture for variable input sizes\n     * @private\n     * @param {number} inputSize - Number of input neurons (2-16)\n     * @param {number} hiddenSize - Number of hidden neurons (4-256)\n     * @param {number} outputSize - Number of output neurons (must be 3)\n     */\n    _validateVariableArchitecture(inputSize, hiddenSize, outputSize) {\n        // Validate input size range (2-16 for 1-8 timesteps)\n        if (inputSize < 2 || inputSize > 16) {\n            throw new Error(`Input size must be between 2 and 16 (for 1-8 timesteps), got ${inputSize}`);\n        }\n        \n        // Input size must be even (pairs of angle/angular velocity)\n        if (inputSize % 2 !== 0) {\n            throw new Error(`Input size must be even (pairs of values), got ${inputSize}`);\n        }\n        \n        // Validate output size (must be 3 for actions)\n        if (outputSize !== NetworkConfig.OUTPUT_SIZE) {\n            throw new Error(`Output size must be ${NetworkConfig.OUTPUT_SIZE}, got ${outputSize}`);\n        }\n        \n        // Validate hidden size range\n        if (hiddenSize < NetworkConfig.MIN_HIDDEN_SIZE || hiddenSize > NetworkConfig.MAX_HIDDEN_SIZE) {\n            throw new Error(`Hidden size must be between ${NetworkConfig.MIN_HIDDEN_SIZE} and ${NetworkConfig.MAX_HIDDEN_SIZE}, got ${hiddenSize}`);\n        }\n        \n        // Check parameter count constraint\n        const paramCount = calculateParameterCount(inputSize, hiddenSize, outputSize);\n        if (paramCount > NetworkConfig.MAX_PARAMETERS) {\n            throw new Error(`Parameter count ${paramCount} exceeds maximum ${NetworkConfig.MAX_PARAMETERS}`);\n        }\n    }\n}","/**\n * Q-Learning Algorithm Implementation for Two-Wheel Balancing Robot\n * \n * Deep Q-Network (DQN) implementation for continuous state space learning.\n * Optimized for the balancing robot control task with neural network function approximation.\n * \n * Features:\n * - DQN with target network for stable training\n * - Epsilon-greedy exploration with decay\n * - Experience replay buffer\n * - Temporal difference learning\n * - Hyperparameter management and validation\n * - Training episode management\n * - Convergence detection and metrics\n */\n\nimport { CPUBackend } from '../network/CPUBackend.js';\nimport { NetworkConfig } from '../network/NeuralNetwork.js';\n\n/**\n * Hyperparameters for Q-learning algorithm\n */\nexport class Hyperparameters {\n    constructor(options = {}) {\n        // Learning parameters - Updated to match PyTorch DQN tutorial standards\n        this.learningRate = this._validateParameter(options.learningRate, 3e-4, 0.0001, 0.01, 'learningRate');\n        this.gamma = this._validateParameter(options.gamma, 0.99, 0.9, 0.999, 'gamma');\n        \n        // Exploration parameters - Linear epsilon decay like PyTorch tutorial\n        this.epsilon = this._validateParameter(options.epsilon, 0.9, 0.0, 1.0, 'epsilon');\n        this.epsilonMin = this._validateParameter(options.epsilonMin, 0.01, 0.0, 0.1, 'epsilonMin');\n        this.epsilonDecay = this._validateParameter(options.epsilonDecay, 2500, 1000, 10000, 'epsilonDecay'); // Steps for linear decay\n        \n        // Training parameters - Updated to match PyTorch standards\n        this.batchSize = this._validateParameter(options.batchSize, 128, 16, 256, 'batchSize');\n        this.targetUpdateFreq = this._validateParameter(options.targetUpdateFreq, 100, 10, 1000, 'targetUpdateFreq');\n        this.maxEpisodes = this._validateParameter(options.maxEpisodes, 1000, 10, 10000, 'maxEpisodes');\n        this.maxStepsPerEpisode = this._validateParameter(options.maxStepsPerEpisode, 8000, 50, 50000, 'maxStepsPerEpisode');\n        \n        // Convergence detection\n        this.convergenceWindow = this._validateParameter(options.convergenceWindow, 100, 10, 500, 'convergenceWindow');\n        this.convergenceThreshold = this._validateParameter(options.convergenceThreshold, 200, 50, 1000, 'convergenceThreshold');\n        \n        // Network architecture - Updated to match PyTorch DQN tutorial (128 neurons)\n        this.hiddenSize = this._validateParameter(options.hiddenSize, 128, 64, 256, 'hiddenSize');\n    }\n    \n    _validateParameter(value, defaultValue, min, max, name) {\n        if (value === undefined || value === null) {\n            return defaultValue;\n        }\n        if (typeof value !== 'number' || isNaN(value)) {\n            console.warn(`Invalid ${name}: ${value}, using default: ${defaultValue}`);\n            return defaultValue;\n        }\n        if (value < min || value > max) {\n            console.warn(`${name} out of range [${min}, ${max}]: ${value}, clamping`);\n            return Math.max(min, Math.min(max, value));\n        }\n        return value;\n    }\n    \n    clone() {\n        return new Hyperparameters({\n            learningRate: this.learningRate,\n            gamma: this.gamma,\n            epsilon: this.epsilon,\n            epsilonMin: this.epsilonMin,\n            epsilonDecay: this.epsilonDecay,\n            batchSize: this.batchSize,\n            targetUpdateFreq: this.targetUpdateFreq,\n            maxEpisodes: this.maxEpisodes,\n            maxStepsPerEpisode: this.maxStepsPerEpisode,\n            convergenceWindow: this.convergenceWindow,\n            convergenceThreshold: this.convergenceThreshold,\n            hiddenSize: this.hiddenSize\n        });\n    }\n}\n\n/**\n * Experience replay buffer for storing and sampling training experiences\n * Now supports variable-sized state arrays for multi-timestep learning\n */\nexport class ReplayBuffer {\n    constructor(maxSize = 10000) {\n        this.maxSize = maxSize;\n        this.buffer = [];\n        this.index = 0;\n    }\n    \n    /**\n     * Add experience to buffer\n     * @param {Float32Array} state - Current state (variable size)\n     * @param {number} action - Action taken\n     * @param {number} reward - Reward received\n     * @param {Float32Array} nextState - Next state (variable size)\n     * @param {boolean} done - Episode termination flag\n     */\n    add(state, action, reward, nextState, done) {\n        // Validate input sizes match\n        if (state.length !== nextState.length) {\n            throw new Error(`State size mismatch: current=${state.length}, next=${nextState.length}`);\n        }\n        \n        const experience = {\n            state: new Float32Array(state),\n            action: action,\n            reward: reward,\n            nextState: new Float32Array(nextState),\n            done: done,\n            stateSize: state.length  // Store size for debugging/validation\n        };\n        \n        if (this.buffer.length < this.maxSize) {\n            this.buffer.push(experience);\n        } else {\n            this.buffer[this.index] = experience;\n        }\n        \n        this.index = (this.index + 1) % this.maxSize;\n    }\n    \n    /**\n     * Sample random batch of experiences\n     * @param {number} batchSize - Size of batch to sample\n     * @returns {Array} Array of sampled experiences\n     */\n    sample(batchSize) {\n        if (this.buffer.length < batchSize) {\n            return this.buffer.slice();\n        }\n        \n        const sampled = [];\n        const indices = new Set();\n        \n        while (sampled.length < batchSize) {\n            const idx = Math.floor(Math.random() * this.buffer.length);\n            if (!indices.has(idx)) {\n                indices.add(idx);\n                sampled.push(this.buffer[idx]);\n            }\n        }\n        \n        return sampled;\n    }\n    \n    size() {\n        return this.buffer.length;\n    }\n    \n    clear() {\n        this.buffer = [];\n        this.index = 0;\n    }\n}\n\n/**\n * Training metrics and statistics\n */\nexport class TrainingMetrics {\n    constructor() {\n        this.reset();\n    }\n    \n    reset() {\n        this.episodeRewards = [];\n        this.episodeLengths = [];\n        this.losses = [];\n        this.epsilonHistory = [];\n        this.startTime = Date.now();\n        this.totalSteps = 0;\n        this.bestReward = -Infinity;\n        this.converged = false;\n        this.convergenceEpisode = null;\n    }\n    \n    addEpisode(reward, length, loss, epsilon) {\n        this.episodeRewards.push(reward);\n        this.episodeLengths.push(length);\n        this.losses.push(loss);\n        this.epsilonHistory.push(epsilon);\n        this.totalSteps += length;\n        \n        if (reward > this.bestReward) {\n            this.bestReward = reward;\n        }\n    }\n    \n    getAverageReward(window = 100) {\n        const start = Math.max(0, this.episodeRewards.length - window);\n        const recent = this.episodeRewards.slice(start);\n        return recent.reduce((sum, r) => sum + r, 0) / recent.length;\n    }\n    \n    getAverageLength(window = 100) {\n        const start = Math.max(0, this.episodeLengths.length - window);\n        const recent = this.episodeLengths.slice(start);\n        return recent.reduce((sum, l) => sum + l, 0) / recent.length;\n    }\n    \n    getTrainingTime() {\n        return (Date.now() - this.startTime) / 1000; // seconds\n    }\n    \n    checkConvergence(threshold, window) {\n        if (this.episodeRewards.length < window) {\n            return false;\n        }\n        \n        const avgReward = this.getAverageReward(window);\n        if (avgReward >= threshold && !this.converged) {\n            this.converged = true;\n            this.convergenceEpisode = this.episodeRewards.length;\n            return true;\n        }\n        \n        return this.converged;\n    }\n    \n    getSummary() {\n        const episodes = this.episodeRewards.length;\n        const avgReward = episodes > 0 ? this.getAverageReward() : 0;\n        const avgLength = episodes > 0 ? this.getAverageLength() : 0;\n        const avgLoss = this.losses.length > 0 ? \n            this.losses.reduce((sum, l) => sum + l, 0) / this.losses.length : 0;\n        \n        return {\n            episodes: episodes,\n            totalSteps: this.totalSteps,\n            averageReward: avgReward,\n            bestReward: this.bestReward,\n            averageLength: avgLength,\n            averageLoss: avgLoss,\n            trainingTime: this.getTrainingTime(),\n            converged: this.converged,\n            convergenceEpisode: this.convergenceEpisode,\n            currentEpsilon: this.epsilonHistory[this.epsilonHistory.length - 1] || 0\n        };\n    }\n}\n\n/**\n * Deep Q-Network implementation for balancing robot control\n */\nexport class QLearning {\n    constructor(hyperparams = {}) {\n        this.hyperparams = new Hyperparameters(hyperparams);\n        this.metrics = new TrainingMetrics();\n        this.replayBuffer = new ReplayBuffer(10000);\n        \n        // Neural networks\n        this.qNetwork = null;       // Main Q-network\n        this.targetNetwork = null;  // Target Q-network for stable training\n        \n        // Training state\n        this.isInitialized = false;\n        this.episode = 0;\n        this.stepCount = 0;\n        this.globalStepCount = 0; // Global step counter for linear epsilon decay\n        this.lastTargetUpdate = 0;\n        \n        // Training completion tracking\n        this.consecutiveMaxEpisodes = 0; // Track consecutive episodes that reach max steps\n        this.trainingCompleted = false;\n        \n        // Action space (discrete actions for continuous control)\n        this.actions = [-1.0, 0.0, 1.0]; // Left motor, brake, right motor\n        this.numActions = this.actions.length;\n        \n        console.log('Q-Learning algorithm initialized with hyperparameters:', this.hyperparams);\n    }\n    \n    /**\n     * Initialize the Q-learning networks\n     * @param {number} inputSize - Input size based on timesteps (2 * timesteps)\n     * @returns {Promise<void>}\n     */\n    async initialize(inputSize = NetworkConfig.INPUT_SIZE) {\n        try {\n            // Create main Q-network with variable input size\n            this.qNetwork = new CPUBackend();\n            await this.qNetwork.createNetwork(\n                inputSize,                   // Variable input size: 2 * timesteps\n                this.hyperparams.hiddenSize, // Hidden layer size\n                this.numActions,             // 3 actions: left, brake, right\n                { initMethod: NetworkConfig.INITIALIZATION.HE }\n            );\n            \n            // Create target network (copy of main network)\n            this.targetNetwork = this.qNetwork.clone();\n            \n            this.isInitialized = true;\n            console.log(`Q-Learning networks initialized: ${inputSize}-${this.hyperparams.hiddenSize}-${this.numActions}`);\n            console.log(`Total parameters: ${this.qNetwork.getParameterCount()}`);\n            \n        } catch (error) {\n            console.error('Failed to initialize Q-Learning networks:', error);\n            throw error;\n        }\n    }\n    \n    /**\n     * Select action using epsilon-greedy policy\n     * @param {Float32Array} state - Current state (normalized)\n     * @param {boolean} training - Whether in training mode (affects exploration)\n     * @returns {number} Selected action index\n     */\n    selectAction(state, training = true) {\n        if (!this.isInitialized) {\n            throw new Error('Q-Learning not initialized. Call initialize() first.');\n        }\n        \n        // Validate state input (now supports variable input sizes)\n        if (!(state instanceof Float32Array)) {\n            throw new Error(`Invalid state input. Expected Float32Array`);\n        }\n        \n        // Check input size matches network architecture\n        const expectedInputSize = this.qNetwork.getArchitecture().inputSize;\n        if (state.length !== expectedInputSize) {\n            throw new Error(`Invalid state input size. Expected ${expectedInputSize}, got ${state.length}`);\n        }\n        \n        // Epsilon-greedy exploration\n        if (training && Math.random() < this.hyperparams.epsilon) {\n            // Random action (exploration)\n            return Math.floor(Math.random() * this.numActions);\n        } else {\n            // Greedy action (exploitation)\n            const qValues = this.qNetwork.forward(state);\n            return this._argmax(qValues);\n        }\n    }\n    \n    /**\n     * Train the Q-network on a single experience\n     * @param {Float32Array} state - Current state\n     * @param {number} action - Action taken\n     * @param {number} reward - Reward received\n     * @param {Float32Array} nextState - Next state\n     * @param {boolean} done - Episode termination flag\n     * @returns {number} Training loss\n     */\n    train(state, action, reward, nextState, done) {\n        if (!this.isInitialized) {\n            throw new Error('Q-Learning not initialized. Call initialize() first.');\n        }\n        \n        // Increment global step counter for linear epsilon decay\n        this.globalStepCount++;\n        \n        // Update epsilon using linear decay (PyTorch style)\n        this._updateEpsilon();\n        \n        // Add experience to replay buffer\n        this.replayBuffer.add(state, action, reward, nextState, done);\n        \n        // Train on batch if buffer has enough experiences\n        if (this.replayBuffer.size() >= this.hyperparams.batchSize) {\n            return this._trainBatch();\n        }\n        \n        return 0; // No training performed\n    }\n    \n    /**\n     * Update epsilon using linear decay schedule (PyTorch DQN style)\n     * @private\n     */\n    _updateEpsilon() {\n        if (this.globalStepCount < this.hyperparams.epsilonDecay) {\n            // Linear interpolation from initial epsilon to epsilon min\n            // Use the initial epsilon value that was set when training started\n            if (!this.initialEpsilon) {\n                this.initialEpsilon = this.hyperparams.epsilon; // Store initial epsilon on first call\n            }\n            const epsilonStart = this.initialEpsilon;\n            const epsilonEnd = this.hyperparams.epsilonMin;\n            const fraction = this.globalStepCount / this.hyperparams.epsilonDecay;\n            this.hyperparams.epsilon = epsilonStart + fraction * (epsilonEnd - epsilonStart);\n        } else {\n            // Keep at minimum after decay period\n            this.hyperparams.epsilon = this.hyperparams.epsilonMin;\n        }\n    }\n    \n    /**\n     * Train on a batch of experiences from replay buffer\n     * @private\n     * @returns {number} Average training loss\n     */\n    _trainBatch() {\n        const batch = this.replayBuffer.sample(this.hyperparams.batchSize);\n        let totalLoss = 0;\n        \n        // Debug: Check weight statistics before training\n        if (this.stepCount % 50 === 0) {\n            const weights = this.qNetwork.getWeights();\n            const outputWeights = weights.weightsHiddenOutput;\n            const weightMagnitude = Math.sqrt(outputWeights.reduce((sum, w) => sum + w * w, 0) / outputWeights.length);\n            console.log(`Step ${this.stepCount} - Weight magnitude: ${weightMagnitude.toFixed(6)}`);\n        }\n        \n        for (const experience of batch) {\n            const { state, action, reward, nextState, done } = experience;\n            \n            // Calculate current Q-values\n            const currentQValues = this.qNetwork.forward(state);\n            const currentQ = currentQValues[action];\n            \n            // Calculate target Q-value\n            let targetQ;\n            if (done) {\n                targetQ = reward; // No future reward if episode is done\n            } else {\n                const nextQValues = this.targetNetwork.forward(nextState);\n                const maxNextQ = Math.max(...nextQValues);\n                targetQ = reward + this.hyperparams.gamma * maxNextQ;\n            }\n            \n            // Calculate temporal difference error with clipping\n            let tdError = targetQ - currentQ;\n            \n            // Clip TD error to prevent explosive gradients (relaxed since reward timing is fixed)\n            tdError = Math.max(-5.0, Math.min(5.0, tdError));\n            \n            // Debug: Log TD errors periodically\n            if (this.stepCount % 50 === 0 && experience === batch[0]) {\n                console.log(`TD Error: ${tdError.toFixed(4)}, Current Q: ${currentQ.toFixed(4)}, Target Q: ${targetQ.toFixed(4)}`);\n            }\n            \n            // Update Q-network using gradient descent\n            const loss = this._updateNetwork(state, action, tdError);\n            totalLoss += loss;\n        }\n        \n        this.stepCount++;\n        \n        // Update target network periodically\n        if (this.stepCount - this.lastTargetUpdate >= this.hyperparams.targetUpdateFreq) {\n            this._updateTargetNetwork();\n            this.lastTargetUpdate = this.stepCount;\n            console.log(`Target network updated at step ${this.stepCount}`);\n        }\n        \n        return totalLoss / batch.length;\n    }\n    \n    /**\n     * Update Q-network weights using backpropagation\n     * @private\n     * @param {Float32Array} state - Input state\n     * @param {number} action - Action index\n     * @param {number} tdError - Temporal difference error\n     * @returns {number} Mean squared error loss\n     */\n    _updateNetwork(state, action, tdError) {\n        const learningRate = this.hyperparams.learningRate;\n        \n        // Get current weights and hidden activations\n        const weights = this.qNetwork.getWeights();\n        const hiddenActivation = this._getHiddenActivation(state);\n        \n        // Calculate Huber loss (PyTorch DQN style) - more robust than MSE\n        const huberDelta = 1.0; // Standard Huber loss delta\n        const absError = Math.abs(tdError);\n        const loss = absError <= huberDelta ? \n            0.5 * tdError * tdError : \n            huberDelta * (absError - 0.5 * huberDelta);\n        \n        // Backpropagation: Update output layer weights and biases with strong gradient clipping\n        const outputWeights = weights.weightsHiddenOutput;\n        for (let i = 0; i < hiddenActivation.length; i++) {\n            // Correct indexing: weights are stored as [hidden][output]\n            const weightIndex = i * this.numActions + action;\n            let gradient = tdError * hiddenActivation[i];\n            // Moderate gradient clipping (relaxed since reward timing is fixed)\n            gradient = Math.max(-0.5, Math.min(0.5, gradient));\n            outputWeights[weightIndex] += learningRate * gradient;\n            \n            // Clamp weights to reasonable range\n            outputWeights[weightIndex] = Math.max(-10.0, Math.min(10.0, outputWeights[weightIndex]));\n        }\n        // Clip bias gradient (relaxed since reward timing is fixed)\n        let biasGradient = Math.max(-0.5, Math.min(0.5, tdError));\n        weights.biasOutput[action] += learningRate * biasGradient;\n        \n        // Clamp bias to reasonable range\n        weights.biasOutput[action] = Math.max(-10.0, Math.min(10.0, weights.biasOutput[action]));\n        \n        // Backpropagation: Update hidden layer weights and biases\n        // Gradient for hidden layer = output error * output weight * ReLU derivative\n        const inputWeights = weights.weightsInputHidden;\n        const hiddenBiases = weights.biasHidden;\n        \n        for (let h = 0; h < hiddenActivation.length; h++) {\n            // ReLU derivative: 1 if activation > 0, 0 otherwise\n            const reluDerivative = hiddenActivation[h] > 0 ? 1.0 : 0.0;\n            \n            // Error signal propagated back to this hidden unit\n            // Correct indexing for output weights\n            const hiddenWeightIndex = h * this.numActions + action;\n            const hiddenError = tdError * outputWeights[hiddenWeightIndex] * reluDerivative;\n            \n            // Update input-to-hidden weights with strong gradient clipping\n            // Correct indexing: weights are stored as [input][hidden]\n            for (let i = 0; i < state.length; i++) {\n                const inputWeightIndex = i * hiddenActivation.length + h;\n                let gradient = hiddenError * state[i];\n                // Moderate gradient clipping (relaxed since reward timing is fixed)\n                gradient = Math.max(-0.5, Math.min(0.5, gradient));\n                inputWeights[inputWeightIndex] += learningRate * gradient;\n                \n                // Clamp weights to reasonable range\n                inputWeights[inputWeightIndex] = Math.max(-10.0, Math.min(10.0, inputWeights[inputWeightIndex]));\n            }\n            \n            // Update hidden biases with moderate gradient clipping\n            let biasGradient = Math.max(-0.5, Math.min(0.5, hiddenError));\n            hiddenBiases[h] += learningRate * biasGradient;\n            \n            // Clamp bias to reasonable range\n            hiddenBiases[h] = Math.max(-10.0, Math.min(10.0, hiddenBiases[h]));\n        }\n        \n        // Set updated weights\n        this.qNetwork.setWeights(weights);\n        \n        return loss;\n    }\n    \n    /**\n     * Get hidden layer activation for given state\n     * @private\n     * @param {Float32Array} state - Input state\n     * @returns {Float32Array} Hidden layer activation\n     */\n    _getHiddenActivation(state) {\n        // Run forward pass to get hidden activations\n        this.qNetwork.forward(state);\n        \n        // Get the actual hidden layer activations from the network\n        return this.qNetwork.getHiddenActivations();\n    }\n    \n    /**\n     * Update target network with current Q-network weights\n     * @private\n     */\n    _updateTargetNetwork() {\n        const weights = this.qNetwork.getWeights();\n        this.targetNetwork.setWeights(weights);\n    }\n    \n    /**\n     * Run training episode\n     * @param {Object} environment - Environment with reset() and step() methods\n     * @param {boolean} verbose - Whether to log progress\n     * @returns {Object} Episode results\n     */\n    runEpisode(environment, verbose = false) {\n        if (!this.isInitialized) {\n            throw new Error('Q-Learning not initialized. Call initialize() first.');\n        }\n        \n        // Reset environment and get initial state\n        environment.reset();\n        let state = environment.getNormalizedInputs();\n        \n        let totalReward = 0;\n        let stepCount = 0;\n        let totalLoss = 0;\n        let lossCount = 0;\n        \n        for (let step = 0; step < this.hyperparams.maxStepsPerEpisode; step++) {\n            // Select action\n            const actionIndex = this.selectAction(state, true);\n            const actionValue = this.actions[actionIndex];\n            \n            // Take action in environment\n            const result = environment.step(actionValue);\n            const nextState = environment.getNormalizedInputs();\n            const reward = result.reward;\n            const done = result.done;\n            \n            // Train on this experience\n            const loss = this.train(state, actionIndex, reward, nextState, done);\n            if (loss > 0) {\n                totalLoss += loss;\n                lossCount++;\n            }\n            \n            totalReward += reward;\n            stepCount++;\n            \n            if (done) {\n                break;\n            }\n            \n            state = nextState;\n        }\n        \n        // Epsilon decay is now handled in _updateEpsilon() called from train()\n        \n        this.episode++;\n        \n        const avgLoss = lossCount > 0 ? totalLoss / lossCount : 0;\n        \n        // Check if episode reached maximum steps (training completion detection)\n        if (stepCount >= this.hyperparams.maxStepsPerEpisode) {\n            this.consecutiveMaxEpisodes++;\n            if (verbose) {\n                console.log(`🎯 Episode ${this.episode} reached max steps (${stepCount}). Consecutive: ${this.consecutiveMaxEpisodes}/20`);\n            }\n        } else {\n            this.consecutiveMaxEpisodes = 0; // Reset counter if episode didn't reach max steps\n        }\n        \n        // Note: Auto-completion logic removed to allow continuous efficiency learning\n        // The robot can continue learning to be more efficient even after achieving basic balance\n        // Training will only stop when user manually stops or reaches the episode limit\n        // \n        // Previously: Auto-completed after 20 consecutive max-step episodes\n        // if (this.consecutiveMaxEpisodes >= 20 && !this.trainingCompleted) {\n        //     this.trainingCompleted = true;\n        //     console.log(`🏆 TRAINING COMPLETED! Model consistently balanced for 20 consecutive episodes...`);\n        // }\n        \n        // Record metrics\n        this.metrics.addEpisode(totalReward, stepCount, avgLoss, this.hyperparams.epsilon);\n        \n        if (verbose) {\n            console.log(`Episode ${this.episode}: Reward=${totalReward.toFixed(2)}, Steps=${stepCount}, Loss=${avgLoss.toFixed(4)}, Epsilon=${this.hyperparams.epsilon.toFixed(3)}`);\n        }\n        \n        return {\n            episode: this.episode,\n            reward: totalReward,\n            steps: stepCount,\n            loss: avgLoss,\n            epsilon: this.hyperparams.epsilon,\n            consecutiveMaxEpisodes: this.consecutiveMaxEpisodes,\n            trainingCompleted: this.trainingCompleted\n        };\n    }\n    \n    /**\n     * Run full training process\n     * @param {Object} environment - Environment with reset() and step() methods\n     * @param {Object} options - Training options\n     * @returns {TrainingMetrics} Training results\n     */\n    async runTraining(environment, options = {}) {\n        const verbose = options.verbose || false;\n        const saveInterval = options.saveInterval || 100;\n        const onEpisodeEnd = options.onEpisodeEnd || null;\n        \n        console.log('Starting Q-Learning training...');\n        console.log(`Max episodes: ${this.hyperparams.maxEpisodes}`);\n        console.log(`Convergence threshold: ${this.hyperparams.convergenceThreshold} (over ${this.hyperparams.convergenceWindow} episodes)`);\n        \n        this.metrics.reset();\n        \n        for (let ep = 0; ep < this.hyperparams.maxEpisodes; ep++) {\n            const result = this.runEpisode(environment, verbose);\n            \n            // Check convergence\n            const converged = this.metrics.checkConvergence(\n                this.hyperparams.convergenceThreshold,\n                this.hyperparams.convergenceWindow\n            );\n            \n            if (converged && !this.metrics.converged) {\n                console.log(`Training converged at episode ${this.episode}!`);\n                console.log(`Average reward: ${this.metrics.getAverageReward().toFixed(2)}`);\n            }\n            \n            // Progress reporting\n            if (verbose && (ep + 1) % saveInterval === 0) {\n                const summary = this.metrics.getSummary();\n                console.log(`\\n=== Episode ${ep + 1}/${this.hyperparams.maxEpisodes} ===`);\n                console.log(`Average reward (last 100): ${summary.averageReward.toFixed(2)}`);\n                console.log(`Best reward: ${summary.bestReward.toFixed(2)}`);\n                console.log(`Average episode length: ${summary.averageLength.toFixed(1)}`);\n                console.log(`Current epsilon: ${summary.currentEpsilon.toFixed(3)}`);\n                console.log(`Replay buffer size: ${this.replayBuffer.size()}`);\n            }\n            \n            // Call episode callback if provided\n            if (onEpisodeEnd) {\n                onEpisodeEnd(result, this.metrics.getSummary());\n            }\n            \n            // Early stopping on convergence (optional)\n            if (options.earlyStop && converged) {\n                console.log('Early stopping due to convergence');\n                break;\n            }\n        }\n        \n        const finalSummary = this.metrics.getSummary();\n        console.log('\\n=== Training Complete ===');\n        console.log(`Episodes completed: ${finalSummary.episodes}`);\n        console.log(`Total steps: ${finalSummary.totalSteps}`);\n        console.log(`Final average reward: ${finalSummary.averageReward.toFixed(2)}`);\n        console.log(`Best reward achieved: ${finalSummary.bestReward.toFixed(2)}`);\n        console.log(`Training time: ${finalSummary.trainingTime.toFixed(1)}s`);\n        console.log(`Converged: ${finalSummary.converged ? 'Yes' : 'No'}`);\n        \n        return this.metrics;\n    }\n    \n    /**\n     * Evaluate trained agent performance\n     * @param {Object} environment - Environment for evaluation\n     * @param {number} numEpisodes - Number of evaluation episodes\n     * @returns {Object} Evaluation results\n     */\n    evaluate(environment, numEpisodes = 10) {\n        if (!this.isInitialized) {\n            throw new Error('Q-Learning not initialized. Call initialize() first.');\n        }\n        \n        const oldEpsilon = this.hyperparams.epsilon;\n        this.hyperparams.epsilon = 0; // No exploration during evaluation\n        \n        const results = [];\n        \n        for (let ep = 0; ep < numEpisodes; ep++) {\n            environment.reset();\n            let state = environment.getNormalizedInputs();\n            let totalReward = 0;\n            let stepCount = 0;\n            \n            for (let step = 0; step < this.hyperparams.maxStepsPerEpisode; step++) {\n                const actionIndex = this.selectAction(state, false); // No exploration\n                const actionValue = this.actions[actionIndex];\n                \n                const result = environment.step(actionValue);\n                const nextState = environment.getNormalizedInputs();\n                const reward = result.reward;\n                const done = result.done;\n                \n                totalReward += reward;\n                stepCount++;\n                \n                if (done) {\n                    break;\n                }\n                \n                state = nextState;\n            }\n            \n            results.push({ reward: totalReward, steps: stepCount });\n        }\n        \n        this.hyperparams.epsilon = oldEpsilon; // Restore original epsilon\n        \n        const avgReward = results.reduce((sum, r) => sum + r.reward, 0) / results.length;\n        const avgSteps = results.reduce((sum, r) => sum + r.steps, 0) / results.length;\n        const bestReward = Math.max(...results.map(r => r.reward));\n        const worstReward = Math.min(...results.map(r => r.reward));\n        \n        return {\n            episodes: numEpisodes,\n            averageReward: avgReward,\n            bestReward: bestReward,\n            worstReward: worstReward,\n            averageSteps: avgSteps,\n            results: results\n        };\n    }\n    \n    /**\n     * Get action value for given state (Q-value)\n     * @param {Float32Array} state - Input state\n     * @param {number} actionIndex - Action index\n     * @returns {number} Q-value for state-action pair\n     */\n    getQValue(state, actionIndex) {\n        if (!this.isInitialized) {\n            throw new Error('Q-Learning not initialized. Call initialize() first.');\n        }\n        \n        const qValues = this.qNetwork.forward(state);\n        return qValues[actionIndex];\n    }\n    \n    /**\n     * Get all Q-values for given state\n     * @param {Float32Array} state - Input state\n     * @returns {Float32Array} All Q-values\n     */\n    getAllQValues(state) {\n        if (!this.isInitialized) {\n            throw new Error('Q-Learning not initialized. Call initialize() first.');\n        }\n        \n        return this.qNetwork.forward(state);\n    }\n    \n    /**\n     * Save Q-learning model\n     * @returns {Object} Serializable model data\n     */\n    save() {\n        if (!this.isInitialized) {\n            throw new Error('Q-Learning not initialized. Call initialize() first.');\n        }\n        \n        return {\n            hyperparams: this.hyperparams,\n            qNetworkWeights: this.qNetwork.getWeights(),\n            targetNetworkWeights: this.targetNetwork.getWeights(),\n            episode: this.episode,\n            stepCount: this.stepCount,\n            metrics: this.metrics.getSummary(),\n            actions: this.actions\n        };\n    }\n    \n    /**\n     * Load Q-learning model\n     * @param {Object} modelData - Saved model data\n     */\n    async load(modelData) {\n        // Extract architecture from saved weights\n        const savedArchitecture = modelData.qNetworkWeights?.architecture;\n        if (!savedArchitecture) {\n            throw new Error('Invalid model data: missing architecture information');\n        }\n        \n        // Check if we need to reinitialize with different architecture\n        if (this.isInitialized) {\n            const currentArch = this.qNetwork.getArchitecture();\n            \n            if (currentArch.inputSize !== savedArchitecture.inputSize ||\n                currentArch.hiddenSize !== savedArchitecture.hiddenSize ||\n                currentArch.outputSize !== savedArchitecture.outputSize) {\n                \n                console.log(`Architecture mismatch detected:`);\n                console.log(`  Current: ${currentArch.inputSize}-${currentArch.hiddenSize}-${currentArch.outputSize}`);\n                console.log(`  Saved: ${savedArchitecture.inputSize}-${savedArchitecture.hiddenSize}-${savedArchitecture.outputSize}`);\n                console.log(`  Reinitializing with saved architecture...`);\n                \n                // Reset to uninitialized state\n                this.isInitialized = false;\n                this.qNetwork = null;\n                this.targetNetwork = null;\n            }\n        }\n        \n        // Update hyperparameters, ensuring hiddenSize matches saved architecture\n        this.hyperparams = new Hyperparameters({\n            ...modelData.hyperparams,\n            hiddenSize: savedArchitecture.hiddenSize\n        });\n        this.episode = modelData.episode || 0;\n        this.stepCount = modelData.stepCount || 0;\n        this.actions = modelData.actions || [-1.0, 0.0, 1.0];\n        this.numActions = this.actions.length;\n        \n        // Initialize with correct architecture from saved model\n        if (!this.isInitialized) {\n            await this.initialize(savedArchitecture.inputSize);\n        }\n        \n        // Load weights (should now be compatible)\n        this.qNetwork.setWeights(modelData.qNetworkWeights);\n        this.targetNetwork.setWeights(modelData.targetNetworkWeights);\n        \n        console.log(`Q-Learning model loaded successfully with architecture: ${savedArchitecture.inputSize}-${savedArchitecture.hiddenSize}-${savedArchitecture.outputSize}`);\n    }\n    \n    /**\n     * Reset training state\n     */\n    reset() {\n        this.metrics.reset();\n        this.replayBuffer.clear();\n        this.episode = 0;\n        this.stepCount = 0;\n        this.globalStepCount = 0; // Reset global step counter for epsilon decay\n        this.lastTargetUpdate = 0;\n        this.consecutiveMaxEpisodes = 0;\n        this.trainingCompleted = false;\n        this.initialEpsilon = null; // Reset initial epsilon so new training uses current slider value\n        \n        if (this.isInitialized) {\n            this.qNetwork.resetWeights();\n            this.targetNetwork = this.qNetwork.clone();\n        }\n    }\n    \n    /**\n     * Get training statistics\n     * @returns {Object} Current training statistics\n     */\n    getStats() {\n        return {\n            ...this.metrics.getSummary(),\n            replayBufferSize: this.replayBuffer.size(),\n            stepCount: this.stepCount,\n            lastTargetUpdate: this.lastTargetUpdate,\n            networkParameters: this.isInitialized ? this.qNetwork.getParameterCount() : 0,\n            consecutiveMaxEpisodes: this.consecutiveMaxEpisodes,\n            trainingCompleted: this.trainingCompleted\n        };\n    }\n    \n    /**\n     * Utility function to find index of maximum value in array\n     * @private\n     * @param {Float32Array} array - Input array\n     * @returns {number} Index of maximum value\n     */\n    _argmax(array) {\n        let maxIndex = 0;\n        let maxValue = array[0];\n        \n        for (let i = 1; i < array.length; i++) {\n            if (array[i] > maxValue) {\n                maxValue = array[i];\n                maxIndex = i;\n            }\n        }\n        \n        return maxIndex;\n    }\n}\n\n/**\n * Utility function to create Q-learning instance with default hyperparameters\n * @param {Object} overrides - Hyperparameter overrides\n * @returns {QLearning} New Q-learning instance\n */\nexport function createDefaultQLearning(overrides = {}) {\n    return new QLearning(overrides);\n}\n\n/**\n * Utility function to create Q-learning instance optimized for fast training\n * @returns {QLearning} Q-learning configured for training speed\n */\nexport function createFastQLearning() {\n    return new QLearning({\n        learningRate: 0.01,\n        epsilon: 0.3,\n        epsilonDecay: 0.99,\n        batchSize: 16,\n        targetUpdateFreq: 50,\n        maxEpisodes: 500,\n        hiddenSize: 6\n    });\n}\n\n/**\n * Utility function to create Q-learning instance optimized for performance\n * @returns {QLearning} Q-learning configured for best performance\n */\nexport function createOptimalQLearning() {\n    return new QLearning({\n        learningRate: 0.001,\n        epsilon: 0.1,\n        epsilonDecay: 0.995,\n        batchSize: 32,\n        targetUpdateFreq: 100,\n        maxEpisodes: 2000,\n        hiddenSize: 12,\n        convergenceThreshold: 300\n    });\n}","/**\n * Shader Manager for WebGPU Neural Network Operations\n * \n * Handles compilation, pipeline creation, and execution of WGSL compute shaders\n * for neural network operations in the two-wheel balancing robot RL application.\n */\n\n/**\n * Shader compilation and management utilities\n */\nexport class ShaderManager {\n    constructor(device) {\n        this.device = device;\n        this.shaderModules = new Map();\n        this.computePipelines = new Map();\n        this.bindGroupLayouts = new Map();\n        this.uniformBuffers = new Map();\n        this.storageBuffers = new Map();\n        \n        // Shader source cache\n        this.shaderSources = new Map();\n        \n        // Performance monitoring\n        this.compilationTimes = new Map();\n        this.pipelineCreationTimes = new Map();\n    }\n\n    /**\n     * Load and compile all neural network shaders\n     * @returns {Promise<void>} Promise that resolves when all shaders are loaded\n     */\n    async loadShaders() {\n        const startTime = performance.now();\n        \n        try {\n            // Load shader source files\n            await this._loadShaderSources();\n            \n            // Compile shader modules\n            await this._compileShaderModules();\n            \n            // Create compute pipelines\n            await this._createComputePipelines();\n            \n            const totalTime = performance.now() - startTime;\n            console.log(`Shaders loaded and compiled in ${totalTime.toFixed(2)}ms`);\n            \n        } catch (error) {\n            console.error('Failed to load shaders:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Load shader source code from files\n     * @private\n     */\n    async _loadShaderSources() {\n        const shaderFiles = {\n            'matmul': './shaders/matmul.wgsl',\n            'relu': './shaders/relu.wgsl', \n            'qlearning': './shaders/qlearning.wgsl'\n        };\n\n        const loadPromises = Object.entries(shaderFiles).map(async ([name, path]) => {\n            try {\n                const response = await fetch(path);\n                if (!response.ok) {\n                    throw new Error(`Failed to load shader ${name}: ${response.statusText}`);\n                }\n                const source = await response.text();\n                this.shaderSources.set(name, source);\n                console.log(`Loaded shader source: ${name}`);\n            } catch (error) {\n                console.error(`Failed to load shader ${name}:`, error);\n                // Fall back to inline shader sources\n                this.shaderSources.set(name, this._getInlineShaderSource(name));\n            }\n        });\n\n        await Promise.all(loadPromises);\n    }\n\n    /**\n     * Get inline shader source as fallback\n     * @private\n     */\n    _getInlineShaderSource(name) {\n        // Simplified inline versions for fallback\n        const inlineShaders = {\n            'matmul': `\n                @group(0) @binding(0) var<storage, read> matrixA: array<f32>;\n                @group(0) @binding(1) var<storage, read> matrixB: array<f32>;\n                @group(0) @binding(2) var<storage, read> bias: array<f32>;\n                @group(0) @binding(3) var<storage, read_write> matrixC: array<f32>;\n                @group(0) @binding(4) var<uniform> params: vec4<u32>;\n                \n                @compute @workgroup_size(64, 1, 1)\n                fn matmul_simple(@builtin(global_invocation_id) global_id: vec3<u32>) {\n                    let index = global_id.x;\n                    let M = params.x;\n                    let K = params.y;\n                    let N = params.z;\n                    \n                    if (index >= M * N) { return; }\n                    \n                    let row = index / N;\n                    let col = index % N;\n                    \n                    var sum: f32 = 0.0;\n                    for (var k: u32 = 0u; k < K; k++) {\n                        sum += matrixA[row * K + k] * matrixB[k * N + col];\n                    }\n                    \n                    matrixC[index] = sum + bias[col];\n                }\n            `,\n            'relu': `\n                @group(0) @binding(0) var<storage, read> input_data: array<f32>;\n                @group(0) @binding(1) var<storage, read_write> output_data: array<f32>;\n                @group(0) @binding(2) var<uniform> params: vec4<u32>;\n                \n                @compute @workgroup_size(64, 1, 1)\n                fn relu(@builtin(global_invocation_id) global_id: vec3<u32>) {\n                    let index = global_id.x;\n                    let size = params.x;\n                    \n                    if (index >= size) { return; }\n                    \n                    output_data[index] = max(0.0, input_data[index]);\n                }\n            `,\n            'qlearning': `\n                @group(0) @binding(0) var<storage, read> q_values: array<f32>;\n                @group(0) @binding(1) var<storage, read> target_q_values: array<f32>;\n                @group(0) @binding(2) var<storage, read> actions: array<u32>;\n                @group(0) @binding(3) var<storage, read_write> td_errors: array<f32>;\n                @group(0) @binding(4) var<uniform> params: vec4<f32>;\n                \n                @compute @workgroup_size(32, 1, 1)\n                fn compute_td_errors(@builtin(global_invocation_id) global_id: vec3<u32>) {\n                    let batch_idx = global_id.x;\n                    let batch_size = u32(params.x);\n                    let gamma = params.y;\n                    \n                    if (batch_idx >= batch_size) { return; }\n                    \n                    let action = actions[batch_idx];\n                    let current_q = q_values[batch_idx * 3u + action];\n                    let target_q = target_q_values[batch_idx * 3u + action];\n                    \n                    td_errors[batch_idx] = target_q - current_q;\n                }\n            `\n        };\n\n        return inlineShaders[name] || '';\n    }\n\n    /**\n     * Compile shader modules from source code\n     * @private\n     */\n    async _compileShaderModules() {\n        for (const [name, source] of this.shaderSources) {\n            const startTime = performance.now();\n            \n            try {\n                const shaderModule = this.device.createShaderModule({\n                    label: `${name}_shader`,\n                    code: source\n                });\n\n                // Check for compilation errors\n                const compilationInfo = await shaderModule.getCompilationInfo();\n                \n                if (compilationInfo.messages.length > 0) {\n                    console.warn(`Shader ${name} compilation messages:`, compilationInfo.messages);\n                    \n                    // Check for errors\n                    const errors = compilationInfo.messages.filter(msg => msg.type === 'error');\n                    if (errors.length > 0) {\n                        throw new Error(`Shader ${name} compilation failed: ${errors.map(e => e.message).join(', ')}`);\n                    }\n                }\n\n                this.shaderModules.set(name, shaderModule);\n                \n                const compilationTime = performance.now() - startTime;\n                this.compilationTimes.set(name, compilationTime);\n                \n                console.log(`Compiled shader ${name} in ${compilationTime.toFixed(2)}ms`);\n                \n            } catch (error) {\n                console.error(`Failed to compile shader ${name}:`, error);\n                throw error;\n            }\n        }\n    }\n\n    /**\n     * Create compute pipelines for all operations\n     * @private\n     */\n    async _createComputePipelines() {\n        // Matrix multiplication pipelines\n        await this._createMatMulPipelines();\n        \n        // Activation function pipelines\n        await this._createActivationPipelines();\n        \n        // Q-learning pipelines\n        await this._createQLearningPipelines();\n    }\n\n    /**\n     * Create matrix multiplication pipelines\n     * @private\n     */\n    async _createMatMulPipelines() {\n        const matmulModule = this.shaderModules.get('matmul');\n        if (!matmulModule) {\n            throw new Error('Matrix multiplication shader module not found');\n        }\n\n        // Bind group layout for matrix multiplication\n        const matmulBindGroupLayout = this.device.createBindGroupLayout({\n            label: 'matmul_bind_group_layout',\n            entries: [\n                { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // matrixA\n                { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // matrixB\n                { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // bias\n                { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },           // matrixC\n                { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },          // params\n            ]\n        });\n\n        this.bindGroupLayouts.set('matmul', matmulBindGroupLayout);\n\n        // Create pipeline layout\n        const pipelineLayout = this.device.createPipelineLayout({\n            label: 'matmul_pipeline_layout',\n            bindGroupLayouts: [matmulBindGroupLayout]\n        });\n\n        // Create compute pipelines for different entry points\n        const entryPoints = ['main', 'matmul_simple', 'matmul_batch'];\n        \n        for (const entryPoint of entryPoints) {\n            try {\n                const pipeline = this.device.createComputePipeline({\n                    label: `matmul_${entryPoint}_pipeline`,\n                    layout: pipelineLayout,\n                    compute: {\n                        module: matmulModule,\n                        entryPoint: entryPoint\n                    }\n                });\n\n                this.computePipelines.set(`matmul_${entryPoint}`, pipeline);\n                console.log(`Created matrix multiplication pipeline: ${entryPoint}`);\n                \n            } catch (error) {\n                console.warn(`Failed to create pipeline for ${entryPoint}, skipping:`, error.message);\n            }\n        }\n    }\n\n    /**\n     * Create activation function pipelines\n     * @private\n     */\n    async _createActivationPipelines() {\n        const reluModule = this.shaderModules.get('relu');\n        if (!reluModule) {\n            throw new Error('ReLU shader module not found');\n        }\n\n        // Bind group layout for activation functions\n        const activationBindGroupLayout = this.device.createBindGroupLayout({\n            label: 'activation_bind_group_layout',\n            entries: [\n                { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // input\n                { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },           // output\n                { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },          // params\n            ]\n        });\n\n        this.bindGroupLayouts.set('activation', activationBindGroupLayout);\n\n        // Create pipeline layout\n        const pipelineLayout = this.device.createPipelineLayout({\n            label: 'activation_pipeline_layout',\n            bindGroupLayouts: [activationBindGroupLayout]\n        });\n\n        // Create pipelines for different activation functions\n        const entryPoints = ['relu', 'leaky_relu', 'relu_derivative', 'relu_inplace', 'softmax'];\n        \n        for (const entryPoint of entryPoints) {\n            try {\n                const pipeline = this.device.createComputePipeline({\n                    label: `${entryPoint}_pipeline`,\n                    layout: pipelineLayout,\n                    compute: {\n                        module: reluModule,\n                        entryPoint: entryPoint\n                    }\n                });\n\n                this.computePipelines.set(entryPoint, pipeline);\n                console.log(`Created activation pipeline: ${entryPoint}`);\n                \n            } catch (error) {\n                console.warn(`Failed to create pipeline for ${entryPoint}, skipping:`, error.message);\n            }\n        }\n    }\n\n    /**\n     * Create Q-learning pipelines\n     * @private\n     */\n    async _createQLearningPipelines() {\n        const qlearningModule = this.shaderModules.get('qlearning');\n        if (!qlearningModule) {\n            throw new Error('Q-learning shader module not found');\n        }\n\n        // Bind group layout for Q-learning\n        const qlearningBindGroupLayout = this.device.createBindGroupLayout({\n            label: 'qlearning_bind_group_layout',\n            entries: [\n                { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // q_values\n                { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // target_q_values\n                { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // actions\n                { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // rewards\n                { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // dones\n                { binding: 5, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // hidden_activations\n                { binding: 6, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // input_states\n                { binding: 7, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },           // weights_hidden\n                { binding: 8, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },           // bias_hidden\n                { binding: 9, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },           // weights_output\n                { binding: 10, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },          // bias_output\n                { binding: 11, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },          // td_errors\n                { binding: 12, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },         // params\n            ]\n        });\n\n        this.bindGroupLayouts.set('qlearning', qlearningBindGroupLayout);\n\n        // Create pipeline layout\n        const pipelineLayout = this.device.createPipelineLayout({\n            label: 'qlearning_pipeline_layout',\n            bindGroupLayouts: [qlearningBindGroupLayout]\n        });\n\n        // Create pipelines for Q-learning operations\n        const entryPoints = [\n            'compute_td_errors',\n            'update_output_weights',\n            'update_output_bias',\n            'update_hidden_weights',\n            'update_hidden_bias'\n        ];\n        \n        for (const entryPoint of entryPoints) {\n            try {\n                const pipeline = this.device.createComputePipeline({\n                    label: `qlearning_${entryPoint}_pipeline`,\n                    layout: pipelineLayout,\n                    compute: {\n                        module: qlearningModule,\n                        entryPoint: entryPoint\n                    }\n                });\n\n                this.computePipelines.set(`qlearning_${entryPoint}`, pipeline);\n                console.log(`Created Q-learning pipeline: ${entryPoint}`);\n                \n            } catch (error) {\n                console.warn(`Failed to create pipeline for ${entryPoint}, skipping:`, error.message);\n            }\n        }\n    }\n\n    /**\n     * Get a compute pipeline by name\n     * @param {string} pipelineName - Name of the pipeline\n     * @returns {GPUComputePipeline} The requested compute pipeline\n     */\n    getPipeline(pipelineName) {\n        const pipeline = this.computePipelines.get(pipelineName);\n        if (!pipeline) {\n            throw new Error(`Pipeline ${pipelineName} not found. Available pipelines: ${Array.from(this.computePipelines.keys()).join(', ')}`);\n        }\n        return pipeline;\n    }\n\n    /**\n     * Get a bind group layout by name\n     * @param {string} layoutName - Name of the bind group layout\n     * @returns {GPUBindGroupLayout} The requested bind group layout\n     */\n    getBindGroupLayout(layoutName) {\n        const layout = this.bindGroupLayouts.get(layoutName);\n        if (!layout) {\n            throw new Error(`Bind group layout ${layoutName} not found. Available layouts: ${Array.from(this.bindGroupLayouts.keys()).join(', ')}`);\n        }\n        return layout;\n    }\n\n    /**\n     * Get compilation and creation performance metrics\n     * @returns {Object} Performance metrics\n     */\n    getPerformanceMetrics() {\n        const totalCompilationTime = Array.from(this.compilationTimes.values())\n            .reduce((sum, time) => sum + time, 0);\n        \n        const totalPipelineTime = Array.from(this.pipelineCreationTimes.values())\n            .reduce((sum, time) => sum + time, 0);\n\n        return {\n            totalCompilationTime,\n            totalPipelineTime,\n            shadersCompiled: this.shaderModules.size,\n            pipelinesCreated: this.computePipelines.size,\n            compilationTimes: Object.fromEntries(this.compilationTimes),\n            pipelineCreationTimes: Object.fromEntries(this.pipelineCreationTimes),\n            availablePipelines: Array.from(this.computePipelines.keys()),\n            availableLayouts: Array.from(this.bindGroupLayouts.keys())\n        };\n    }\n\n    /**\n     * Validate shader compilation status\n     * @returns {Object} Validation results\n     */\n    validateShaders() {\n        const validation = {\n            allShadersCompiled: true,\n            missingShaders: [],\n            availableShaders: Array.from(this.shaderModules.keys()),\n            availablePipelines: Array.from(this.computePipelines.keys())\n        };\n\n        const requiredShaders = ['matmul', 'relu', 'qlearning'];\n        const requiredPipelines = [\n            'matmul_simple', 'relu', 'qlearning_compute_td_errors'\n        ];\n\n        for (const shader of requiredShaders) {\n            if (!this.shaderModules.has(shader)) {\n                validation.allShadersCompiled = false;\n                validation.missingShaders.push(shader);\n            }\n        }\n\n        validation.allPipelinesCreated = requiredPipelines.every(\n            pipeline => this.computePipelines.has(pipeline)\n        );\n\n        return validation;\n    }\n\n    /**\n     * Clean up resources\n     */\n    destroy() {\n        // Clear all caches\n        this.shaderModules.clear();\n        this.computePipelines.clear();\n        this.bindGroupLayouts.clear();\n        this.shaderSources.clear();\n        this.compilationTimes.clear();\n        this.pipelineCreationTimes.clear();\n\n        console.log('Shader manager destroyed');\n    }\n}","/**\n * Enhanced Buffer Manager for WebGPU Neural Network Operations\n * \n * Advanced GPU buffer management with pooling, async operations, and optimization\n * for neural network operations. Provides efficient memory management for the\n * two-wheel balancing robot RL application with production-ready features.\n * \n * Features:\n * - Buffer pooling and reuse for performance optimization\n * - Async buffer operations with proper error handling\n * - Memory usage tracking and validation\n * - Batch operation support for training efficiency\n * - Staging buffer management for optimal CPU-GPU transfers\n * - Buffer size validation and limits checking\n */\n\n/**\n * Buffer usage types for different operations\n */\nexport const BufferUsageType = {\n    STORAGE_READ_WRITE: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    STORAGE_READ_ONLY: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    STORAGE_WRITE_ONLY: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    UNIFORM: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    STAGING_UPLOAD: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC,\n    STAGING_DOWNLOAD: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    VERTEX: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n    INDEX: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST\n};\n\n/**\n * Buffer pool entry for reuse management\n */\nclass BufferPoolEntry {\n    constructor(buffer, size, usage, lastUsed = Date.now()) {\n        this.buffer = buffer;\n        this.size = size;\n        this.usage = usage;\n        this.lastUsed = lastUsed;\n        this.isInUse = false;\n        this.useCount = 0;\n    }\n\n    markUsed() {\n        this.isInUse = true;\n        this.lastUsed = Date.now();\n        this.useCount++;\n    }\n\n    markAvailable() {\n        this.isInUse = false;\n        this.lastUsed = Date.now();\n    }\n}\n\n/**\n * Enhanced GPU buffer management for neural network operations\n */\nexport class BufferManager {\n    constructor(device, options = {}) {\n        this.device = device;\n        this.isDestroyed = false;\n        \n        // Configuration\n        this.config = {\n            maxBufferSize: options.maxBufferSize || 1024 * 1024 * 64, // 64MB default\n            maxTotalMemory: options.maxTotalMemory || 1024 * 1024 * 512, // 512MB total limit\n            alignment: options.alignment || 256,\n            poolEnabled: options.poolEnabled !== false,\n            poolMaxAge: options.poolMaxAge || 30000, // 30 seconds\n            poolMaxSize: options.poolMaxSize || 50,\n            asyncTimeout: options.asyncTimeout || 10000, // 10 seconds\n            enableValidation: options.enableValidation !== false,\n            enableProfiling: options.enableProfiling !== false\n        };\n        \n        // Named buffer storage\n        this.buffers = new Map();\n        this.bindGroups = new Map();\n        this.bufferMetadata = new Map();\n        \n        // Enhanced buffer pools for reuse\n        this.bufferPools = new Map(); // key: \"size_usage\", value: BufferPoolEntry[]\n        this.poolStats = {\n            hits: 0,\n            misses: 0,\n            evictions: 0,\n            totalReused: 0\n        };\n        \n        // Memory tracking\n        this.memoryUsage = {\n            totalAllocated: 0,\n            totalActive: 0,\n            totalPooled: 0,\n            bufferCount: 0,\n            pooledCount: 0\n        };\n        \n        // Performance tracking\n        this.performanceMetrics = {\n            bufferCreationTimes: [],\n            memoryTransferTimes: [],\n            mappingTimes: [],\n            asyncOperationTimes: [],\n            errorCount: 0,\n            warningCount: 0\n        };\n        \n        // Async operation tracking\n        this.pendingOperations = new Map();\n        this.operationCounter = 0;\n        \n        // Validation and error handling\n        this.validationEnabled = this.config.enableValidation;\n        this.errorLog = [];\n        \n        // Buffer type tracking for optimization\n        this.bufferTypeStats = new Map();\n        \n        // Setup periodic pool cleanup\n        this._setupPoolCleanup();\n        \n        console.log('Enhanced BufferManager initialized with config:', this.config);\n    }\n\n    /**\n     * Create a GPU buffer with comprehensive validation and pooling\n     * @param {GPUDevice} device - WebGPU device\n     * @param {ArrayBuffer|TypedArray|number} data - Data to upload or size in bytes\n     * @param {number} usage - Buffer usage flags (use BufferUsageType constants)\n     * @param {Object} options - Buffer creation options\n     * @param {string} options.label - Buffer label for debugging\n     * @param {boolean} options.allowReuse - Allow buffer reuse from pool (default: true)\n     * @param {boolean} options.persistent - Keep buffer even when not in use\n     * @returns {Promise<GPUBuffer>} Created or reused buffer\n     */\n    async createBuffer(device, data, usage, options = {}) {\n        this._validateNotDestroyed();\n        \n        const {\n            label = 'unnamed_buffer',\n            allowReuse = true,\n            persistent = false\n        } = options;\n        \n        const startTime = performance.now();\n        \n        try {\n            // Determine buffer size\n            let size;\n            let initialData = null;\n            \n            if (typeof data === 'number') {\n                size = data;\n            } else {\n                if (data instanceof ArrayBuffer) {\n                    size = data.byteLength;\n                    initialData = new Uint8Array(data);\n                } else if (ArrayBuffer.isView(data)) {\n                    size = data.byteLength;\n                    initialData = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n                } else {\n                    throw new Error('Data must be ArrayBuffer, TypedArray, or number (size)');\n                }\n            }\n            \n            // Validate buffer size\n            this._validateBufferSize(size, label);\n            \n            // Align size\n            const alignedSize = this._alignSize(size);\n            \n            // Try to get buffer from pool if allowed\n            let buffer = null;\n            if (allowReuse && this.config.poolEnabled) {\n                buffer = this._getBufferFromPool(alignedSize, usage);\n            }\n            \n            // Create new buffer if not found in pool\n            if (!buffer) {\n                this._validateMemoryLimit(alignedSize);\n                \n                buffer = device.createBuffer({\n                    label: `enhanced_${label}`,\n                    size: alignedSize,\n                    usage: usage\n                });\n                \n                this.poolStats.misses++;\n                this._updateMemoryUsage(alignedSize, 'allocate');\n                \n                console.log(`Created new buffer ${label}: ${this._formatBytes(alignedSize)}`);\n            } else {\n                this.poolStats.hits++;\n                this.poolStats.totalReused++;\n                console.log(`Reused buffer ${label}: ${this._formatBytes(alignedSize)}`);\n            }\n            \n            // Upload initial data if provided\n            if (initialData) {\n                await this.updateBuffer(device.queue, buffer, initialData, 0, { label });\n            }\n            \n            // Track buffer metadata\n            this._trackBufferMetadata(buffer, {\n                label,\n                size: alignedSize,\n                usage,\n                persistent,\n                createdAt: Date.now(),\n                accessCount: 0\n            });\n            \n            const creationTime = performance.now() - startTime;\n            this.performanceMetrics.bufferCreationTimes.push(creationTime);\n            \n            return buffer;\n            \n        } catch (error) {\n            this._handleError(`Failed to create buffer ${label}`, error);\n            throw error;\n        }\n    }\n    \n    /**\n     * Update buffer data with efficient staging and validation\n     * @param {GPUQueue} queue - WebGPU queue\n     * @param {GPUBuffer} buffer - Target buffer\n     * @param {ArrayBuffer|TypedArray} data - Data to upload\n     * @param {number} offset - Offset in buffer (bytes)\n     * @param {Object} options - Update options\n     * @param {string} options.label - Operation label for debugging\n     * @param {boolean} options.useStaging - Use staging buffer for large uploads\n     * @returns {Promise<void>}\n     */\n    async updateBuffer(queue, buffer, data, offset = 0, options = {}) {\n        this._validateNotDestroyed();\n        \n        const { label = 'buffer_update', useStaging = false } = options;\n        const startTime = performance.now();\n        const operationId = this._generateOperationId();\n        \n        try {\n            // Convert data to Uint8Array\n            let uint8Data;\n            if (data instanceof ArrayBuffer) {\n                uint8Data = new Uint8Array(data);\n            } else if (ArrayBuffer.isView(data)) {\n                uint8Data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n            } else {\n                throw new Error('Data must be ArrayBuffer or TypedArray');\n            }\n            \n            // Validate operation\n            this._validateBufferUpdate(buffer, uint8Data, offset);\n            \n            // Track pending operation\n            this.pendingOperations.set(operationId, {\n                type: 'update',\n                buffer,\n                size: uint8Data.length,\n                startTime\n            });\n            \n            // Choose upload method based on size and options\n            if (useStaging && uint8Data.length > 64 * 1024) { // 64KB threshold\n                await this._updateBufferStaging(queue, buffer, uint8Data, offset, label);\n            } else {\n                queue.writeBuffer(buffer, offset, uint8Data);\n            }\n            \n            // Update buffer access tracking\n            this._updateBufferAccess(buffer);\n            \n            const transferTime = performance.now() - startTime;\n            this.performanceMetrics.memoryTransferTimes.push(transferTime);\n            \n            if (this.config.enableProfiling) {\n                console.log(`Updated buffer ${label}: ${this._formatBytes(uint8Data.length)} in ${transferTime.toFixed(2)}ms`);\n            }\n            \n        } catch (error) {\n            this._handleError(`Failed to update buffer ${label}`, error);\n            throw error;\n        } finally {\n            this.pendingOperations.delete(operationId);\n        }\n    }\n    \n    /**\n     * Read buffer data with async operations and validation\n     * @param {GPUDevice} device - WebGPU device\n     * @param {GPUBuffer} buffer - Source buffer\n     * @param {number} size - Size to read (bytes)\n     * @param {number} offset - Offset in buffer (bytes)\n     * @param {Object} options - Read options\n     * @param {string} options.label - Operation label for debugging\n     * @param {number} options.timeout - Operation timeout (ms)\n     * @returns {Promise<ArrayBuffer>} Downloaded data\n     */\n    async readBuffer(device, buffer, size, offset = 0, options = {}) {\n        this._validateNotDestroyed();\n        \n        const {\n            label = 'buffer_read',\n            timeout = this.config.asyncTimeout\n        } = options;\n        \n        const startTime = performance.now();\n        const operationId = this._generateOperationId();\n        \n        try {\n            // Validate read operation\n            this._validateBufferRead(buffer, size, offset);\n            \n            // Track pending operation\n            this.pendingOperations.set(operationId, {\n                type: 'read',\n                buffer,\n                size,\n                startTime\n            });\n            \n            // Create staging buffer for reading\n            const stagingBuffer = await this.createBuffer(device, size, BufferUsageType.STAGING_DOWNLOAD, {\n                label: `staging_${label}_read`,\n                allowReuse: true\n            });\n            \n            // Copy data to staging buffer\n            const commandEncoder = device.createCommandEncoder({\n                label: `copy_${label}_to_staging`\n            });\n            \n            commandEncoder.copyBufferToBuffer(buffer, offset, stagingBuffer, 0, size);\n            const commands = commandEncoder.finish();\n            device.queue.submit([commands]);\n            \n            // Map and read data with timeout\n            const mapPromise = stagingBuffer.mapAsync(GPUMapMode.READ);\n            const timeoutPromise = new Promise((_, reject) => {\n                setTimeout(() => reject(new Error(`Buffer read timeout after ${timeout}ms`)), timeout);\n            });\n            \n            await Promise.race([mapPromise, timeoutPromise]);\n            \n            const mappingStartTime = performance.now();\n            const arrayBuffer = stagingBuffer.getMappedRange().slice();\n            stagingBuffer.unmap();\n            \n            const mappingTime = performance.now() - mappingStartTime;\n            this.performanceMetrics.mappingTimes.push(mappingTime);\n            \n            // Return staging buffer to pool\n            this._returnBufferToPool(stagingBuffer, size, BufferUsageType.STAGING_DOWNLOAD);\n            \n            // Update buffer access tracking\n            this._updateBufferAccess(buffer);\n            \n            const transferTime = performance.now() - startTime;\n            this.performanceMetrics.memoryTransferTimes.push(transferTime);\n            this.performanceMetrics.asyncOperationTimes.push(transferTime);\n            \n            if (this.config.enableProfiling) {\n                console.log(`Read buffer ${label}: ${this._formatBytes(size)} in ${transferTime.toFixed(2)}ms`);\n            }\n            \n            return arrayBuffer;\n            \n        } catch (error) {\n            this._handleError(`Failed to read buffer ${label}`, error);\n            throw error;\n        } finally {\n            this.pendingOperations.delete(operationId);\n        }\n    }\n    \n    /**\n     * Create buffers for neural network architecture with enhanced features\n     * @param {Object} architecture - Network architecture specification\n     * @param {number} architecture.inputSize - Input layer size (2)\n     * @param {number} architecture.hiddenSize - Hidden layer size (4-16)\n     * @param {number} architecture.outputSize - Output layer size (3)\n     * @param {number} architecture.batchSize - Batch size for training (1-32)\n     * @param {Object} options - Buffer creation options\n     * @returns {Promise<Object>} Created buffer references\n     */\n    async createNetworkBuffers(architecture, options = {}) {\n        const { inputSize, hiddenSize, outputSize, batchSize = 1 } = architecture;\n        const { persistent = false, allowReuse = true } = options;\n        \n        console.log(`Creating enhanced buffers for ${inputSize}-${hiddenSize}-${outputSize} network, batch size: ${batchSize}`);\n        \n        const buffers = {};\n        const startTime = performance.now();\n        \n        try {\n            // Calculate buffer sizes\n            const sizes = this._calculateBufferSizes(architecture);\n            \n            // Create input/output buffers with enhanced features\n            buffers.input = await this.createBuffer(this.device, sizes.input, BufferUsageType.STORAGE_READ_ONLY, {\n                label: 'neural_input',\n                persistent,\n                allowReuse\n            });\n            \n            buffers.hidden = await this.createBuffer(this.device, sizes.hidden, BufferUsageType.STORAGE_READ_WRITE, {\n                label: 'neural_hidden',\n                persistent,\n                allowReuse\n            });\n            \n            buffers.output = await this.createBuffer(this.device, sizes.output, BufferUsageType.STORAGE_WRITE_ONLY, {\n                label: 'neural_output',\n                persistent,\n                allowReuse\n            });\n            \n            // Create weight buffers with read-write access\n            buffers.weightsHidden = await this.createBuffer(this.device, sizes.weightsHidden, BufferUsageType.STORAGE_READ_WRITE, {\n                label: 'weights_hidden',\n                persistent: true, // Weights should persist\n                allowReuse\n            });\n            \n            buffers.weightsOutput = await this.createBuffer(this.device, sizes.weightsOutput, BufferUsageType.STORAGE_READ_WRITE, {\n                label: 'weights_output',\n                persistent: true,\n                allowReuse\n            });\n            \n            // Create bias buffers\n            buffers.biasHidden = await this.createBuffer(this.device, sizes.biasHidden, BufferUsageType.STORAGE_READ_WRITE, {\n                label: 'bias_hidden',\n                persistent: true,\n                allowReuse\n            });\n            \n            buffers.biasOutput = await this.createBuffer(this.device, sizes.biasOutput, BufferUsageType.STORAGE_READ_WRITE, {\n                label: 'bias_output',\n                persistent: true,\n                allowReuse\n            });\n            \n            // Create uniform buffers for parameters\n            buffers.matmulParams = await this.createBuffer(this.device, 16, BufferUsageType.UNIFORM, {\n                label: 'matmul_params',\n                persistent,\n                allowReuse\n            });\n            \n            buffers.activationParams = await this.createBuffer(this.device, 16, BufferUsageType.UNIFORM, {\n                label: 'activation_params',\n                persistent,\n                allowReuse\n            });\n            \n            // Create staging buffers for efficient CPU-GPU data transfer\n            buffers.stagingInput = await this.createBuffer(this.device, sizes.input, BufferUsageType.STAGING_UPLOAD, {\n                label: 'staging_input',\n                persistent: false,\n                allowReuse: true\n            });\n            \n            buffers.stagingOutput = await this.createBuffer(this.device, sizes.output, BufferUsageType.STAGING_DOWNLOAD, {\n                label: 'staging_output',\n                persistent: false,\n                allowReuse: true\n            });\n            \n            // Create buffers for training (Q-learning) with batch support\n            if (batchSize > 1) {\n                buffers.qValues = await this.createBuffer(this.device, sizes.qValues, BufferUsageType.STORAGE_READ_WRITE, {\n                    label: `q_values_batch_${batchSize}`,\n                    persistent,\n                    allowReuse\n                });\n                \n                buffers.targetQValues = await this.createBuffer(this.device, sizes.qValues, BufferUsageType.STORAGE_READ_WRITE, {\n                    label: `target_q_values_batch_${batchSize}`,\n                    persistent,\n                    allowReuse\n                });\n                \n                buffers.actions = await this.createBuffer(this.device, batchSize * 4, BufferUsageType.STORAGE_READ_ONLY, {\n                    label: `actions_batch_${batchSize}`,\n                    persistent,\n                    allowReuse\n                });\n                \n                buffers.rewards = await this.createBuffer(this.device, batchSize * 4, BufferUsageType.STORAGE_READ_ONLY, {\n                    label: `rewards_batch_${batchSize}`,\n                    persistent,\n                    allowReuse\n                });\n                \n                buffers.dones = await this.createBuffer(this.device, batchSize * 4, BufferUsageType.STORAGE_READ_ONLY, {\n                    label: `dones_batch_${batchSize}`,\n                    persistent,\n                    allowReuse\n                });\n                \n                buffers.tdErrors = await this.createBuffer(this.device, batchSize * 4, BufferUsageType.STORAGE_WRITE_ONLY, {\n                    label: `td_errors_batch_${batchSize}`,\n                    persistent,\n                    allowReuse\n                });\n                \n                buffers.qlearningParams = await this.createBuffer(this.device, 32, BufferUsageType.UNIFORM, {\n                    label: `qlearning_params_batch_${batchSize}`,\n                    persistent,\n                    allowReuse\n                });\n            }\n            \n            // Store named buffer references\n            Object.entries(buffers).forEach(([name, buffer]) => {\n                this.buffers.set(name, buffer);\n            });\n            \n            const creationTime = performance.now() - startTime;\n            const bufferCount = Object.keys(buffers).length;\n            const totalMemory = this.memoryUsage.totalAllocated;\n            \n            console.log(`Created ${bufferCount} enhanced buffers in ${creationTime.toFixed(2)}ms`);\n            console.log(`Total memory allocated: ${this._formatBytes(totalMemory)}`);\n            console.log(`Buffer pool stats: ${this.poolStats.hits} hits, ${this.poolStats.misses} misses`);\n            \n            return buffers;\n            \n        } catch (error) {\n            this._handleError('Failed to create network buffers', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Calculate required buffer sizes for architecture with enhanced validation\n     * @private\n     */\n    _calculateBufferSizes(architecture) {\n        const { inputSize, hiddenSize, outputSize, batchSize = 1 } = architecture;\n        \n        // Validate architecture parameters\n        if (!inputSize || !hiddenSize || !outputSize || !batchSize) {\n            throw new Error('Invalid architecture: all sizes must be positive');\n        }\n        \n        if (batchSize > 1024) {\n            console.warn(`Large batch size ${batchSize} detected, may impact performance`);\n        }\n        \n        const bytesPerFloat = 4;\n        const sizes = {};\n        \n        // Layer data sizes (with batch dimension)\n        sizes.input = this._alignSize(batchSize * inputSize * bytesPerFloat);\n        sizes.hidden = this._alignSize(batchSize * hiddenSize * bytesPerFloat);\n        sizes.output = this._alignSize(batchSize * outputSize * bytesPerFloat);\n        \n        // Weight matrix sizes\n        sizes.weightsHidden = this._alignSize(inputSize * hiddenSize * bytesPerFloat);\n        sizes.weightsOutput = this._alignSize(hiddenSize * outputSize * bytesPerFloat);\n        \n        // Bias vector sizes\n        sizes.biasHidden = this._alignSize(hiddenSize * bytesPerFloat);\n        sizes.biasOutput = this._alignSize(outputSize * bytesPerFloat);\n        \n        // Training-specific sizes\n        sizes.qValues = this._alignSize(batchSize * outputSize * bytesPerFloat);\n        \n        // Calculate total memory requirement\n        const totalMemory = Object.values(sizes).reduce((sum, size) => sum + size, 0);\n        \n        if (this.validationEnabled && totalMemory > this.config.maxTotalMemory) {\n            throw new Error(`Total buffer memory ${this._formatBytes(totalMemory)} exceeds limit ${this._formatBytes(this.config.maxTotalMemory)}`);\n        }\n        \n        console.log(`Calculated buffer sizes for ${inputSize}-${hiddenSize}-${outputSize} (batch: ${batchSize}):`);\n        Object.entries(sizes).forEach(([name, size]) => {\n            console.log(`  ${name}: ${this._formatBytes(size)}`);\n        });\n        console.log(`  Total: ${this._formatBytes(totalMemory)}`);\n        \n        return sizes;\n    }\n\n    /**\n     * Align buffer size to device requirements\n     * @private\n     */\n    _alignSize(size) {\n        return Math.ceil(size / this.alignment) * this.alignment;\n    }\n\n    /**\n     * Create a GPU buffer with specified parameters\n     * @private\n     */\n    _createBuffer(name, size, usage) {\n        const startTime = performance.now();\n        \n        if (size > this.maxBufferSize) {\n            throw new Error(`Buffer ${name} size ${size} exceeds maximum ${this.maxBufferSize}`);\n        }\n        \n        const buffer = this.device.createBuffer({\n            label: `neural_network_${name}`,\n            size: size,\n            usage: usage\n        });\n        \n        // Store buffer reference and size\n        this.buffers.set(name, buffer);\n        this.bufferSizes.set(name, size);\n        this.totalMemoryUsed += size;\n        \n        const creationTime = performance.now() - startTime;\n        this.bufferCreationTimes.push(creationTime);\n        \n        console.log(`Created buffer ${name}: ${this._formatBytes(size)}, usage: ${this._formatUsage(usage)}`);\n        \n        return buffer;\n    }\n\n    /**\n     * Create bind groups for shader operations\n     * @param {Object} buffers - Buffer references\n     * @param {Object} layouts - Bind group layouts from ShaderManager\n     * @returns {Object} Created bind groups\n     */\n    createBindGroups(buffers, layouts) {\n        const bindGroups = {};\n        \n        // Matrix multiplication bind group\n        bindGroups.matmul = this.device.createBindGroup({\n            label: 'matmul_bind_group',\n            layout: layouts.matmul,\n            entries: [\n                { binding: 0, resource: { buffer: buffers.input } },\n                { binding: 1, resource: { buffer: buffers.weightsHidden } },\n                { binding: 2, resource: { buffer: buffers.biasHidden } },\n                { binding: 3, resource: { buffer: buffers.hidden } },\n                { binding: 4, resource: { buffer: buffers.matmulParams } }\n            ]\n        });\n        \n        // Activation function bind group\n        bindGroups.activation = this.device.createBindGroup({\n            label: 'activation_bind_group',\n            layout: layouts.activation,\n            entries: [\n                { binding: 0, resource: { buffer: buffers.hidden } },\n                { binding: 1, resource: { buffer: buffers.hidden } }, // In-place operation\n                { binding: 2, resource: { buffer: buffers.activationParams } }\n            ]\n        });\n        \n        // Output layer bind group\n        bindGroups.output = this.device.createBindGroup({\n            label: 'output_bind_group',\n            layout: layouts.matmul,\n            entries: [\n                { binding: 0, resource: { buffer: buffers.hidden } },\n                { binding: 1, resource: { buffer: buffers.weightsOutput } },\n                { binding: 2, resource: { buffer: buffers.biasOutput } },\n                { binding: 3, resource: { buffer: buffers.output } },\n                { binding: 4, resource: { buffer: buffers.matmulParams } }\n            ]\n        });\n        \n        // Q-learning bind group (if training buffers exist)\n        if (buffers.qValues) {\n            bindGroups.qlearning = this.device.createBindGroup({\n                label: 'qlearning_bind_group',\n                layout: layouts.qlearning,\n                entries: [\n                    { binding: 0, resource: { buffer: buffers.qValues } },\n                    { binding: 1, resource: { buffer: buffers.targetQValues } },\n                    { binding: 2, resource: { buffer: buffers.actions } },\n                    { binding: 3, resource: { buffer: buffers.rewards } },\n                    { binding: 4, resource: { buffer: buffers.dones } },\n                    { binding: 5, resource: { buffer: buffers.hidden } },\n                    { binding: 6, resource: { buffer: buffers.input } },\n                    { binding: 7, resource: { buffer: buffers.weightsHidden } },\n                    { binding: 8, resource: { buffer: buffers.biasHidden } },\n                    { binding: 9, resource: { buffer: buffers.weightsOutput } },\n                    { binding: 10, resource: { buffer: buffers.biasOutput } },\n                    { binding: 11, resource: { buffer: buffers.tdErrors } },\n                    { binding: 12, resource: { buffer: buffers.qlearningParams } }\n                ]\n            });\n        }\n        \n        // Store bind groups\n        Object.entries(bindGroups).forEach(([name, bindGroup]) => {\n            this.bindGroups.set(name, bindGroup);\n        });\n        \n        console.log(`Created ${Object.keys(bindGroups).length} bind groups`);\n        \n        return bindGroups;\n    }\n\n    /**\n     * Upload data to GPU buffer\n     * @param {string} bufferName - Name of the buffer\n     * @param {ArrayBuffer|TypedArray} data - Data to upload\n     * @param {number} offset - Offset in buffer (bytes)\n     */\n    async uploadData(bufferName, data, offset = 0) {\n        const startTime = performance.now();\n        \n        const buffer = this.buffers.get(bufferName);\n        if (!buffer) {\n            throw new Error(`Buffer ${bufferName} not found`);\n        }\n        \n        // Convert to Uint8Array if needed\n        let uint8Data;\n        if (data instanceof ArrayBuffer) {\n            uint8Data = new Uint8Array(data);\n        } else if (ArrayBuffer.isView(data)) {\n            uint8Data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n        } else {\n            throw new Error('Data must be ArrayBuffer or TypedArray');\n        }\n        \n        // Write data to buffer\n        this.device.queue.writeBuffer(buffer, offset, uint8Data);\n        \n        const transferTime = performance.now() - startTime;\n        this.memoryTransferTimes.push(transferTime);\n        \n        console.log(`Uploaded ${this._formatBytes(uint8Data.length)} to ${bufferName} in ${transferTime.toFixed(2)}ms`);\n    }\n\n    /**\n     * Download data from GPU buffer\n     * @param {string} bufferName - Name of the buffer\n     * @param {number} size - Size to read (bytes)\n     * @param {number} offset - Offset in buffer (bytes)\n     * @returns {Promise<ArrayBuffer>} Downloaded data\n     */\n    async downloadData(bufferName, size, offset = 0) {\n        const startTime = performance.now();\n        \n        const buffer = this.buffers.get(bufferName);\n        if (!buffer) {\n            throw new Error(`Buffer ${bufferName} not found`);\n        }\n        \n        // Create a staging buffer for reading\n        const stagingBuffer = this.device.createBuffer({\n            label: `staging_${bufferName}_read`,\n            size: size,\n            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\n        });\n        \n        // Copy data to staging buffer\n        const commandEncoder = this.device.createCommandEncoder({\n            label: `copy_${bufferName}_to_staging`\n        });\n        \n        commandEncoder.copyBufferToBuffer(buffer, offset, stagingBuffer, 0, size);\n        \n        const commands = commandEncoder.finish();\n        this.device.queue.submit([commands]);\n        \n        // Map and read data\n        await stagingBuffer.mapAsync(GPUMapMode.READ);\n        const arrayBuffer = stagingBuffer.getMappedRange().slice();\n        stagingBuffer.unmap();\n        stagingBuffer.destroy();\n        \n        const transferTime = performance.now() - startTime;\n        this.memoryTransferTimes.push(transferTime);\n        \n        console.log(`Downloaded ${this._formatBytes(size)} from ${bufferName} in ${transferTime.toFixed(2)}ms`);\n        \n        return arrayBuffer;\n    }\n\n    /**\n     * Update uniform buffer with parameters\n     * @param {string} bufferName - Name of uniform buffer\n     * @param {Object} params - Parameters to upload\n     */\n    updateUniformBuffer(bufferName, params) {\n        const buffer = this.buffers.get(bufferName);\n        if (!buffer) {\n            throw new Error(`Uniform buffer ${bufferName} not found`);\n        }\n        \n        // Convert parameters to appropriate format\n        let data;\n        if (bufferName === 'matmulParams') {\n            // Matrix multiplication parameters: M, K, N, padding\n            data = new Uint32Array([params.M || 0, params.K || 0, params.N || 0, 0]);\n        } else if (bufferName === 'activationParams') {\n            // Activation parameters: size, padding...\n            data = new Uint32Array([params.size || 0, 0, 0, 0]);\n        } else if (bufferName === 'qlearningParams') {\n            // Q-learning parameters: batch_size, input_size, hidden_size, output_size, learning_rate, gamma, epsilon, clip_grad_norm\n            data = new Float32Array([\n                params.batch_size || 1,\n                params.input_size || 2,\n                params.hidden_size || 8,\n                params.output_size || 3,\n                params.learning_rate || 0.01,\n                params.gamma || 0.99,\n                params.epsilon || 1e-8,\n                params.clip_grad_norm || 1.0\n            ]);\n        } else {\n            throw new Error(`Unknown uniform buffer format for ${bufferName}`);\n        }\n        \n        this.device.queue.writeBuffer(buffer, 0, data);\n    }\n\n    /**\n     * Get buffer by name\n     * @param {string} name - Buffer name\n     * @returns {GPUBuffer} The requested buffer\n     */\n    getBuffer(name) {\n        const buffer = this.buffers.get(name);\n        if (!buffer) {\n            throw new Error(`Buffer ${name} not found. Available buffers: ${Array.from(this.buffers.keys()).join(', ')}`);\n        }\n        return buffer;\n    }\n\n    /**\n     * Get bind group by name\n     * @param {string} name - Bind group name\n     * @returns {GPUBindGroup} The requested bind group\n     */\n    getBindGroup(name) {\n        const bindGroup = this.bindGroups.get(name);\n        if (!bindGroup) {\n            throw new Error(`Bind group ${name} not found. Available bind groups: ${Array.from(this.bindGroups.keys()).join(', ')}`);\n        }\n        return bindGroup;\n    }\n\n    /**\n     * Get memory usage statistics\n     * @returns {Object} Memory usage information\n     */\n    getMemoryUsage() {\n        const bufferInfo = Array.from(this.buffers.entries()).map(([name, buffer]) => ({\n            name,\n            size: this.bufferSizes.get(name),\n            sizeFormatted: this._formatBytes(this.bufferSizes.get(name))\n        }));\n\n        const avgCreationTime = this.bufferCreationTimes.length > 0\n            ? this.bufferCreationTimes.reduce((a, b) => a + b) / this.bufferCreationTimes.length\n            : 0;\n\n        const avgTransferTime = this.memoryTransferTimes.length > 0\n            ? this.memoryTransferTimes.reduce((a, b) => a + b) / this.memoryTransferTimes.length\n            : 0;\n\n        return {\n            totalMemoryUsed: this.totalMemoryUsed,\n            totalMemoryFormatted: this._formatBytes(this.totalMemoryUsed),\n            bufferCount: this.buffers.size,\n            bindGroupCount: this.bindGroups.size,\n            bufferInfo,\n            performance: {\n                avgCreationTime: avgCreationTime.toFixed(2) + 'ms',\n                avgTransferTime: avgTransferTime.toFixed(2) + 'ms',\n                totalCreations: this.bufferCreationTimes.length,\n                totalTransfers: this.memoryTransferTimes.length\n            }\n        };\n    }\n\n    /**\n     * Format buffer usage flags for display\n     * @private\n     */\n    _formatUsage(usage) {\n        const flags = [];\n        if (usage & GPUBufferUsage.VERTEX) flags.push('VERTEX');\n        if (usage & GPUBufferUsage.INDEX) flags.push('INDEX');\n        if (usage & GPUBufferUsage.UNIFORM) flags.push('UNIFORM');\n        if (usage & GPUBufferUsage.STORAGE) flags.push('STORAGE');\n        if (usage & GPUBufferUsage.COPY_SRC) flags.push('COPY_SRC');\n        if (usage & GPUBufferUsage.COPY_DST) flags.push('COPY_DST');\n        if (usage & GPUBufferUsage.MAP_READ) flags.push('MAP_READ');\n        if (usage & GPUBufferUsage.MAP_WRITE) flags.push('MAP_WRITE');\n        return flags.join(' | ');\n    }\n\n    /**\n     * Format byte size for display\n     * @private\n     */\n    _formatBytes(bytes) {\n        if (bytes === 0) return '0 B';\n        const k = 1024;\n        const sizes = ['B', 'KB', 'MB', 'GB'];\n        const i = Math.floor(Math.log(bytes) / Math.log(k));\n        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n    }\n\n    /**\n     * Clean up all buffers and resources\n     */\n    destroy() {\n        // Destroy all buffers\n        for (const [name, buffer] of this.buffers) {\n            try {\n                buffer.destroy();\n            } catch (error) {\n                console.warn(`Failed to destroy buffer ${name}:`, error);\n            }\n        }\n        \n        // Clear all maps\n        this.buffers.clear();\n        this.bindGroups.clear();\n        this.bufferPools.clear();\n        this.bufferSizes.clear();\n        \n        // Reset counters\n        this.totalMemoryUsed = 0;\n        this.bufferCreationTimes = [];\n        this.memoryTransferTimes = [];\n        \n        console.log('Buffer manager destroyed');\n    }\n}\n\n/**\n * Utility functions for buffer management\n */\n\n/**\n * Create a buffer with validation and error handling\n * @param {GPUDevice} device - WebGPU device\n * @param {ArrayBuffer|TypedArray|number} data - Data or size\n * @param {number} usage - Buffer usage flags\n * @param {Object} options - Creation options\n * @returns {Promise<GPUBuffer>} Created buffer\n */\nexport async function createBuffer(device, data, usage, options = {}) {\n    // Create a temporary buffer manager for standalone usage\n    const bufferManager = new BufferManager(device, {\n        enableValidation: options.enableValidation !== false,\n        enableProfiling: options.enableProfiling !== false\n    });\n    \n    try {\n        const buffer = await bufferManager.createBuffer(device, data, usage, options);\n        return buffer;\n    } finally {\n        // Clean up temporary buffer manager (but not the buffer)\n        bufferManager.buffers.clear();\n        bufferManager.bufferMetadata.clear();\n    }\n}\n\n/**\n * Update buffer data with efficient upload\n * @param {GPUQueue} queue - WebGPU queue\n * @param {GPUBuffer} buffer - Target buffer\n * @param {ArrayBuffer|TypedArray} data - Data to upload\n * @param {number} offset - Offset in buffer\n * @param {Object} options - Update options\n * @returns {Promise<void>}\n */\nexport async function updateBuffer(queue, buffer, data, offset = 0, options = {}) {\n    const startTime = performance.now();\n    \n    try {\n        // Convert data to Uint8Array\n        let uint8Data;\n        if (data instanceof ArrayBuffer) {\n            uint8Data = new Uint8Array(data);\n        } else if (ArrayBuffer.isView(data)) {\n            uint8Data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n        } else {\n            throw new Error('Data must be ArrayBuffer or TypedArray');\n        }\n        \n        // Use appropriate upload method based on size\n        if (uint8Data.length > 64 * 1024 && options.useStaging) {\n            // Use staging buffer for large uploads\n            const device = queue.getDevice ? queue.getDevice() : options.device;\n            if (!device) {\n                throw new Error('Device required for staging buffer operations');\n            }\n            \n            const stagingBuffer = device.createBuffer({\n                label: 'staging_upload',\n                size: uint8Data.length,\n                usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC\n            });\n            \n            await stagingBuffer.mapAsync(GPUMapMode.WRITE);\n            const mappedRange = new Uint8Array(stagingBuffer.getMappedRange());\n            mappedRange.set(uint8Data);\n            stagingBuffer.unmap();\n            \n            const commandEncoder = device.createCommandEncoder();\n            commandEncoder.copyBufferToBuffer(stagingBuffer, 0, buffer, offset, uint8Data.length);\n            queue.submit([commandEncoder.finish()]);\n            \n            stagingBuffer.destroy();\n        } else {\n            // Direct upload for smaller data\n            queue.writeBuffer(buffer, offset, uint8Data);\n        }\n        \n        const transferTime = performance.now() - startTime;\n        \n        if (options.enableProfiling) {\n            console.log(`Buffer update: ${(uint8Data.length / 1024).toFixed(2)}KB in ${transferTime.toFixed(2)}ms`);\n        }\n        \n    } catch (error) {\n        console.error('Failed to update buffer:', error);\n        throw error;\n    }\n}\n\n/**\n * Read buffer data with async operations\n * @param {GPUDevice} device - WebGPU device\n * @param {GPUBuffer} buffer - Source buffer\n * @param {number} size - Size to read\n * @param {number} offset - Offset in buffer\n * @param {Object} options - Read options\n * @returns {Promise<ArrayBuffer>} Downloaded data\n */\nexport async function readBuffer(device, buffer, size, offset = 0, options = {}) {\n    const startTime = performance.now();\n    \n    try {\n        // Create staging buffer for reading\n        const stagingBuffer = device.createBuffer({\n            label: 'staging_download',\n            size: size,\n            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\n        });\n        \n        // Copy data to staging buffer\n        const commandEncoder = device.createCommandEncoder();\n        commandEncoder.copyBufferToBuffer(buffer, offset, stagingBuffer, 0, size);\n        device.queue.submit([commandEncoder.finish()]);\n        \n        // Map and read data\n        await stagingBuffer.mapAsync(GPUMapMode.READ);\n        const arrayBuffer = stagingBuffer.getMappedRange().slice();\n        stagingBuffer.unmap();\n        stagingBuffer.destroy();\n        \n        const transferTime = performance.now() - startTime;\n        \n        if (options.enableProfiling) {\n            console.log(`Buffer read: ${(size / 1024).toFixed(2)}KB in ${transferTime.toFixed(2)}ms`);\n        }\n        \n        return arrayBuffer;\n        \n    } catch (error) {\n        console.error('Failed to read buffer:', error);\n        throw error;\n    }\n}\n\n/**\n * Validate buffer operations for safety\n * @param {GPUBuffer} buffer - Buffer to validate\n * @param {number} size - Operation size\n * @param {number} offset - Operation offset\n * @throws {Error} If validation fails\n */\nexport function validateBufferOperation(buffer, size, offset = 0) {\n    if (!buffer) {\n        throw new Error('Buffer is null or undefined');\n    }\n    \n    if (size <= 0) {\n        throw new Error(`Invalid size: ${size}`);\n    }\n    \n    if (offset < 0) {\n        throw new Error(`Invalid offset: ${offset}`);\n    }\n    \n    // Note: We can't check buffer.size directly as it's not exposed in WebGPU API\n    // Size validation should be done by the BufferManager that tracks metadata\n}","/**\n * WebGPU Neural Network Implementation with Compute Shaders\n * \n * Complete GPU-accelerated neural network implementation using WGSL compute shaders\n * for the two-wheel balancing robot RL application. This replaces the placeholder\n * implementation in the main WebGPUBackend.js file.\n */\n\nimport { ShaderManager } from './ShaderManager.js';\nimport { BufferManager, BufferUsageType } from './BufferManager.js';\nimport { validateArchitecture, calculateParameterCount } from '../NeuralNetwork.js';\n\n/**\n * GPU-accelerated neural network using WebGPU compute shaders\n */\nexport class WebGPUNeuralNetwork {\n    constructor(device) {\n        this.device = device;\n        this.shaderManager = null;\n        this.bufferManager = null;\n        \n        // Network architecture\n        this.inputSize = 0;\n        this.hiddenSize = 0;\n        this.outputSize = 0;\n        \n        // GPU resources\n        this.buffers = null;\n        this.bindGroups = null;\n        \n        // State tracking\n        this.isInitialized = false;\n        this.weightsInitialized = false;\n        \n        // Performance tracking\n        this.forwardPassTimes = [];\n        this.gpuMemoryUsed = 0;\n        \n        // Async operation management\n        this.pendingOperations = new Map();\n        this.operationCounter = 0;\n        this.maxConcurrentOps = 4;\n        this.asyncQueue = [];\n        \n        // Error handling and recovery\n        this.errorCount = 0;\n        this.maxErrors = 10;\n        this.lastError = null;\n        this.errorLog = [];\n        \n        // Batch buffer caching\n        this._batchBufferCache = new Map();\n        this._batchBindGroupCache = new Map();\n        \n        // Operation timeouts\n        this.operationTimeout = 30000; // 30 seconds\n        this.activeTimeouts = new Map();\n    }\n\n    /**\n     * Initialize the neural network with GPU resources\n     * @param {number} inputSize - Input layer size (2)\n     * @param {number} hiddenSize - Hidden layer size (4-16)\n     * @param {number} outputSize - Output layer size (3)\n     * @param {Object} options - Configuration options\n     */\n    async initialize(inputSize, hiddenSize, outputSize, options = {}) {\n        console.log('Initializing WebGPU neural network...');\n        \n        // Validate architecture\n        validateArchitecture(inputSize, hiddenSize, outputSize);\n        \n        this.inputSize = inputSize;\n        this.hiddenSize = hiddenSize;\n        this.outputSize = outputSize;\n        \n        // Initialize shader and buffer managers with enhanced configuration\n        this.shaderManager = new ShaderManager(this.device);\n        this.bufferManager = new BufferManager(this.device, {\n            maxBufferSize: 1024 * 1024 * 16, // 16MB max per buffer\n            maxTotalMemory: 1024 * 1024 * 256, // 256MB total limit\n            poolEnabled: true,\n            poolMaxAge: 60000, // 1 minute\n            poolMaxSize: 20,\n            enableValidation: true,\n            enableProfiling: true\n        });\n        \n        try {\n            // Load and compile shaders\n            await this.shaderManager.loadShaders();\n            \n            // Create buffers for network with enhanced features\n            const architecture = { inputSize, hiddenSize, outputSize, batchSize: 1 };\n            this.buffers = await this.bufferManager.createNetworkBuffers(architecture, {\n                persistent: true, // Keep weights persistent\n                allowReuse: true  // Allow buffer reuse from pool\n            });\n            \n            // Create specialized bind groups for each layer\n            await this._createBindGroups();\n            \n            // Initialize weights\n            await this.initializeWeights(options.initMethod || 'xavier', options.seed);\n            \n            this.isInitialized = true;\n            const memoryUsage = this.bufferManager.getMemoryUsage();\n            this.gpuMemoryUsed = memoryUsage.memory.totalActive;\n            \n            console.log(`WebGPU neural network initialized: ${inputSize}-${hiddenSize}-${outputSize}`);\n            console.log(`GPU memory used: ${memoryUsage.memory.totalActiveFormatted}`);\n            console.log(`Buffer pool efficiency: ${memoryUsage.pool.hitRate} hit rate`);\n            \n        } catch (error) {\n            console.error('Failed to initialize WebGPU neural network:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Initialize network weights using specified method\n     * @param {string} method - Initialization method ('xavier', 'he', 'random')\n     * @param {number} seed - Random seed for reproducible initialization\n     */\n    async initializeWeights(method = 'xavier', seed = null) {\n        if (seed !== null) {\n            // Note: WebGPU doesn't have built-in seeded random, so we use CPU generation\n            console.log(`Initializing weights with ${method} method, seed: ${seed}`);\n        }\n\n        // Generate weights on CPU (for deterministic initialization)\n        const weightsHidden = this._generateWeights(this.inputSize, this.hiddenSize, method, seed);\n        const biasHidden = this._generateBias(this.hiddenSize);\n        const weightsOutput = this._generateWeights(this.hiddenSize, this.outputSize, method, seed ? seed + 1 : null);\n        const biasOutput = this._generateBias(this.outputSize);\n\n        // Upload weights to GPU using enhanced buffer operations\n        await this.bufferManager.updateBuffer(\n            this.device.queue, \n            this.buffers.weightsHidden, \n            weightsHidden, \n            0, \n            { label: 'init_weights_hidden' }\n        );\n        await this.bufferManager.updateBuffer(\n            this.device.queue, \n            this.buffers.biasHidden, \n            biasHidden, \n            0, \n            { label: 'init_bias_hidden' }\n        );\n        await this.bufferManager.updateBuffer(\n            this.device.queue, \n            this.buffers.weightsOutput, \n            weightsOutput, \n            0, \n            { label: 'init_weights_output' }\n        );\n        await this.bufferManager.updateBuffer(\n            this.device.queue, \n            this.buffers.biasOutput, \n            biasOutput, \n            0, \n            { label: 'init_bias_output' }\n        );\n\n        this.weightsInitialized = true;\n        console.log('Weights initialized and uploaded to GPU');\n    }\n\n    /**\n     * Generate weight matrix using specified initialization method\n     * @private\n     */\n    _generateWeights(inputSize, outputSize, method, seed) {\n        const size = inputSize * outputSize;\n        const weights = new Float32Array(size);\n        \n        // Simple random number generator for seeded initialization\n        let random = seed ? this._seededRandom(seed) : Math.random;\n        \n        switch (method) {\n            case 'xavier':\n                const xavierStd = Math.sqrt(2.0 / (inputSize + outputSize));\n                for (let i = 0; i < size; i++) {\n                    weights[i] = (random() - 0.5) * 2 * xavierStd;\n                }\n                break;\n                \n            case 'he':\n                const heStd = Math.sqrt(2.0 / inputSize);\n                for (let i = 0; i < size; i++) {\n                    weights[i] = this._boxMuller() * heStd;\n                }\n                break;\n                \n            default: // random\n                for (let i = 0; i < size; i++) {\n                    weights[i] = (random() - 0.5) * 0.1;\n                }\n        }\n        \n        return weights;\n    }\n\n    /**\n     * Generate bias vector\n     * @private\n     */\n    _generateBias(size) {\n        return new Float32Array(size).fill(0.01);\n    }\n\n    /**\n     * Simple seeded random number generator\n     * @private\n     */\n    _seededRandom(seed) {\n        let s = seed;\n        return function() {\n            s = (s * 1664525 + 1013904223) % 4294967296;\n            return s / 4294967296;\n        };\n    }\n\n    /**\n     * Box-Muller transform for normal distribution\n     * @private\n     */\n    _boxMuller() {\n        const u1 = Math.random();\n        const u2 = Math.random();\n        return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\n    }\n\n    /**\n     * Perform forward pass through the network\n     * @param {Float32Array} input - Input values [angle, angular_velocity]\n     * @returns {Promise<Float32Array>} Output action probabilities [left, right, brake]\n     */\n    async forward(input) {\n        if (!this.isInitialized) {\n            throw new Error('Neural network not initialized');\n        }\n\n        if (input.length !== this.inputSize) {\n            throw new Error(`Input size mismatch. Expected ${this.inputSize}, got ${input.length}`);\n        }\n\n        const startTime = performance.now();\n\n        try {\n            // Upload input data to GPU using enhanced buffer operations\n            await this.bufferManager.updateBuffer(\n                this.device.queue, \n                this.buffers.input, \n                input, \n                0, \n                { label: 'forward_input' }\n            );\n\n            // Execute forward pass on GPU\n            await this._executeForwardPass();\n\n            // Download output from GPU using enhanced buffer operations\n            const outputBuffer = await this.bufferManager.readBuffer(\n                this.device, \n                this.buffers.output, \n                this.outputSize * 4, \n                0, \n                { label: 'forward_output' }\n            );\n            const output = new Float32Array(outputBuffer);\n\n            // Track performance\n            const forwardTime = performance.now() - startTime;\n            this.forwardPassTimes.push(forwardTime);\n            \n            // Keep only recent timing history\n            if (this.forwardPassTimes.length > 100) {\n                this.forwardPassTimes.shift();\n            }\n\n            return output;\n\n        } catch (error) {\n            console.error('Forward pass failed:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Execute forward pass using GPU compute shaders with proper synchronization\n     * @private\n     */\n    async _executeForwardPass() {\n        try {\n            // Create command encoder for the entire forward pass sequence\n            const commandEncoder = this.device.createCommandEncoder({\n                label: 'neural_network_forward_pass'\n            });\n            \n            const passEncoder = commandEncoder.beginComputePass({\n                label: 'forward_pass_compute',\n                timestampWrites: this.device.features.has('timestamp-query') ? {\n                    querySet: null, // Would be set up for performance monitoring\n                    beginningOfPassWriteIndex: undefined,\n                    endOfPassWriteIndex: undefined\n                } : undefined\n            });\n\n            // Step 1: Input to hidden layer (matrix multiplication + bias)\n            // Update parameters for hidden layer computation\n            const hiddenParams = new Uint32Array([1, this.inputSize, this.hiddenSize, 0]);\n            this.device.queue.writeBuffer(this.buffers.matmulParams, 0, hiddenParams);\n            \n            passEncoder.setPipeline(this.shaderManager.getPipeline('matmul_simple'));\n            passEncoder.setBindGroup(0, this.bindGroups.matmulHidden);\n            passEncoder.dispatchWorkgroups(Math.ceil((1 * this.hiddenSize) / 64));\n\n            // Step 2: ReLU activation on hidden layer\n            // Update parameters for activation function\n            const activationParams = new Uint32Array([this.hiddenSize, 0, 0, 0]);\n            this.device.queue.writeBuffer(this.buffers.activationParams, 0, activationParams);\n            \n            passEncoder.setPipeline(this.shaderManager.getPipeline('relu'));\n            passEncoder.setBindGroup(0, this.bindGroups.activation);\n            passEncoder.dispatchWorkgroups(Math.ceil(this.hiddenSize / 64));\n\n            // Step 3: Hidden to output layer (matrix multiplication + bias)\n            // Update parameters for output layer computation\n            const outputParams = new Uint32Array([1, this.hiddenSize, this.outputSize, 0]);\n            this.device.queue.writeBuffer(this.buffers.matmulParams, 0, outputParams);\n            \n            passEncoder.setPipeline(this.shaderManager.getPipeline('matmul_simple'));\n            passEncoder.setBindGroup(0, this.bindGroups.matmulOutput);\n            passEncoder.dispatchWorkgroups(Math.ceil((1 * this.outputSize) / 64));\n\n            // End compute pass\n            passEncoder.end();\n\n            // Submit all commands in a single batch for optimal GPU utilization\n            const commandBuffer = commandEncoder.finish();\n            this.device.queue.submit([commandBuffer]);\n            \n            // Wait for all GPU operations to complete\n            await this.device.queue.onSubmittedWorkDone();\n            \n        } catch (error) {\n            console.error('Forward pass execution failed:', error);\n            throw new Error(`GPU forward pass failed: ${error.message}`);\n        }\n    }\n\n    /**\n     * Perform batch forward pass for training with optimized GPU utilization\n     * @param {Float32Array} batchInput - Batch of inputs [batchSize * inputSize]\n     * @param {number} batchSize - Number of samples in batch\n     * @param {Object} options - Batch processing options\n     * @param {boolean} options.reuseBuffers - Reuse existing batch buffers\n     * @param {boolean} options.async - Execute asynchronously\n     * @returns {Promise<Float32Array>} Batch output [batchSize * outputSize]\n     */\n    async forwardBatch(batchInput, batchSize, options = {}) {\n        const { reuseBuffers = true, async = false } = options;\n        \n        if (!this.isInitialized) {\n            throw new Error('Neural network not initialized');\n        }\n\n        if (batchInput.length !== batchSize * this.inputSize) {\n            throw new Error(`Batch input size mismatch. Expected ${batchSize * this.inputSize}, got ${batchInput.length}`);\n        }\n\n        const startTime = performance.now();\n        const batchKey = `batch_${batchSize}`;\n\n        try {\n            // Get or create batch buffers\n            let batchBuffers = reuseBuffers ? this._batchBufferCache?.get(batchKey) : null;\n            let batchBindGroups = reuseBuffers ? this._batchBindGroupCache?.get(batchKey) : null;\n\n            if (!batchBuffers || !batchBindGroups) {\n                console.log(`Creating new batch buffers for batch size: ${batchSize}`);\n                \n                // Create buffers with batch dimension\n                const batchArchitecture = { \n                    inputSize: this.inputSize, \n                    hiddenSize: this.hiddenSize, \n                    outputSize: this.outputSize, \n                    batchSize \n                };\n                \n                batchBuffers = await this.bufferManager.createNetworkBuffers(batchArchitecture, {\n                    persistent: reuseBuffers, // Cache if reusing\n                    allowReuse: true\n                });\n\n                // Create specialized bind groups for batch processing\n                batchBindGroups = await this._createBatchBindGroups(batchBuffers, batchSize);\n\n                // Cache for reuse\n                if (reuseBuffers) {\n                    this._batchBufferCache = this._batchBufferCache || new Map();\n                    this._batchBindGroupCache = this._batchBindGroupCache || new Map();\n                    this._batchBufferCache.set(batchKey, batchBuffers);\n                    this._batchBindGroupCache.set(batchKey, batchBindGroups);\n                }\n            }\n\n            // Copy current weights to batch buffers if needed\n            await this._syncWeightsToBatchBuffers(batchBuffers);\n\n            // Upload batch input with optimized transfer\n            await this.bufferManager.updateBuffer(\n                this.device.queue, \n                batchBuffers.input, \n                batchInput, \n                0, \n                { \n                    label: 'batch_input', \n                    useStaging: batchInput.length > 64 * 1024 \n                }\n            );\n\n            // Execute optimized batch forward pass\n            if (async) {\n                // Fire and forget for high throughput training\n                this._executeBatchForwardPassAsync(batchSize, batchBindGroups, batchBuffers);\n                return null; // Caller must retrieve results separately\n            } else {\n                await this._executeBatchForwardPass(batchSize, batchBindGroups, batchBuffers);\n            }\n\n            // Download batch output\n            const outputBuffer = await this.bufferManager.readBuffer(\n                this.device, \n                batchBuffers.output, \n                batchSize * this.outputSize * 4, \n                0, \n                { label: 'batch_output' }\n            );\n            \n            const output = new Float32Array(outputBuffer);\n            \n            // Track batch performance\n            const batchTime = performance.now() - startTime;\n            console.log(`Batch forward (${batchSize}): ${batchTime.toFixed(2)}ms (${(batchTime/batchSize).toFixed(2)}ms per sample)`);\n            \n            return output;\n\n        } catch (error) {\n            console.error('Batch forward pass failed:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Synchronize current weights to batch buffers efficiently\n     * @private\n     */\n    async _syncWeightsToBatchBuffers(batchBuffers) {\n        try {\n            // Copy weights using GPU-to-GPU transfers for efficiency\n            const commandEncoder = this.device.createCommandEncoder({\n                label: 'weight_sync_to_batch'\n            });\n\n            // Copy hidden layer weights\n            commandEncoder.copyBufferToBuffer(\n                this.buffers.weightsHidden, 0,\n                batchBuffers.weightsHidden, 0,\n                this.inputSize * this.hiddenSize * 4\n            );\n\n            // Copy hidden layer biases\n            commandEncoder.copyBufferToBuffer(\n                this.buffers.biasHidden, 0,\n                batchBuffers.biasHidden, 0,\n                this.hiddenSize * 4\n            );\n\n            // Copy output layer weights\n            commandEncoder.copyBufferToBuffer(\n                this.buffers.weightsOutput, 0,\n                batchBuffers.weightsOutput, 0,\n                this.hiddenSize * this.outputSize * 4\n            );\n\n            // Copy output layer biases\n            commandEncoder.copyBufferToBuffer(\n                this.buffers.biasOutput, 0,\n                batchBuffers.biasOutput, 0,\n                this.outputSize * 4\n            );\n\n            // Submit copy operations\n            this.device.queue.submit([commandEncoder.finish()]);\n            \n            // Don't wait - subsequent operations will implicitly wait\n            \n        } catch (error) {\n            console.error('Weight synchronization failed:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Create specialized bind groups for batch processing\n     * @private\n     */\n    async _createBatchBindGroups(batchBuffers, batchSize) {\n        const layouts = {\n            matmul: this.shaderManager.getBindGroupLayout('matmul'),\n            activation: this.shaderManager.getBindGroupLayout('activation')\n        };\n\n        const bindGroups = {};\n\n        // Batch hidden layer matrix multiplication\n        bindGroups.matmulHidden = this.device.createBindGroup({\n            label: `batch_matmul_hidden_${batchSize}`,\n            layout: layouts.matmul,\n            entries: [\n                { binding: 0, resource: { buffer: batchBuffers.input } },\n                { binding: 1, resource: { buffer: batchBuffers.weightsHidden } },\n                { binding: 2, resource: { buffer: batchBuffers.biasHidden } },\n                { binding: 3, resource: { buffer: batchBuffers.hidden } },\n                { binding: 4, resource: { buffer: batchBuffers.matmulParams } }\n            ]\n        });\n\n        // Batch output layer matrix multiplication\n        bindGroups.matmulOutput = this.device.createBindGroup({\n            label: `batch_matmul_output_${batchSize}`,\n            layout: layouts.matmul,\n            entries: [\n                { binding: 0, resource: { buffer: batchBuffers.hidden } },\n                { binding: 1, resource: { buffer: batchBuffers.weightsOutput } },\n                { binding: 2, resource: { buffer: batchBuffers.biasOutput } },\n                { binding: 3, resource: { buffer: batchBuffers.output } },\n                { binding: 4, resource: { buffer: batchBuffers.matmulParams } }\n            ]\n        });\n\n        // Batch activation function\n        bindGroups.activation = this.device.createBindGroup({\n            label: `batch_activation_${batchSize}`,\n            layout: layouts.activation,\n            entries: [\n                { binding: 0, resource: { buffer: batchBuffers.hidden } },\n                { binding: 1, resource: { buffer: batchBuffers.hidden } }, // In-place operation\n                { binding: 2, resource: { buffer: batchBuffers.activationParams } }\n            ]\n        });\n\n        console.log(`Created batch bind groups for batch size: ${batchSize}`);\n        return bindGroups;\n    }\n\n    /**\n     * Execute optimized batch forward pass with proper GPU utilization\n     * @private\n     */\n    async _executeBatchForwardPass(batchSize, bindGroups, buffers) {\n        try {\n            const commandEncoder = this.device.createCommandEncoder({\n                label: `batch_forward_pass_${batchSize}`\n            });\n            \n            const passEncoder = commandEncoder.beginComputePass({\n                label: 'batch_forward_compute'\n            });\n\n            // Step 1: Input to hidden layer matrix multiplication\n            const hiddenParams = new Uint32Array([batchSize, this.inputSize, this.hiddenSize, 0]);\n            this.device.queue.writeBuffer(buffers.matmulParams, 0, hiddenParams);\n            \n            // Use batch-optimized pipeline if available\n            if (this.shaderManager.computePipelines.has('matmul_batch')) {\n                passEncoder.setPipeline(this.shaderManager.getPipeline('matmul_batch'));\n                passEncoder.setBindGroup(0, bindGroups.matmulHidden);\n                // Optimal workgroup dispatch for batch processing\n                passEncoder.dispatchWorkgroups(\n                    Math.ceil(this.hiddenSize / 8),\n                    Math.ceil(batchSize / 8),\n                    1\n                );\n            } else {\n                // Fallback to simple implementation\n                passEncoder.setPipeline(this.shaderManager.getPipeline('matmul_simple'));\n                passEncoder.setBindGroup(0, bindGroups.matmulHidden);\n                passEncoder.dispatchWorkgroups(Math.ceil(batchSize * this.hiddenSize / 64));\n            }\n\n            // Step 2: Batch ReLU activation on hidden layer\n            const activationParams = new Uint32Array([batchSize * this.hiddenSize, 0, 0, 0]);\n            this.device.queue.writeBuffer(buffers.activationParams, 0, activationParams);\n            \n            passEncoder.setPipeline(this.shaderManager.getPipeline('relu'));\n            passEncoder.setBindGroup(0, bindGroups.activation);\n            passEncoder.dispatchWorkgroups(Math.ceil(batchSize * this.hiddenSize / 64));\n\n            // Step 3: Hidden to output layer matrix multiplication\n            const outputParams = new Uint32Array([batchSize, this.hiddenSize, this.outputSize, 0]);\n            this.device.queue.writeBuffer(buffers.matmulParams, 0, outputParams);\n            \n            if (this.shaderManager.computePipelines.has('matmul_batch')) {\n                passEncoder.setPipeline(this.shaderManager.getPipeline('matmul_batch'));\n                passEncoder.setBindGroup(0, bindGroups.matmulOutput);\n                passEncoder.dispatchWorkgroups(\n                    Math.ceil(this.outputSize / 8),\n                    Math.ceil(batchSize / 8),\n                    1\n                );\n            } else {\n                passEncoder.setPipeline(this.shaderManager.getPipeline('matmul_simple'));\n                passEncoder.setBindGroup(0, bindGroups.matmulOutput);\n                passEncoder.dispatchWorkgroups(Math.ceil(batchSize * this.outputSize / 64));\n            }\n\n            passEncoder.end();\n            \n            // Submit command buffer\n            const commandBuffer = commandEncoder.finish();\n            this.device.queue.submit([commandBuffer]);\n            \n            // Wait for completion\n            await this.device.queue.onSubmittedWorkDone();\n            \n        } catch (error) {\n            console.error('Batch forward pass execution failed:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Execute asynchronous batch forward pass for high-throughput training\n     * @private\n     */\n    async _executeBatchForwardPassAsync(batchSize, bindGroups, buffers) {\n        try {\n            const commandEncoder = this.device.createCommandEncoder({\n                label: `async_batch_forward_${batchSize}`\n            });\n            \n            const passEncoder = commandEncoder.beginComputePass({\n                label: 'async_batch_compute'\n            });\n\n            // Same operations as synchronous version but no await\n            const hiddenParams = new Uint32Array([batchSize, this.inputSize, this.hiddenSize, 0]);\n            this.device.queue.writeBuffer(buffers.matmulParams, 0, hiddenParams);\n            \n            passEncoder.setPipeline(this.shaderManager.getPipeline('matmul_simple'));\n            passEncoder.setBindGroup(0, bindGroups.matmulHidden);\n            passEncoder.dispatchWorkgroups(Math.ceil(batchSize * this.hiddenSize / 64));\n\n            const activationParams = new Uint32Array([batchSize * this.hiddenSize, 0, 0, 0]);\n            this.device.queue.writeBuffer(buffers.activationParams, 0, activationParams);\n            \n            passEncoder.setPipeline(this.shaderManager.getPipeline('relu'));\n            passEncoder.setBindGroup(0, bindGroups.activation);\n            passEncoder.dispatchWorkgroups(Math.ceil(batchSize * this.hiddenSize / 64));\n\n            const outputParams = new Uint32Array([batchSize, this.hiddenSize, this.outputSize, 0]);\n            this.device.queue.writeBuffer(buffers.matmulParams, 0, outputParams);\n            \n            passEncoder.setPipeline(this.shaderManager.getPipeline('matmul_simple'));\n            passEncoder.setBindGroup(0, bindGroups.matmulOutput);\n            passEncoder.dispatchWorkgroups(Math.ceil(batchSize * this.outputSize / 64));\n\n            passEncoder.end();\n            \n            // Submit without waiting - fire and forget\n            this.device.queue.submit([commandEncoder.finish()]);\n            \n        } catch (error) {\n            console.error('Async batch forward pass failed:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Get current network weights\n     * @returns {Promise<Object>} Object containing weights and biases\n     */\n    async getWeights() {\n        if (!this.isInitialized) {\n            throw new Error('Neural network not initialized');\n        }\n\n        // Download weights from GPU using enhanced buffer operations\n        const weightsHiddenBuffer = await this.bufferManager.readBuffer(\n            this.device, this.buffers.weightsHidden, this.inputSize * this.hiddenSize * 4, 0, \n            { label: 'get_weights_hidden' }\n        );\n        const biasHiddenBuffer = await this.bufferManager.readBuffer(\n            this.device, this.buffers.biasHidden, this.hiddenSize * 4, 0, \n            { label: 'get_bias_hidden' }\n        );\n        const weightsOutputBuffer = await this.bufferManager.readBuffer(\n            this.device, this.buffers.weightsOutput, this.hiddenSize * this.outputSize * 4, 0, \n            { label: 'get_weights_output' }\n        );\n        const biasOutputBuffer = await this.bufferManager.readBuffer(\n            this.device, this.buffers.biasOutput, this.outputSize * 4, 0, \n            { label: 'get_bias_output' }\n        );\n\n        return {\n            weightsHidden: new Float32Array(weightsHiddenBuffer),\n            biasHidden: new Float32Array(biasHiddenBuffer),\n            weightsOutput: new Float32Array(weightsOutputBuffer),\n            biasOutput: new Float32Array(biasOutputBuffer)\n        };\n    }\n\n    /**\n     * Set network weights\n     * @param {Object} weights - Object containing weights and biases\n     */\n    async setWeights(weights) {\n        if (!this.isInitialized) {\n            throw new Error('Neural network not initialized');\n        }\n\n        // Upload new weights to GPU using enhanced buffer operations\n        await this.bufferManager.updateBuffer(\n            this.device.queue, this.buffers.weightsHidden, weights.weightsHidden, 0, \n            { label: 'set_weights_hidden' }\n        );\n        await this.bufferManager.updateBuffer(\n            this.device.queue, this.buffers.biasHidden, weights.biasHidden, 0, \n            { label: 'set_bias_hidden' }\n        );\n        await this.bufferManager.updateBuffer(\n            this.device.queue, this.buffers.weightsOutput, weights.weightsOutput, 0, \n            { label: 'set_weights_output' }\n        );\n        await this.bufferManager.updateBuffer(\n            this.device.queue, this.buffers.biasOutput, weights.biasOutput, 0, \n            { label: 'set_bias_output' }\n        );\n\n        this.weightsInitialized = true;\n        console.log('Weights updated on GPU');\n    }\n\n    /**\n     * Get network architecture information\n     * @returns {Object} Architecture details\n     */\n    getArchitecture() {\n        return {\n            inputSize: this.inputSize,\n            hiddenSize: this.hiddenSize,\n            outputSize: this.outputSize,\n            parameterCount: calculateParameterCount(this.inputSize, this.hiddenSize, this.outputSize),\n            backend: 'webgpu',\n            isInitialized: this.isInitialized,\n            weightsInitialized: this.weightsInitialized\n        };\n    }\n\n    /**\n     * Get comprehensive performance metrics including enhanced buffer management\n     * @returns {Object} Performance statistics\n     */\n    getPerformanceMetrics() {\n        const forwardTimes = this.forwardPassTimes;\n        const avgForwardTime = forwardTimes.length > 0 \n            ? forwardTimes.reduce((a, b) => a + b) / forwardTimes.length \n            : 0;\n\n        const bufferMetrics = this.bufferManager ? this.bufferManager.getMemoryUsage() : null;\n        const bufferPerformance = this.bufferManager ? this.bufferManager.getPerformanceMetrics() : null;\n\n        return {\n            // Neural network metrics\n            averageForwardTime: avgForwardTime,\n            totalForwardPasses: forwardTimes.length,\n            gpuMemoryUsed: this.gpuMemoryUsed,\n            \n            // Enhanced buffer management metrics\n            bufferManager: bufferMetrics ? {\n                memory: bufferMetrics.memory,\n                buffers: bufferMetrics.buffers,\n                pool: bufferMetrics.pool,\n                performance: bufferMetrics.performance,\n                config: bufferMetrics.config\n            } : null,\n            \n            // Detailed buffer performance\n            bufferPerformance: bufferPerformance ? {\n                bufferCreation: bufferPerformance.bufferCreation,\n                memoryTransfer: bufferPerformance.memoryTransfer,\n                mapping: bufferPerformance.mapping,\n                asyncOperations: bufferPerformance.asyncOperations,\n                errors: bufferPerformance.errors\n            } : null,\n            \n            // Shader manager metrics\n            shaderManager: this.shaderManager ? this.shaderManager.getPerformanceMetrics() : null,\n            \n            // Async operation metrics\n            asyncOperations: this.getAsyncStatus(),\n            \n            // Overall system efficiency\n            efficiency: {\n                bufferPoolHitRate: bufferMetrics ? bufferMetrics.pool.hitRate : '0%',\n                memoryUtilization: bufferMetrics ? bufferMetrics.memory.utilizationPercent + '%' : '0%',\n                averageBufferCreationTime: bufferMetrics ? bufferMetrics.performance.avgCreationTime : '0ms',\n                averageTransferTime: bufferMetrics ? bufferMetrics.performance.avgTransferTime : '0ms',\n                errorRate: this.operationCounter > 0 ? (this.errorCount / this.operationCounter * 100).toFixed(2) + '%' : '0%'\n            }\n        };\n    }\n\n    /**\n     * Comprehensive performance benchmark against CPU implementation\n     * @param {Object} cpuBackend - CPU backend instance for comparison\n     * @param {Object} options - Benchmark configuration\n     * @returns {Promise<Object>} Detailed benchmark results\n     */\n    async benchmarkAgainstCPU(cpuBackend, options = {}) {\n        const {\n            iterations = 1000,\n            warmupIterations = 100,\n            testBatchSizes = [1, 4, 8, 16],\n            includeMemoryAnalysis = true,\n            includeAccuracyCheck = true\n        } = options;\n\n        console.log('Starting comprehensive GPU vs CPU benchmark...');\n        const startTime = performance.now();\n\n        const results = {\n            config: {\n                iterations,\n                warmupIterations,\n                testBatchSizes,\n                architecture: this.getArchitecture()\n            },\n            singleInference: null,\n            batchProcessing: {},\n            memoryComparison: null,\n            accuracyVerification: null,\n            summary: null\n        };\n\n        try {\n            // 1. Single inference benchmark\n            console.log('Benchmarking single inference performance...');\n            results.singleInference = await this._benchmarkSingleInference(\n                cpuBackend, iterations, warmupIterations\n            );\n\n            // 2. Batch processing benchmark\n            console.log('Benchmarking batch processing performance...');\n            for (const batchSize of testBatchSizes) {\n                console.log(`  Testing batch size: ${batchSize}`);\n                results.batchProcessing[batchSize] = await this._benchmarkBatchProcessing(\n                    cpuBackend, batchSize, Math.floor(iterations / batchSize)\n                );\n            }\n\n            // 3. Memory usage comparison\n            if (includeMemoryAnalysis) {\n                console.log('Analyzing memory usage...');\n                results.memoryComparison = await this._compareMemoryUsage(cpuBackend);\n            }\n\n            // 4. Accuracy verification\n            if (includeAccuracyCheck) {\n                console.log('Verifying numerical accuracy...');\n                results.accuracyVerification = await this._verifyAccuracy(cpuBackend);\n            }\n\n            // 5. Generate summary\n            results.summary = this._generateBenchmarkSummary(results);\n\n            const totalTime = performance.now() - startTime;\n            console.log(`Benchmark completed in ${totalTime.toFixed(2)}ms`);\n            results.benchmarkTime = totalTime;\n\n            return results;\n\n        } catch (error) {\n            console.error('Benchmark failed:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Benchmark single inference performance\n     * @private\n     */\n    async _benchmarkSingleInference(cpuBackend, iterations, warmupIterations) {\n        const testInput = new Float32Array([0.1, -0.05]); // Sample robot state\n\n        // Warmup\n        for (let i = 0; i < warmupIterations; i++) {\n            cpuBackend.forward(testInput);\n            await this.forward(testInput);\n        }\n\n        // Benchmark CPU\n        const cpuTimes = [];\n        for (let i = 0; i < iterations; i++) {\n            const start = performance.now();\n            cpuBackend.forward(testInput);\n            cpuTimes.push(performance.now() - start);\n        }\n\n        // Benchmark GPU\n        const gpuTimes = [];\n        for (let i = 0; i < iterations; i++) {\n            const start = performance.now();\n            await this.forward(testInput);\n            gpuTimes.push(performance.now() - start);\n        }\n\n        // Benchmark GPU real-time optimized\n        const gpuRealTimeTimes = [];\n        for (let i = 0; i < iterations; i++) {\n            const start = performance.now();\n            await this.forwardRealTime(testInput, { realTime: true, skipValidation: true });\n            gpuRealTimeTimes.push(performance.now() - start);\n        }\n\n        const cpuStats = this._calculatePerformanceStats(cpuTimes);\n        const gpuStats = this._calculatePerformanceStats(gpuTimes);\n        const gpuRealTimeStats = this._calculatePerformanceStats(gpuRealTimeTimes);\n\n        return {\n            cpu: cpuStats,\n            gpu: gpuStats,\n            gpuRealTime: gpuRealTimeStats,\n            speedup: {\n                standard: cpuStats.median / gpuStats.median,\n                realTime: cpuStats.median / gpuRealTimeStats.median\n            },\n            throughput: {\n                cpu: 1000 / cpuStats.median,\n                gpu: 1000 / gpuStats.median,\n                gpuRealTime: 1000 / gpuRealTimeStats.median\n            },\n            realTimeCapable: gpuRealTimeStats.p95 <= 5.0, // 5ms threshold\n            iterations\n        };\n    }\n\n    /**\n     * Benchmark batch processing performance\n     * @private\n     */\n    async _benchmarkBatchProcessing(cpuBackend, batchSize, iterations) {\n        const batchInput = new Float32Array(batchSize * this.inputSize);\n        \n        // Generate batch input\n        for (let i = 0; i < batchInput.length; i += 2) {\n            batchInput[i] = Math.random() * 0.2 - 0.1;     // angle\n            batchInput[i + 1] = Math.random() * 0.1 - 0.05; // angular velocity\n        }\n\n        // Warmup\n        for (let i = 0; i < 10; i++) {\n            // CPU batch simulation (multiple single forwards)\n            for (let j = 0; j < batchSize; j++) {\n                const singleInput = batchInput.slice(j * 2, (j + 1) * 2);\n                cpuBackend.forward(singleInput);\n            }\n            \n            await this.forwardBatch(batchInput, batchSize);\n        }\n\n        // Benchmark CPU batch processing (simulated)\n        const cpuBatchTimes = [];\n        for (let i = 0; i < iterations; i++) {\n            const start = performance.now();\n            for (let j = 0; j < batchSize; j++) {\n                const singleInput = batchInput.slice(j * 2, (j + 1) * 2);\n                cpuBackend.forward(singleInput);\n            }\n            cpuBatchTimes.push(performance.now() - start);\n        }\n\n        // Benchmark GPU batch processing\n        const gpuBatchTimes = [];\n        for (let i = 0; i < iterations; i++) {\n            const start = performance.now();\n            await this.forwardBatch(batchInput, batchSize);\n            gpuBatchTimes.push(performance.now() - start);\n        }\n\n        const cpuStats = this._calculatePerformanceStats(cpuBatchTimes);\n        const gpuStats = this._calculatePerformanceStats(gpuBatchTimes);\n\n        return {\n            batchSize,\n            cpu: {\n                ...cpuStats,\n                timePerSample: cpuStats.median / batchSize,\n                throughput: (1000 * batchSize) / cpuStats.median\n            },\n            gpu: {\n                ...gpuStats,\n                timePerSample: gpuStats.median / batchSize,\n                throughput: (1000 * batchSize) / gpuStats.median\n            },\n            speedup: cpuStats.median / gpuStats.median,\n            batchEfficiency: (cpuStats.median / batchSize) / (gpuStats.median / batchSize),\n            iterations\n        };\n    }\n\n    /**\n     * Compare memory usage between CPU and GPU implementations\n     * @private\n     */\n    async _compareMemoryUsage(cpuBackend) {\n        const cpuMemory = cpuBackend.getMemoryUsage();\n        const gpuMemory = this.bufferManager.getMemoryUsage();\n\n        return {\n            cpu: {\n                totalBytes: cpuMemory.totalBytes,\n                totalKB: cpuMemory.totalKB,\n                parameterBytes: cpuMemory.parameterBytes,\n                breakdown: cpuMemory.breakdown\n            },\n            gpu: {\n                totalBytes: gpuMemory.memory.totalActive,\n                totalKB: gpuMemory.memory.totalActive / 1024,\n                bufferCount: gpuMemory.buffers.count,\n                pooledBytes: gpuMemory.memory.totalPooled,\n                efficiency: gpuMemory.pool.hitRate\n            },\n            comparison: {\n                memoryRatio: gpuMemory.memory.totalActive / cpuMemory.totalBytes,\n                gpuOverhead: gpuMemory.memory.totalActive - cpuMemory.totalBytes,\n                bufferPoolSavings: gpuMemory.memory.totalPooled\n            }\n        };\n    }\n\n    /**\n     * Verify numerical accuracy against CPU\n     * @private\n     */\n    async _verifyAccuracy(cpuBackend, testCases = 100) {\n        const errors = [];\n        const maxErrors = { absolute: 0, relative: 0 };\n        let totalAbsoluteError = 0;\n        let totalRelativeError = 0;\n\n        for (let i = 0; i < testCases; i++) {\n            // Generate test input\n            const input = new Float32Array([\n                (Math.random() - 0.5) * 0.4, // angle: -0.2 to 0.2\n                (Math.random() - 0.5) * 0.2  // angular velocity: -0.1 to 0.1\n            ]);\n\n            // Get outputs\n            const cpuOutput = cpuBackend.forward(input);\n            const gpuOutput = await this.forward(input);\n\n            // Calculate errors\n            const absoluteErrors = [];\n            const relativeErrors = [];\n\n            for (let j = 0; j < cpuOutput.length; j++) {\n                const absError = Math.abs(cpuOutput[j] - gpuOutput[j]);\n                const relError = cpuOutput[j] !== 0 ? Math.abs((cpuOutput[j] - gpuOutput[j]) / cpuOutput[j]) : 0;\n\n                absoluteErrors.push(absError);\n                relativeErrors.push(relError);\n\n                maxErrors.absolute = Math.max(maxErrors.absolute, absError);\n                maxErrors.relative = Math.max(maxErrors.relative, relError);\n            }\n\n            const maxAbsError = Math.max(...absoluteErrors);\n            const maxRelError = Math.max(...relativeErrors);\n\n            totalAbsoluteError += maxAbsError;\n            totalRelativeError += maxRelError;\n\n            errors.push({\n                input: Array.from(input),\n                cpuOutput: Array.from(cpuOutput),\n                gpuOutput: Array.from(gpuOutput),\n                absoluteErrors,\n                relativeErrors,\n                maxAbsoluteError: maxAbsError,\n                maxRelativeError: maxRelError\n            });\n        }\n\n        const averageAbsoluteError = totalAbsoluteError / testCases;\n        const averageRelativeError = totalRelativeError / testCases;\n\n        // Calculate correlation\n        const allCpuOutputs = errors.flatMap(e => e.cpuOutput);\n        const allGpuOutputs = errors.flatMap(e => e.gpuOutput);\n        const correlation = this._calculateCorrelation(allCpuOutputs, allGpuOutputs);\n\n        return {\n            testCases,\n            maxErrors,\n            averageErrors: {\n                absolute: averageAbsoluteError,\n                relative: averageRelativeError\n            },\n            correlation,\n            passed: {\n                absolute: maxErrors.absolute < 1e-6,\n                relative: maxErrors.relative < 1e-5,\n                correlation: correlation > 0.9999\n            },\n            detailedErrors: errors.slice(0, 5) // First 5 for debugging\n        };\n    }\n\n    /**\n     * Generate benchmark summary\n     * @private\n     */\n    _generateBenchmarkSummary(results) {\n        const summary = {\n            overallSpeedup: results.singleInference.speedup.standard,\n            realTimeSpeedup: results.singleInference.speedup.realTime,\n            realTimeCapable: results.singleInference.realTimeCapable,\n            bestBatchSpeedup: 0,\n            optimalBatchSize: 1,\n            memoryEfficient: false,\n            numericallyAccurate: false,\n            productionReady: false,\n            recommendations: []\n        };\n\n        // Find best batch performance\n        for (const [batchSize, batchResult] of Object.entries(results.batchProcessing)) {\n            if (batchResult.speedup > summary.bestBatchSpeedup) {\n                summary.bestBatchSpeedup = batchResult.speedup;\n                summary.optimalBatchSize = parseInt(batchSize);\n            }\n        }\n\n        // Memory efficiency check\n        if (results.memoryComparison) {\n            summary.memoryEfficient = results.memoryComparison.comparison.memoryRatio < 2.0;\n        }\n\n        // Accuracy check\n        if (results.accuracyVerification) {\n            summary.numericallyAccurate = \n                results.accuracyVerification.passed.absolute &&\n                results.accuracyVerification.passed.relative &&\n                results.accuracyVerification.passed.correlation;\n        }\n\n        // Production readiness assessment\n        summary.productionReady = \n            summary.overallSpeedup >= 2.0 &&\n            summary.realTimeCapable &&\n            summary.memoryEfficient &&\n            summary.numericallyAccurate;\n\n        // Generate recommendations\n        if (summary.overallSpeedup < 2.0) {\n            summary.recommendations.push('Optimize GPU compute pipeline for better single inference performance');\n        }\n        if (!summary.realTimeCapable) {\n            summary.recommendations.push('Implement additional real-time optimizations to meet latency requirements');\n        }\n        if (!summary.memoryEfficient) {\n            summary.recommendations.push('Optimize buffer management to reduce GPU memory overhead');\n        }\n        if (!summary.numericallyAccurate) {\n            summary.recommendations.push('Review shader implementations for numerical precision issues');\n        }\n        if (summary.bestBatchSpeedup < 1.5) {\n            summary.recommendations.push('Improve batch processing efficiency for training workflows');\n        }\n\n        return summary;\n    }\n\n    /**\n     * Calculate comprehensive performance statistics\n     * @private\n     */\n    _calculatePerformanceStats(times) {\n        const sorted = [...times].sort((a, b) => a - b);\n        const n = times.length;\n        const mean = times.reduce((sum, t) => sum + t, 0) / n;\n        const variance = times.reduce((sum, t) => sum + Math.pow(t - mean, 2), 0) / n;\n\n        return {\n            count: n,\n            min: Math.min(...times),\n            max: Math.max(...times),\n            mean,\n            median: sorted[Math.floor(n / 2)],\n            p90: sorted[Math.floor(n * 0.9)],\n            p95: sorted[Math.floor(n * 0.95)],\n            p99: sorted[Math.floor(n * 0.99)],\n            std: Math.sqrt(variance),\n            cv: Math.sqrt(variance) / mean // Coefficient of variation\n        };\n    }\n\n    /**\n     * Calculate correlation coefficient between two arrays\n     * @private\n     */\n    _calculateCorrelation(x, y) {\n        const n = x.length;\n        const meanX = x.reduce((sum, val) => sum + val, 0) / n;\n        const meanY = y.reduce((sum, val) => sum + val, 0) / n;\n        \n        let numerator = 0;\n        let sumXSq = 0;\n        let sumYSq = 0;\n        \n        for (let i = 0; i < n; i++) {\n            const deltaX = x[i] - meanX;\n            const deltaY = y[i] - meanY;\n            numerator += deltaX * deltaY;\n            sumXSq += deltaX * deltaX;\n            sumYSq += deltaY * deltaY;\n        }\n        \n        return numerator / Math.sqrt(sumXSq * sumYSq);\n    }\n\n    /**\n     * Validate that the network is ready for inference with enhanced buffer validation\n     * @returns {Object} Comprehensive validation results\n     */\n    validate() {\n        const validation = {\n            isValid: true,\n            issues: [],\n            warnings: [],\n            bufferStatus: {},\n            performance: {}\n        };\n\n        // Basic validation\n        if (!this.isInitialized) {\n            validation.isValid = false;\n            validation.issues.push('Network not initialized');\n        }\n\n        if (!this.weightsInitialized) {\n            validation.isValid = false;\n            validation.issues.push('Weights not initialized');\n        }\n\n        if (!this.device) {\n            validation.isValid = false;\n            validation.issues.push('WebGPU device not available');\n        }\n\n        if (!this.shaderManager || !this.bufferManager) {\n            validation.isValid = false;\n            validation.issues.push('GPU managers not initialized');\n        }\n\n        // Enhanced buffer validation\n        if (this.bufferManager) {\n            const bufferMetrics = this.bufferManager.getMemoryUsage();\n            const bufferPerformance = this.bufferManager.getPerformanceMetrics();\n            \n            validation.bufferStatus = {\n                totalBuffers: bufferMetrics.buffers.count,\n                memoryUsage: bufferMetrics.memory.totalActiveFormatted,\n                memoryUtilization: bufferMetrics.memory.utilizationPercent + '%',\n                poolEfficiency: bufferMetrics.pool.hitRate,\n                errorCount: bufferPerformance.errors.count\n            };\n            \n            // Check for buffer-related issues\n            if (bufferPerformance.errors.count > 0) {\n                validation.warnings.push(`${bufferPerformance.errors.count} buffer errors detected`);\n            }\n            \n            if (parseFloat(bufferMetrics.memory.utilizationPercent) > 90) {\n                validation.warnings.push('High memory utilization (>90%)');\n            }\n            \n            if (parseFloat(bufferMetrics.pool.hitRate) < 50 && bufferMetrics.pool.hits + bufferMetrics.pool.misses > 10) {\n                validation.warnings.push('Low buffer pool efficiency (<50% hit rate)');\n            }\n            \n            // Performance validation\n            const avgCreationTime = parseFloat(bufferMetrics.performance.avgCreationTime);\n            const avgTransferTime = parseFloat(bufferMetrics.performance.avgTransferTime);\n            \n            validation.performance = {\n                avgBufferCreation: bufferMetrics.performance.avgCreationTime,\n                avgMemoryTransfer: bufferMetrics.performance.avgTransferTime,\n                isPerformant: avgCreationTime < 5.0 && avgTransferTime < 10.0 // ms thresholds\n            };\n            \n            if (!validation.performance.isPerformant) {\n                validation.warnings.push('Suboptimal buffer performance detected');\n            }\n        }\n\n        // Validate shader compilation\n        if (this.shaderManager) {\n            const shaderValidation = this.shaderManager.validateShaders();\n            if (!shaderValidation.allShadersCompiled) {\n                validation.isValid = false;\n                validation.issues.push(`Missing shaders: ${shaderValidation.missingShaders.join(', ')}`);\n            }\n        }\n\n        // Validate required buffers exist\n        if (this.buffers) {\n            const requiredBuffers = ['input', 'hidden', 'output', 'weightsHidden', 'weightsOutput', 'biasHidden', 'biasOutput'];\n            for (const bufferName of requiredBuffers) {\n                if (!this.buffers[bufferName]) {\n                    validation.isValid = false;\n                    validation.issues.push(`Missing required buffer: ${bufferName}`);\n                }\n            }\n        }\n\n        return validation;\n    }\n\n    /**\n     * Execute async operation with timeout and error handling\n     * @param {Function} operation - Async operation to execute\n     * @param {string} operationName - Name for tracking\n     * @param {number} timeoutMs - Timeout in milliseconds\n     * @returns {Promise} Operation result\n     */\n    async executeAsyncOperation(operation, operationName, timeoutMs = this.operationTimeout) {\n        const operationId = this._generateOperationId();\n        \n        try {\n            // Check if we're at capacity\n            if (this.pendingOperations.size >= this.maxConcurrentOps) {\n                // Queue the operation\n                await this._queueOperation({ operation, operationName, timeoutMs, operationId });\n                return;\n            }\n            \n            // Track pending operation\n            this.pendingOperations.set(operationId, {\n                name: operationName,\n                startTime: performance.now(),\n                promise: null\n            });\n            \n            // Set up timeout\n            const timeoutPromise = new Promise((_, reject) => {\n                const timeoutId = setTimeout(() => {\n                    reject(new Error(`Operation ${operationName} timed out after ${timeoutMs}ms`));\n                }, timeoutMs);\n                this.activeTimeouts.set(operationId, timeoutId);\n            });\n            \n            // Execute operation with timeout\n            const result = await Promise.race([\n                operation(),\n                timeoutPromise\n            ]);\n            \n            // Clean up successful operation\n            this._cleanupOperation(operationId);\n            \n            return result;\n            \n        } catch (error) {\n            // Handle error\n            this._handleAsyncError(error, operationName, operationId);\n            throw error;\n        }\n    }\n    \n    /**\n     * Queue operation when at capacity\n     * @private\n     */\n    async _queueOperation(operationData) {\n        return new Promise((resolve, reject) => {\n            this.asyncQueue.push({ ...operationData, resolve, reject });\n            this._processQueue();\n        });\n    }\n    \n    /**\n     * Process queued operations\n     * @private\n     */\n    async _processQueue() {\n        if (this.asyncQueue.length === 0 || this.pendingOperations.size >= this.maxConcurrentOps) {\n            return;\n        }\n        \n        const { operation, operationName, timeoutMs, operationId, resolve, reject } = this.asyncQueue.shift();\n        \n        try {\n            const result = await this.executeAsyncOperation(operation, operationName, timeoutMs);\n            resolve(result);\n        } catch (error) {\n            reject(error);\n        }\n        \n        // Process next in queue\n        setImmediate(() => this._processQueue());\n    }\n    \n    /**\n     * Generate unique operation ID\n     * @private\n     */\n    _generateOperationId() {\n        return `op_${++this.operationCounter}_${Date.now()}`;\n    }\n    \n    /**\n     * Handle async operation error\n     * @private\n     */\n    _handleAsyncError(error, operationName, operationId) {\n        this.errorCount++;\n        this.lastError = error;\n        \n        const errorInfo = {\n            timestamp: new Date().toISOString(),\n            operationName,\n            operationId,\n            message: error.message,\n            stack: error.stack\n        };\n        \n        this.errorLog.push(errorInfo);\n        \n        // Keep error log manageable\n        if (this.errorLog.length > 100) {\n            this.errorLog.shift();\n        }\n        \n        // Clean up failed operation\n        this._cleanupOperation(operationId);\n        \n        console.error(`Async operation ${operationName} failed:`, error);\n        \n        // Check if we've exceeded error threshold\n        if (this.errorCount > this.maxErrors) {\n            console.error(`Too many errors (${this.errorCount}). Neural network may be unstable.`);\n        }\n    }\n    \n    /**\n     * Clean up operation tracking\n     * @private\n     */\n    _cleanupOperation(operationId) {\n        this.pendingOperations.delete(operationId);\n        \n        const timeoutId = this.activeTimeouts.get(operationId);\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n            this.activeTimeouts.delete(operationId);\n        }\n    }\n    \n    /**\n     * Wait for all pending operations to complete\n     * @param {number} timeoutMs - Maximum wait time\n     * @returns {Promise<void>}\n     */\n    async waitForOperations(timeoutMs = 60000) {\n        const startTime = performance.now();\n        \n        while (this.pendingOperations.size > 0) {\n            if (performance.now() - startTime > timeoutMs) {\n                const pendingOps = Array.from(this.pendingOperations.keys());\n                throw new Error(`Timeout waiting for operations: ${pendingOps.join(', ')}`);\n            }\n            \n            // Wait a bit before checking again\n            await new Promise(resolve => setTimeout(resolve, 10));\n        }\n    }\n    \n    /**\n     * Get async operation status\n     * @returns {Object} Operation status information\n     */\n    getAsyncStatus() {\n        return {\n            pendingOperations: this.pendingOperations.size,\n            queuedOperations: this.asyncQueue.length,\n            totalErrors: this.errorCount,\n            lastError: this.lastError ? {\n                message: this.lastError.message,\n                timestamp: this.errorLog[this.errorLog.length - 1]?.timestamp\n            } : null,\n            recentErrors: this.errorLog.slice(-5), // Last 5 errors\n            maxConcurrentOps: this.maxConcurrentOps,\n            operationTimeout: this.operationTimeout\n        };\n    }\n    \n    /**\n     * Reset error state\n     */\n    resetErrorState() {\n        this.errorCount = 0;\n        this.lastError = null;\n        this.errorLog = [];\n        console.log('Neural network error state reset');\n    }\n\n    /**\n     * Clean up GPU resources with enhanced async operation handling\n     */\n    destroy() {\n        // Cancel all pending operations\n        for (const [operationId, timeout] of this.activeTimeouts) {\n            clearTimeout(timeout);\n        }\n        this.activeTimeouts.clear();\n        this.pendingOperations.clear();\n        this.asyncQueue = [];\n        \n        // Clean up batch caches\n        this._batchBufferCache?.clear();\n        this._batchBindGroupCache?.clear();\n        \n        if (this.bufferManager) {\n            this.bufferManager.destroy();\n            this.bufferManager = null;\n        }\n\n        if (this.shaderManager) {\n            this.shaderManager.destroy();\n            this.shaderManager = null;\n        }\n\n        this.buffers = null;\n        this.bindGroups = null;\n        this.isInitialized = false;\n        this.weightsInitialized = false;\n        this.forwardPassTimes = [];\n\n        // Log final performance and error metrics\n        if (this.errorCount > 0) {\n            console.log('Final error stats:', {\n                totalErrors: this.errorCount,\n                errorRate: `${((this.errorCount / (this.operationCounter || 1)) * 100).toFixed(2)}%`\n            });\n        }\n        \n        console.log('Enhanced WebGPU neural network destroyed');\n    }\n\n    /**\n     * Create specialized bind groups for different forward pass stages\n     * @private\n     */\n    async _createBindGroups() {\n        const layouts = {\n            matmul: this.shaderManager.getBindGroupLayout('matmul'),\n            activation: this.shaderManager.getBindGroupLayout('activation')\n        };\n\n        this.bindGroups = {};\n\n        // Hidden layer matrix multiplication bind group\n        this.bindGroups.matmulHidden = this.device.createBindGroup({\n            label: 'matmul_hidden_bind_group',\n            layout: layouts.matmul,\n            entries: [\n                { binding: 0, resource: { buffer: this.buffers.input } },\n                { binding: 1, resource: { buffer: this.buffers.weightsHidden } },\n                { binding: 2, resource: { buffer: this.buffers.biasHidden } },\n                { binding: 3, resource: { buffer: this.buffers.hidden } },\n                { binding: 4, resource: { buffer: this.buffers.matmulParams } }\n            ]\n        });\n\n        // Output layer matrix multiplication bind group\n        this.bindGroups.matmulOutput = this.device.createBindGroup({\n            label: 'matmul_output_bind_group',\n            layout: layouts.matmul,\n            entries: [\n                { binding: 0, resource: { buffer: this.buffers.hidden } },\n                { binding: 1, resource: { buffer: this.buffers.weightsOutput } },\n                { binding: 2, resource: { buffer: this.buffers.biasOutput } },\n                { binding: 3, resource: { buffer: this.buffers.output } },\n                { binding: 4, resource: { buffer: this.buffers.matmulParams } }\n            ]\n        });\n\n        // Activation function bind group (in-place ReLU on hidden layer)\n        this.bindGroups.activation = this.device.createBindGroup({\n            label: 'activation_bind_group',\n            layout: layouts.activation,\n            entries: [\n                { binding: 0, resource: { buffer: this.buffers.hidden } },\n                { binding: 1, resource: { buffer: this.buffers.hidden } }, // In-place operation\n                { binding: 2, resource: { buffer: this.buffers.activationParams } }\n            ]\n        });\n\n        console.log('Created specialized bind groups for forward pass');\n    }\n\n    /**\n     * Perform forward pass with real-time optimization for robot control\n     * @param {Float32Array} input - Input values [angle, angular_velocity]\n     * @param {Object} options - Forward pass options\n     * @param {boolean} options.realTime - Optimize for real-time inference\n     * @param {boolean} options.skipValidation - Skip input validation for performance\n     * @returns {Promise<Float32Array>} Output action probabilities [left, right, brake]\n     */\n    async forwardRealTime(input, options = {}) {\n        const { realTime = true, skipValidation = false } = options;\n        \n        if (!this.isInitialized) {\n            throw new Error('Neural network not initialized');\n        }\n\n        if (!skipValidation && input.length !== this.inputSize) {\n            throw new Error(`Input size mismatch. Expected ${this.inputSize}, got ${input.length}`);\n        }\n\n        const startTime = performance.now();\n\n        try {\n            // Fast path upload - use direct writeBuffer for small data\n            this.device.queue.writeBuffer(this.buffers.input, 0, input);\n\n            // Execute optimized forward pass\n            if (realTime) {\n                await this._executeRealTimeForwardPass();\n            } else {\n                await this._executeForwardPass();\n            }\n\n            // Fast path download - use staging buffer\n            const outputBuffer = await this.bufferManager.readBuffer(\n                this.device, \n                this.buffers.output, \n                this.outputSize * 4, \n                0, \n                { label: 'realtime_forward_output' }\n            );\n            const output = new Float32Array(outputBuffer);\n\n            // Track performance for real-time optimization\n            const forwardTime = performance.now() - startTime;\n            this.forwardPassTimes.push(forwardTime);\n            \n            // Keep only recent timing history for memory efficiency\n            if (this.forwardPassTimes.length > 50) {\n                this.forwardPassTimes.shift();\n            }\n\n            return output;\n\n        } catch (error) {\n            console.error('Real-time forward pass failed:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Optimized forward pass for real-time robot control\n     * @private\n     */\n    async _executeRealTimeForwardPass() {\n        try {\n            // Minimal command encoding for lowest latency\n            const encoder = this.device.createCommandEncoder({ label: 'realtime_forward' });\n            const pass = encoder.beginComputePass({ label: 'realtime_compute' });\n\n            // Input -> Hidden (pre-computed parameters)\n            const hiddenParams = new Uint32Array([1, this.inputSize, this.hiddenSize, 0]);\n            this.device.queue.writeBuffer(this.buffers.matmulParams, 0, hiddenParams);\n            \n            pass.setPipeline(this.shaderManager.getPipeline('matmul_simple'));\n            pass.setBindGroup(0, this.bindGroups.matmulHidden);\n            pass.dispatchWorkgroups(Math.ceil(this.hiddenSize / 64));\n\n            // ReLU activation (in-place)\n            const activationParams = new Uint32Array([this.hiddenSize, 0, 0, 0]);\n            this.device.queue.writeBuffer(this.buffers.activationParams, 0, activationParams);\n            \n            pass.setPipeline(this.shaderManager.getPipeline('relu'));\n            pass.setBindGroup(0, this.bindGroups.activation);\n            pass.dispatchWorkgroups(Math.ceil(this.hiddenSize / 64));\n\n            // Hidden -> Output\n            const outputParams = new Uint32Array([1, this.hiddenSize, this.outputSize, 0]);\n            this.device.queue.writeBuffer(this.buffers.matmulParams, 0, outputParams);\n            \n            pass.setPipeline(this.shaderManager.getPipeline('matmul_simple'));\n            pass.setBindGroup(0, this.bindGroups.matmulOutput);\n            pass.dispatchWorkgroups(Math.ceil(this.outputSize / 64));\n\n            pass.end();\n            this.device.queue.submit([encoder.finish()]);\n            \n            // Don't await - fire and forget for minimal latency\n            // The read operation will implicitly wait\n            \n        } catch (error) {\n            console.error('Real-time forward pass execution failed:', error);\n            throw error;\n        }\n    }\n}","/**\n * WebGPU Backend for Neural Network Implementation\n * \n * GPU-accelerated neural network for two-wheel balancing robot RL.\n * Provides significant performance improvements for matrix operations\n * with automatic fallback to CPU backend when WebGPU is unavailable.\n */\n\nimport { NeuralNetwork, NetworkConfig, validateArchitecture, calculateParameterCount } from './NeuralNetwork.js';\nimport { CPUBackend } from './CPUBackend.js';\nimport { WebGPUNeuralNetwork } from './shaders/WebGPUNeuralNetwork.js';\n\n/**\n * WebGPU feature requirements for neural network operations\n */\nexport const WebGPUFeatures = {\n    // Required features for compute shaders\n    REQUIRED_FEATURES: [\n        // Core compute features will be checked programmatically\n    ],\n    \n    // Minimum buffer sizes needed for neural networks\n    MIN_BUFFER_SIZES: {\n        storageBuffer: 1024,      // Minimum storage buffer size\n        uniformBuffer: 256        // Minimum uniform buffer size\n    },\n    \n    // Minimum workgroup sizes for compute shaders\n    MIN_WORKGROUP_SIZES: {\n        maxComputeWorkgroupSizeX: 64,\n        maxComputeWorkgroupSizeY: 1,\n        maxComputeWorkgroupSizeZ: 1,\n        maxComputeInvocationsPerWorkgroup: 64\n    }\n};\n\n/**\n * WebGPU device capabilities and status\n */\nexport class WebGPUDeviceInfo {\n    constructor() {\n        this.isAvailable = false;\n        this.adapter = null;\n        this.device = null;\n        this.capabilities = null;\n        this.features = new Set();\n        this.limits = null;\n        this.errorMessage = null;\n        this.fallbackReason = null;\n    }\n\n    /**\n     * Get a summary of device capabilities\n     * @returns {Object} Device capability summary\n     */\n    getSummary() {\n        return {\n            isAvailable: this.isAvailable,\n            hasComputeShaders: this.features.has('compute') || this.isAvailable, // Basic compute assumed if available\n            maxBufferSize: this.limits?.maxBufferSize || 0,\n            maxComputeWorkgroupSizeX: this.limits?.maxComputeWorkgroupSizeX || 0,\n            maxComputeInvocationsPerWorkgroup: this.limits?.maxComputeInvocationsPerWorkgroup || 0,\n            errorMessage: this.errorMessage,\n            fallbackReason: this.fallbackReason,\n            adapterInfo: this.adapter ? {\n                vendor: this.adapter.info?.vendor || 'Unknown',\n                architecture: this.adapter.info?.architecture || 'Unknown',\n                device: this.adapter.info?.device || 'Unknown',\n                description: this.adapter.info?.description || 'Unknown'\n            } : null\n        };\n    }\n\n    /**\n     * Check if device meets minimum requirements for neural networks\n     * @returns {boolean} True if device meets requirements\n     */\n    meetsRequirements() {\n        if (!this.isAvailable || !this.limits) {\n            return false;\n        }\n\n        // Check buffer size requirements\n        if (this.limits.maxBufferSize < WebGPUFeatures.MIN_BUFFER_SIZES.storageBuffer) {\n            this.fallbackReason = `Insufficient buffer size: ${this.limits.maxBufferSize} < ${WebGPUFeatures.MIN_BUFFER_SIZES.storageBuffer}`;\n            return false;\n        }\n\n        // Check workgroup size requirements\n        if (this.limits.maxComputeWorkgroupSizeX < WebGPUFeatures.MIN_WORKGROUP_SIZES.maxComputeWorkgroupSizeX) {\n            this.fallbackReason = `Insufficient workgroup size X: ${this.limits.maxComputeWorkgroupSizeX} < ${WebGPUFeatures.MIN_WORKGROUP_SIZES.maxComputeWorkgroupSizeX}`;\n            return false;\n        }\n\n        if (this.limits.maxComputeInvocationsPerWorkgroup < WebGPUFeatures.MIN_WORKGROUP_SIZES.maxComputeInvocationsPerWorkgroup) {\n            this.fallbackReason = `Insufficient compute invocations: ${this.limits.maxComputeInvocationsPerWorkgroup} < ${WebGPUFeatures.MIN_WORKGROUP_SIZES.maxComputeInvocationsPerWorkgroup}`;\n            return false;\n        }\n\n        return true;\n    }\n}\n\n/**\n * WebGPU device initialization and management\n */\nexport class WebGPUDeviceManager {\n    constructor() {\n        this.deviceInfo = new WebGPUDeviceInfo();\n        this.isInitialized = false;\n        this.initializationPromise = null;\n    }\n\n    /**\n     * Initialize WebGPU device with comprehensive feature detection\n     * @param {Object} options - Initialization options\n     * @param {boolean} options.preferHighPerformance - Prefer high-performance adapter\n     * @param {boolean} options.forceFallback - Force CPU fallback for testing\n     * @returns {Promise<WebGPUDeviceInfo>} Device information\n     */\n    async initWebGPU(options = {}) {\n        // Return existing initialization promise if already in progress\n        if (this.initializationPromise) {\n            return this.initializationPromise;\n        }\n\n        this.initializationPromise = this._initWebGPUInternal(options);\n        return this.initializationPromise;\n    }\n\n    /**\n     * Internal WebGPU initialization implementation\n     * @private\n     */\n    async _initWebGPUInternal(options) {\n        const { preferHighPerformance = true, forceFallback = false } = options;\n\n        try {\n            // Check for forced fallback (for testing)\n            if (forceFallback) {\n                throw new Error('Forced CPU fallback for testing');\n            }\n\n            // Check WebGPU browser support\n            if (!navigator.gpu) {\n                throw new Error('WebGPU is not supported in this browser. Requires Chrome 113+ or Edge 113+');\n            }\n\n            console.log('WebGPU API detected, requesting adapter...');\n\n            // Request WebGPU adapter\n            const adapter = await navigator.gpu.requestAdapter({\n                powerPreference: preferHighPerformance ? 'high-performance' : 'low-power'\n            });\n\n            if (!adapter) {\n                throw new Error('No suitable WebGPU adapter found. Your GPU may not support WebGPU');\n            }\n\n            this.deviceInfo.adapter = adapter;\n            console.log('WebGPU adapter obtained:', adapter);\n\n            // Log adapter information if available\n            if (adapter.info) {\n                console.log('Adapter info:', {\n                    vendor: adapter.info.vendor,\n                    architecture: adapter.info.architecture,\n                    device: adapter.info.device,\n                    description: adapter.info.description\n                });\n            }\n\n            // Get adapter features and limits\n            const adapterFeatures = Array.from(adapter.features);\n            console.log('Adapter features:', adapterFeatures);\n\n            // Request device with required features\n            const deviceDescriptor = this._createDeviceDescriptor(adapter);\n            console.log('Requesting device with descriptor:', deviceDescriptor);\n\n            const device = await adapter.requestDevice(deviceDescriptor);\n\n            if (!device) {\n                throw new Error('Failed to obtain WebGPU device');\n            }\n\n            this.deviceInfo.device = device;\n            this.deviceInfo.features = device.features;\n            this.deviceInfo.limits = device.limits;\n\n            console.log('WebGPU device obtained successfully');\n            console.log('Device features:', Array.from(device.features));\n            console.log('Device limits:', device.limits);\n\n            // Set up error handling\n            device.addEventListener('uncapturederror', (event) => {\n                console.error('WebGPU uncaptured error:', event.error);\n            });\n\n            // Validate device capabilities\n            if (!this.deviceInfo.meetsRequirements()) {\n                throw new Error(`WebGPU device does not meet requirements: ${this.deviceInfo.fallbackReason}`);\n            }\n\n            // Mark as successfully initialized\n            this.deviceInfo.isAvailable = true;\n            this.isInitialized = true;\n\n            console.log('WebGPU initialization completed successfully');\n            return this.deviceInfo;\n\n        } catch (error) {\n            console.warn('WebGPU initialization failed:', error.message);\n            this.deviceInfo.isAvailable = false;\n            this.deviceInfo.errorMessage = error.message;\n            this.deviceInfo.fallbackReason = this.deviceInfo.fallbackReason || error.message;\n            \n            return this.deviceInfo;\n        }\n    }\n\n    /**\n     * Create device descriptor with required features\n     * @private\n     */\n    _createDeviceDescriptor(adapter) {\n        const requiredFeatures = [];\n        \n        // Add features that are available and useful for neural networks\n        const usefulFeatures = [\n            'timestamp-query',\n            'pipeline-statistics-query'\n        ];\n\n        for (const feature of usefulFeatures) {\n            if (adapter.features.has(feature)) {\n                requiredFeatures.push(feature);\n            }\n        }\n\n        return {\n            requiredFeatures,\n            requiredLimits: {\n                // Request higher limits if supported\n                maxBufferSize: Math.min(\n                    adapter.limits.maxBufferSize,\n                    1024 * 1024 * 1024 // 1GB max\n                ),\n                maxComputeWorkgroupSizeX: Math.min(\n                    adapter.limits.maxComputeWorkgroupSizeX,\n                    256\n                )\n            }\n        };\n    }\n\n    /**\n     * Get current device information\n     * @returns {WebGPUDeviceInfo} Current device info\n     */\n    getDeviceInfo() {\n        return this.deviceInfo;\n    }\n\n    /**\n     * Check if WebGPU is available and ready\n     * @returns {boolean} True if WebGPU is available\n     */\n    isWebGPUAvailable() {\n        return this.deviceInfo.isAvailable && this.isInitialized;\n    }\n\n    /**\n     * Get the WebGPU device\n     * @returns {GPUDevice|null} WebGPU device or null if not available\n     */\n    getDevice() {\n        return this.deviceInfo.device;\n    }\n\n    /**\n     * Clean up WebGPU resources\n     */\n    destroy() {\n        if (this.deviceInfo.device) {\n            this.deviceInfo.device.destroy();\n            this.deviceInfo.device = null;\n        }\n        \n        this.deviceInfo.adapter = null;\n        this.isInitialized = false;\n        this.initializationPromise = null;\n        \n        console.log('WebGPU device manager destroyed');\n    }\n\n    /**\n     * Get performance characteristics estimate\n     * @returns {Object} Performance estimates\n     */\n    getPerformanceEstimate() {\n        if (!this.isWebGPUAvailable()) {\n            return {\n                estimatedSpeedup: 1.0,\n                supportedOperations: ['basic'],\n                recommendedBatchSize: 1\n            };\n        }\n\n        // Estimate performance based on device capabilities\n        const limits = this.deviceInfo.limits;\n        const workgroupSize = Math.min(limits.maxComputeWorkgroupSizeX, 64);\n        \n        // Conservative estimates for neural network operations\n        const estimatedSpeedup = Math.min(\n            workgroupSize / 8, // Assume 8x speedup per 64 threads\n            10.0 // Cap at 10x speedup\n        );\n\n        return {\n            estimatedSpeedup,\n            supportedOperations: ['matrix_multiply', 'activation_functions', 'gradient_computation'],\n            recommendedBatchSize: Math.floor(workgroupSize / 4),\n            maxWorkgroupSize: workgroupSize,\n            maxBufferSizeMB: Math.floor(limits.maxBufferSize / (1024 * 1024))\n        };\n    }\n}\n\n/**\n * WebGPU-accelerated neural network implementation\n * Falls back to CPU backend when WebGPU is unavailable\n */\nexport class WebGPUBackend extends NeuralNetwork {\n    constructor() {\n        super();\n        \n        // WebGPU device management\n        this.deviceManager = new WebGPUDeviceManager();\n        this.isWebGPUAvailable = false;\n        \n        // GPU neural network implementation\n        this.gpuNetwork = null;\n        \n        // CPU fallback backend\n        this.cpuBackend = new CPUBackend();\n        this.usingFallback = false;\n        \n        // Network state\n        this.isInitialized = false;\n        \n        // Performance monitoring\n        this.performanceMetrics = {\n            initializationTime: 0,\n            forwardPassTimes: [],\n            gpuMemoryUsage: 0,\n            fallbackReason: null\n        };\n    }\n\n    /**\n     * Create and initialize the neural network with WebGPU acceleration\n     * @param {number|Object} inputSizeOrArchitecture - Input size (2) or full architecture object\n     * @param {number} hiddenSize - Number of hidden neurons (4-16) - legacy parameter\n     * @param {number} outputSize - Number of output neurons (must be 3) - legacy parameter\n     * @param {Object} options - Configuration options\n     * @param {string} options.initMethod - Weight initialization method\n     * @param {number} options.seed - Random seed for reproducible initialization\n     * @param {boolean} options.forceCPU - Force CPU fallback for testing\n     * @returns {Promise<void>} Promise that resolves when network is created\n     */\n    async createNetwork(inputSizeOrArchitecture, hiddenSize, outputSize, options = {}) {\n        const startTime = performance.now();\n        \n        try {\n            // Handle both old single-layer and new multi-layer architecture formats\n            let architecture, inputSize, outputSize;\n            \n            if (typeof inputSizeOrArchitecture === 'object' && inputSizeOrArchitecture.layers) {\n                // New architecture object format\n                architecture = inputSizeOrArchitecture;\n                inputSize = architecture.inputSize || 2;\n                outputSize = architecture.outputSize || 3;\n                console.log(`Creating network with ${architecture.name || 'Custom'} architecture: ${architecture.layers.join('→')} layers`);\n            } else {\n                // Legacy format: (inputSize, hiddenSize, outputSize)\n                inputSize = inputSizeOrArchitecture || 2;\n                outputSize = outputSize || 3;\n                architecture = {\n                    name: 'Legacy',\n                    inputSize: inputSize,\n                    outputSize: outputSize,\n                    layers: [hiddenSize || 8],\n                    getParameterCount: function() {\n                        let total = 0;\n                        let prevSize = this.inputSize;\n                        for (const layerSize of this.layers) {\n                            total += (prevSize * layerSize) + layerSize;\n                            prevSize = layerSize;\n                        }\n                        total += (prevSize * this.outputSize) + this.outputSize;\n                        return total;\n                    }\n                };\n                console.log(`Creating network with legacy format: ${inputSize}-${hiddenSize}-${outputSize}`);\n            }\n            \n            // Validate architecture constraints\n            if (architecture.layers.length === 1) {\n                // Single layer - use old validation for backward compatibility\n                validateArchitecture(inputSize, architecture.layers[0], outputSize);\n            } else {\n                // Multi-layer - validate with architecture object\n                const validation = architecture.validate ? architecture.validate() : { valid: true };\n                if (!validation.valid) {\n                    throw new Error(`Invalid architecture: ${validation.errors.join(', ')}`);\n                }\n            }\n            \n            // Store architecture for later use\n            this.currentArchitecture = architecture;\n            \n            console.log('Initializing WebGPU backend...');\n            \n            // Initialize WebGPU device\n            const deviceInfo = await this.deviceManager.initWebGPU({\n                forceFallback: options.forceCPU || false\n            });\n            \n            if (deviceInfo.isAvailable && deviceInfo.meetsRequirements()) {\n                // WebGPU is available and meets requirements\n                this.isWebGPUAvailable = true;\n                this.usingFallback = false;\n                \n                console.log('WebGPU backend initialized successfully');\n                console.log('Performance estimate:', this.deviceManager.getPerformanceEstimate());\n                \n                // Initialize WebGPU neural network with shaders\n                this.gpuNetwork = new WebGPUNeuralNetwork(this.deviceManager.getDevice());\n                await this.gpuNetwork.initialize(architecture, options);\n                \n            } else {\n                // Fall back to CPU backend\n                this.isWebGPUAvailable = false;\n                this.usingFallback = true;\n                this.performanceMetrics.fallbackReason = deviceInfo.fallbackReason || deviceInfo.errorMessage;\n                \n                console.log('Falling back to CPU backend:', this.performanceMetrics.fallbackReason);\n                await this.cpuBackend.createNetwork(architecture, options);\n            }\n            \n            this.isInitialized = true;\n            this.performanceMetrics.initializationTime = performance.now() - startTime;\n            \n            const backendType = this.isWebGPUAvailable ? 'WebGPU' : 'CPU (fallback)';\n            console.log(`Neural Network created with ${backendType} backend: ${architecture.name} (${architecture.layers.join('→')} layers, ${architecture.getParameterCount()} params)`);\n            \n        } catch (error) {\n            console.error('Failed to initialize WebGPU backend:', error);\n            \n            // Emergency fallback to CPU\n            if (!this.usingFallback) {\n                console.log('Emergency fallback to CPU backend');\n                this.isWebGPUAvailable = false;\n                this.usingFallback = true;\n                this.performanceMetrics.fallbackReason = error.message;\n                \n                await this.cpuBackend.createNetwork(architecture, options);\n                this.isInitialized = true;\n            } else {\n                throw error;\n            }\n        }\n    }\n\n    /**\n     * Perform forward pass through the network\n     * @param {Float32Array} input - Input values (angle, angular velocity)\n     * @returns {Float32Array} Output probabilities for actions\n     */\n    async forward(input) {\n        if (!this.isInitialized) {\n            throw new Error('Network not initialized. Call createNetwork() first.');\n        }\n        \n        const startTime = performance.now();\n        \n        let result;\n        if (this.isWebGPUAvailable && this.gpuNetwork) {\n            // Use WebGPU compute shaders\n            result = await this.gpuNetwork.forward(input);\n        } else {\n            // Use CPU backend fallback\n            result = this.cpuBackend.forward(input);\n        }\n        \n        // Track performance\n        const forwardTime = performance.now() - startTime;\n        this.performanceMetrics.forwardPassTimes.push(forwardTime);\n        \n        // Keep only recent timing history\n        if (this.performanceMetrics.forwardPassTimes.length > 100) {\n            this.performanceMetrics.forwardPassTimes.shift();\n        }\n        \n        return result;\n    }\n\n    /**\n     * Get the total number of parameters in the network\n     * @returns {number} Total parameter count\n     */\n    getParameterCount() {\n        if (!this.isInitialized || !this.currentArchitecture) {\n            return 0;\n        }\n        \n        return this.currentArchitecture.getParameterCount();\n    }\n\n    /**\n     * Get network weights for serialization/export\n     * @returns {Promise<Object>} Object containing weights and biases\n     */\n    async getWeights() {\n        if (!this.isInitialized) {\n            throw new Error('Network not initialized');\n        }\n        \n        if (this.isWebGPUAvailable && this.gpuNetwork) {\n            return await this.gpuNetwork.getWeights();\n        } else {\n            return this.cpuBackend.getWeights();\n        }\n    }\n\n    /**\n     * Set network weights from serialized data\n     * @param {Object} weights - Object containing weights and biases\n     */\n    async setWeights(weights) {\n        if (this.isWebGPUAvailable && this.gpuNetwork) {\n            return await this.gpuNetwork.setWeights(weights);\n        } else {\n            return this.cpuBackend.setWeights(weights);\n        }\n    }\n\n    /**\n     * Get network architecture information including backend details\n     * @returns {Object} Architecture details with backend information\n     */\n    getArchitecture() {\n        if (!this.isInitialized || !this.currentArchitecture) {\n            return {\n                backend: 'uninitialized',\n                webgpuAvailable: this.isWebGPUAvailable,\n                usingFallback: this.usingFallback\n            };\n        }\n        \n        return {\n            ...this.currentArchitecture,\n            parameterCount: this.currentArchitecture.getParameterCount(),\n            backend: this.isWebGPUAvailable ? 'webgpu' : 'cpu',\n            webgpuAvailable: this.isWebGPUAvailable,\n            usingFallback: this.usingFallback,\n            fallbackReason: this.performanceMetrics.fallbackReason,\n            deviceInfo: this.deviceManager.getDeviceInfo().getSummary(),\n            performanceEstimate: this.deviceManager.getPerformanceEstimate()\n        };\n    }\n\n    /**\n     * Get comprehensive backend information\n     * @returns {Object} Backend status and capabilities\n     */\n    getBackendInfo() {\n        return {\n            type: this.isWebGPUAvailable ? 'webgpu' : 'cpu',\n            webgpuAvailable: this.isWebGPUAvailable,\n            usingFallback: this.usingFallback,\n            fallbackReason: this.performanceMetrics.fallbackReason,\n            deviceInfo: this.deviceManager.getDeviceInfo(),\n            performanceMetrics: this.getPerformanceMetrics(),\n            capabilities: this.deviceManager.getPerformanceEstimate()\n        };\n    }\n\n    /**\n     * Get performance metrics\n     * @returns {Object} Performance statistics\n     */\n    getPerformanceMetrics() {\n        const forwardTimes = this.performanceMetrics.forwardPassTimes;\n        const avgForwardTime = forwardTimes.length > 0 \n            ? forwardTimes.reduce((a, b) => a + b) / forwardTimes.length \n            : 0;\n\n        const baseMetrics = {\n            initializationTime: this.performanceMetrics.initializationTime,\n            averageForwardTime: avgForwardTime,\n            totalForwardPasses: forwardTimes.length,\n            estimatedSpeedup: this.isWebGPUAvailable \n                ? this.deviceManager.getPerformanceEstimate().estimatedSpeedup \n                : 1.0,\n            memoryUsage: this.getMemoryUsage()\n        };\n\n        // Add GPU-specific metrics if available\n        if (this.isWebGPUAvailable && this.gpuNetwork) {\n            const gpuMetrics = this.gpuNetwork.getPerformanceMetrics();\n            return {\n                ...baseMetrics,\n                gpu: gpuMetrics,\n                backend: 'webgpu'\n            };\n        }\n\n        return {\n            ...baseMetrics,\n            backend: 'cpu'\n        };\n    }\n\n    /**\n     * Benchmark forward pass performance\n     * @param {number} iterations - Number of iterations to benchmark\n     * @returns {Object} Performance statistics with backend comparison\n     */\n    benchmark(iterations = 1000) {\n        if (!this.isInitialized) {\n            throw new Error('Network not initialized');\n        }\n        \n        // Use CPU backend's benchmark for now\n        const results = this.cpuBackend.benchmark(iterations);\n        \n        // Add backend-specific information\n        return {\n            ...results,\n            backend: this.isWebGPUAvailable ? 'webgpu' : 'cpu',\n            webgpuAvailable: this.isWebGPUAvailable,\n            usingFallback: this.usingFallback,\n            estimatedSpeedup: this.isWebGPUAvailable \n                ? this.deviceManager.getPerformanceEstimate().estimatedSpeedup \n                : 1.0\n        };\n    }\n\n    /**\n     * Get memory usage information\n     * @returns {Object} Memory usage statistics\n     */\n    getMemoryUsage() {\n        const cpuMemory = this.cpuBackend.getMemoryUsage();\n        \n        return {\n            ...cpuMemory,\n            backend: this.isWebGPUAvailable ? 'webgpu' : 'cpu',\n            gpuMemoryEstimate: this.isWebGPUAvailable ? cpuMemory.totalBytes : 0,\n            webgpuBuffers: this.isWebGPUAvailable ? 'Not implemented (Phase 2.2)' : 'N/A'\n        };\n    }\n\n    /**\n     * Create a copy of the network\n     * @returns {WebGPUBackend} Deep copy of this network\n     */\n    clone() {\n        const clone = new WebGPUBackend();\n        \n        if (this.isInitialized && this.currentArchitecture) {\n            clone.createNetwork(this.currentArchitecture, {\n                initMethod: 'xavier'\n            });\n            clone.setWeights(this.getWeights());\n        }\n        \n        return clone;\n    }\n\n    /**\n     * Reset network weights to initial random values\n     */\n    resetWeights() {\n        if (!this.isInitialized) {\n            throw new Error('Network not initialized');\n        }\n        \n        this.cpuBackend.resetWeights();\n    }\n\n    /**\n     * Clean up resources\n     */\n    destroy() {\n        if (this.gpuNetwork) {\n            this.gpuNetwork.destroy();\n            this.gpuNetwork = null;\n        }\n        \n        if (this.cpuBackend) {\n            // CPU backend doesn't have a destroy method, but we can clear references\n            this.cpuBackend = null;\n        }\n        \n        if (this.deviceManager) {\n            this.deviceManager.destroy();\n            this.deviceManager = null;\n        }\n        \n        this.isInitialized = false;\n        this.isWebGPUAvailable = false;\n        this.usingFallback = false;\n        \n        console.log('WebGPU backend destroyed');\n    }\n}\n\n/**\n * Utility function to check WebGPU availability without full initialization\n * @returns {Promise<Object>} Quick availability check result\n */\nexport async function checkWebGPUAvailability() {\n    try {\n        if (!navigator.gpu) {\n            return {\n                available: false,\n                reason: 'WebGPU API not found in browser'\n            };\n        }\n\n        const adapter = await navigator.gpu.requestAdapter();\n        if (!adapter) {\n            return {\n                available: false,\n                reason: 'No WebGPU adapter available'\n            };\n        }\n\n        return {\n            available: true,\n            adapterInfo: adapter.info ? {\n                vendor: adapter.info.vendor,\n                device: adapter.info.device\n            } : 'Unknown adapter'\n        };\n    } catch (error) {\n        return {\n            available: false,\n            reason: error.message\n        };\n    }\n}\n\n/**\n * Factory function to create appropriate backend (WebGPU with CPU fallback)\n * @param {Object} options - Backend creation options\n * @returns {WebGPUBackend} Backend instance\n */\nexport function createBackend(options = {}) {\n    return new WebGPUBackend();\n}","/**\n * Parallel Training System for Multi-Core CPU Utilization\n * \n * Uses Web Workers to run multiple training episodes in parallel,\n * utilizing 50% of available CPU cores for improved training speed.\n */\n\nimport { createDefaultRobot } from '../physics/BalancingRobot.js';\n\n/**\n * System capability detection and configuration\n */\nexport class SystemCapabilities {\n    constructor() {\n        this.coreCount = this.detectCores();\n        this.targetCores = Math.max(1, Math.floor(this.coreCount * 0.5)); // Use 50% of cores\n        this.maxWorkers = Math.min(this.targetCores, 64); // Cap at 64 workers for extreme performance\n        \n        console.log(`System Detection:`);\n        console.log(`- Total CPU cores: ${this.coreCount}`);\n        console.log(`- Target cores (50%): ${this.targetCores}`);\n        console.log(`- Max workers: ${this.maxWorkers}`);\n    }\n    \n    /**\n     * Detect available CPU cores\n     * @returns {number} Number of logical CPU cores\n     */\n    detectCores() {\n        if (typeof navigator !== 'undefined' && navigator.hardwareConcurrency) {\n            return navigator.hardwareConcurrency;\n        }\n        \n        // Fallback estimation if hardwareConcurrency is not available\n        console.warn('navigator.hardwareConcurrency not available, estimating cores');\n        return 4; // Conservative fallback\n    }\n    \n    /**\n     * Get recommended worker configuration\n     * @returns {Object} Worker configuration\n     */\n    getWorkerConfig() {\n        return {\n            workerCount: this.maxWorkers,\n            episodesPerWorker: 2, // Episodes per batch per worker\n            batchSize: this.maxWorkers * 2 // Total episodes per parallel batch\n        };\n    }\n}\n\n/**\n * Web Worker manager for parallel episode execution\n */\nexport class WorkerPool {\n    constructor(workerCount, workerScript) {\n        this.workerCount = workerCount;\n        this.workers = [];\n        this.availableWorkers = [];\n        this.busyWorkers = new Set();\n        this.taskQueue = [];\n        this.workerScript = workerScript;\n        \n        this.initialized = false;\n    }\n    \n    /**\n     * Initialize the worker pool\n     */\n    async initialize() {\n        console.log(`🔧 Initializing worker pool with ${this.workerCount} workers...`);\n        \n        for (let i = 0; i < this.workerCount; i++) {\n            try {\n                console.log(`  Creating worker ${i + 1}/${this.workerCount}...`);\n                const worker = new Worker(this.workerScript);\n                \n                // Set up worker message handling\n                worker.onmessage = (event) => {\n                    this.handleWorkerMessage(i, event.data);\n                };\n                \n                worker.onerror = (error) => {\n                    console.error(`❌ Worker ${i} error:`, error);\n                };\n                \n                // Test worker with ping\n                worker.postMessage({ type: 'ping', taskId: `init-${i}` });\n                \n                this.workers[i] = worker;\n                this.availableWorkers.push(i);\n                \n                console.log(`  ✅ Worker ${i} created successfully`);\n                \n            } catch (error) {\n                console.error(`❌ Failed to create worker ${i}:`, error);\n                throw error;\n            }\n        }\n        \n        this.initialized = true;\n        console.log(`🎉 Worker pool initialized with ${this.workers.length} workers`);\n        \n        // Initialize all workers\n        console.log('🔧 Initializing workers...');\n        for (let i = 0; i < this.workers.length; i++) {\n            this.workers[i].postMessage({ type: 'initialize', taskId: `worker-init-${i}` });\n        }\n    }\n    \n    /**\n     * Handle message from worker\n     * @param {number} workerId - Worker ID\n     * @param {Object} data - Message data\n     */\n    handleWorkerMessage(workerId, data) {\n        console.log(`📨 Worker ${workerId} message:`, data.type, data.taskId);\n        \n        if (data.type === 'episode_complete') {\n            console.log(`  ✅ Episode completed by worker ${workerId}: reward=${data.result?.totalReward?.toFixed(2)}, steps=${data.result?.stepCount}`);\n            // Mark worker as available\n            this.busyWorkers.delete(workerId);\n            this.availableWorkers.push(workerId);\n            \n            // Process next task in queue\n            this.processNextTask();\n        } else if (data.type === 'error') {\n            console.error(`❌ Worker ${workerId} error:`, data.error);\n            // Mark worker as available even on error\n            this.busyWorkers.delete(workerId);\n            this.availableWorkers.push(workerId);\n        } else if (data.type === 'pong') {\n            console.log(`  🏓 Worker ${workerId} responded to ping`);\n        } else if (data.type === 'initialized') {\n            console.log(`  🎉 Worker ${workerId} initialized successfully`);\n        } else {\n            console.log(`  ❓ Unknown message type from worker ${workerId}:`, data.type);\n        }\n    }\n    \n    /**\n     * Execute parallel episodes\n     * @param {Array} tasks - Array of episode tasks\n     * @returns {Promise<Array>} Results from all tasks\n     */\n    async executeParallelEpisodes(tasks) {\n        if (!this.initialized) {\n            throw new Error('Worker pool not initialized');\n        }\n        \n        return new Promise((resolve, reject) => {\n            const results = [];\n            let completedTasks = 0;\n            \n            // Handler for completed tasks\n            const taskCompleteHandler = (taskId, result) => {\n                results[taskId] = result;\n                completedTasks++;\n                \n                if (completedTasks === tasks.length) {\n                    resolve(results);\n                }\n            };\n            \n            // Add all tasks to queue\n            tasks.forEach((task, index) => {\n                this.taskQueue.push({\n                    id: index,\n                    task: task,\n                    callback: taskCompleteHandler\n                });\n            });\n            \n            // Start processing tasks\n            this.processAllTasks();\n        });\n    }\n    \n    /**\n     * Process all tasks in the queue\n     */\n    processAllTasks() {\n        while (this.availableWorkers.length > 0 && this.taskQueue.length > 0) {\n            this.processNextTask();\n        }\n    }\n    \n    /**\n     * Process next task in queue\n     */\n    processNextTask() {\n        if (this.availableWorkers.length === 0 || this.taskQueue.length === 0) {\n            return;\n        }\n        \n        const workerId = this.availableWorkers.pop();\n        const taskItem = this.taskQueue.shift();\n        \n        this.busyWorkers.add(workerId);\n        \n        // Send task to worker\n        this.workers[workerId].postMessage({\n            type: 'run_episode',\n            taskId: taskItem.id,\n            ...taskItem.task\n        });\n        \n        // Set up one-time listener for this task\n        const originalHandler = this.workers[workerId].onmessage;\n        this.workers[workerId].onmessage = (event) => {\n            if (event.data.taskId === taskItem.id) {\n                taskItem.callback(taskItem.id, event.data.result);\n                this.workers[workerId].onmessage = originalHandler;\n            }\n            originalHandler(event);\n        };\n    }\n    \n    /**\n     * Terminate all workers\n     */\n    terminate() {\n        this.workers.forEach(worker => {\n            worker.terminate();\n        });\n        this.workers = [];\n        this.availableWorkers = [];\n        this.busyWorkers.clear();\n        this.initialized = false;\n    }\n}\n\n/**\n * Parallel training coordinator\n */\nexport class ParallelTrainingManager {\n    constructor(qLearning, environment) {\n        this.qLearning = qLearning;\n        this.environment = environment;\n        this.capabilities = new SystemCapabilities();\n        this.workerPool = null;\n        \n        // Configuration\n        this.config = this.capabilities.getWorkerConfig();\n        this.parallelEnabled = this.config.workerCount > 1;\n        \n        // Performance tracking\n        this.stats = {\n            totalParallelEpisodes: 0,\n            totalSerialEpisodes: 0,\n            parallelTime: 0,\n            serialTime: 0,\n            speedupFactor: 1.0\n        };\n        \n        console.log(`Parallel Training Manager initialized:`);\n        console.log(`- Parallel enabled: ${this.parallelEnabled}`);\n        console.log(`- Worker count: ${this.config.workerCount}`);\n        console.log(`- Episodes per batch: ${this.config.batchSize}`);\n    }\n    \n    /**\n     * Initialize parallel training system\n     */\n    async initialize() {\n        if (!this.parallelEnabled) {\n            console.log('Parallel training disabled (single core or insufficient cores)');\n            return;\n        }\n        \n        try {\n            // Create worker script URL from EpisodeWorker.js\n            const workerURL = await this.createWorkerScript();\n            \n            this.workerPool = new WorkerPool(this.config.workerCount, workerURL);\n            await this.workerPool.initialize();\n            \n            console.log('Parallel training system initialized successfully');\n        } catch (error) {\n            console.warn('Failed to initialize parallel training, falling back to serial:', error);\n            this.parallelEnabled = false;\n        }\n    }\n    \n    /**\n     * Create worker script URL from the EpisodeWorker.js file\n     * @returns {string} Worker script URL\n     */\n    async createWorkerScript() {\n        try {\n            // Fetch the episode worker script\n            console.log('🔍 Attempting to load EpisodeWorker.js...');\n            const workerResponse = await fetch('./src/training/EpisodeWorker.js');\n            \n            if (!workerResponse.ok) {\n                throw new Error(`Failed to fetch EpisodeWorker.js: ${workerResponse.status}`);\n            }\n            \n            const workerCode = await workerResponse.text();\n            console.log(`✅ EpisodeWorker.js loaded successfully (${workerCode.length} chars)`);\n            \n            // Create blob URL for the worker\n            const workerBlob = new Blob([workerCode], { type: 'application/javascript' });\n            return URL.createObjectURL(workerBlob);\n            \n        } catch (error) {\n            console.warn('❌ Failed to load EpisodeWorker.js, using fallback simulation:', error.message);\n            // Fallback to inline worker if file loading fails\n            return this.createFallbackWorkerScript();\n        }\n    }\n    \n    /**\n     * Create fallback inline worker script\n     * @returns {string} Worker script URL\n     */\n    createFallbackWorkerScript() {\n        const fallbackWorkerCode = `\n            // Fallback episode worker\n            let episodeCount = 0;\n            \n            self.onmessage = function(event) {\n                const { type, taskId } = event.data;\n                \n                if (type === 'initialize') {\n                    self.postMessage({\n                        type: 'initialized',\n                        taskId: taskId,\n                        success: true\n                    });\n                    return;\n                }\n                \n                if (type === 'run_episode') {\n                    try {\n                        const result = runSimulatedEpisode(event.data);\n                        \n                        self.postMessage({\n                            type: 'episode_complete',\n                            taskId: taskId,\n                            result: result\n                        });\n                    } catch (error) {\n                        self.postMessage({\n                            type: 'error',\n                            taskId: taskId,\n                            error: { message: error.message }\n                        });\n                    }\n                }\n            };\n            \n            function runSimulatedEpisode(params) {\n                episodeCount++;\n                \n                // Simulate episode with reasonable results\n                const maxSteps = params.maxSteps || 1000;\n                const steps = Math.floor(Math.random() * maxSteps * 0.8) + maxSteps * 0.2;\n                const success = Math.random() > 0.3; // 70% success rate\n                const reward = success ? steps : Math.random() * steps * 0.5;\n                \n                // Simulate some computation time\n                const startTime = Date.now();\n                const computeTime = 5 + Math.random() * 15; // 5-20ms\n                while (Date.now() - startTime < computeTime) {\n                    // Busy wait\n                }\n                \n                // Generate some fake experiences\n                const experiences = [];\n                for (let i = 0; i < Math.min(steps, 100); i++) {\n                    experiences.push({\n                        state: [Math.random() * 2 - 1, Math.random() * 2 - 1],\n                        action: Math.floor(Math.random() * 3),\n                        reward: success ? 1.0 : 0.0,\n                        nextState: [Math.random() * 2 - 1, Math.random() * 2 - 1],\n                        done: i === steps - 1\n                    });\n                }\n                \n                return {\n                    episodeId: params.episodeId || episodeCount,\n                    totalReward: reward,\n                    stepCount: steps,\n                    experiences: experiences,\n                    completed: success,\n                    finalState: {\n                        angle: Math.random() * 0.2 - 0.1,\n                        angularVelocity: Math.random() * 0.4 - 0.2,\n                        position: Math.random() * 2 - 1,\n                        velocity: Math.random() * 0.4 - 0.2\n                    }\n                };\n            }\n        `;\n        \n        const workerBlob = new Blob([fallbackWorkerCode], { type: 'application/javascript' });\n        return URL.createObjectURL(workerBlob);\n    }\n    \n    /**\n     * Run episodes in parallel if possible, otherwise run serially\n     * @param {number} numEpisodes - Number of episodes to run\n     * @param {Object} options - Episode options\n     * @returns {Promise<Array>} Episode results\n     */\n    async runEpisodes(numEpisodes, options = {}) {\n        const startTime = Date.now();\n        \n        if (this.parallelEnabled && numEpisodes >= this.config.workerCount) {\n            return this.runParallelEpisodes(numEpisodes, options);\n        } else {\n            return this.runSerialEpisodes(numEpisodes, options);\n        }\n    }\n    \n    /**\n     * Run episodes in parallel across multiple workers\n     * @param {number} numEpisodes - Number of episodes to run\n     * @param {Object} options - Episode options\n     * @returns {Promise<Array>} Episode results\n     */\n    async runParallelEpisodes(numEpisodes, options = {}) {\n        const startTime = Date.now();\n        \n        console.log(`Running ${numEpisodes} episodes in parallel across ${this.config.workerCount} workers...`);\n        \n        // Get current neural network weights to send to workers\n        const neuralNetworkWeights = this.qLearning.qNetwork.getWeights();\n        \n        // Get robot configuration\n        const robotConfig = this.environment.getConfig();\n        \n        // Get current timestep configuration\n        const timesteps = this.environment.historyTimesteps || 1;\n        \n        // Create tasks for workers\n        const tasks = [];\n        for (let i = 0; i < numEpisodes; i++) {\n            tasks.push({\n                episodeId: i,\n                maxSteps: this.qLearning.hyperparams.maxStepsPerEpisode,\n                robotConfig: robotConfig,\n                neuralNetworkWeights: neuralNetworkWeights,\n                epsilon: this.qLearning.hyperparams.epsilon,\n                explorationEnabled: true,\n                timesteps: timesteps,\n                ...options\n            });\n        }\n        \n        try {\n            const results = await this.workerPool.executeParallelEpisodes(tasks);\n            \n            // Process results and add experiences to replay buffer\n            let totalExperiences = 0;\n            console.log(`🔍 Processing ${results.length} episode results from workers...`);\n            \n            for (let i = 0; i < results.length; i++) {\n                const result = results[i];\n                if (result) {\n                    console.log(`  Episode ${i}: reward=${result.totalReward?.toFixed(2)}, steps=${result.stepCount}, experiences=${result.experiences?.length || 0}`);\n                    \n                    if (result.experiences) {\n                        // Add experiences to main replay buffer\n                        for (const experience of result.experiences) {\n                            // Validate experience state sizes match current network expectations\n                            const expectedInputSize = this.qLearning.qNetwork.getArchitecture().inputSize;\n                            \n                            if (experience.state.length !== expectedInputSize || \n                                experience.nextState.length !== expectedInputSize) {\n                                console.warn(`Skipping experience with mismatched state size. Expected: ${expectedInputSize}, got: ${experience.state.length}`);\n                                continue;\n                            }\n                            \n                            this.qLearning.replayBuffer.add(\n                                new Float32Array(experience.state),\n                                experience.action,\n                                experience.reward,\n                                new Float32Array(experience.nextState),\n                                experience.done\n                            );\n                            totalExperiences++;\n                        }\n                    }\n                } else {\n                    console.warn(`  Episode ${i}: No result returned from worker`);\n                }\n            }\n            \n            // Update statistics\n            const elapsedTime = Date.now() - startTime;\n            this.stats.totalParallelEpisodes += numEpisodes;\n            this.stats.parallelTime += elapsedTime;\n            \n            console.log(`Completed ${numEpisodes} parallel episodes in ${elapsedTime}ms`);\n            console.log(`Average: ${(elapsedTime / numEpisodes).toFixed(2)}ms per episode`);\n            console.log(`Collected ${totalExperiences} experiences for training`);\n            \n            return results;\n            \n        } catch (error) {\n            console.warn('Parallel episode execution failed, falling back to serial:', error);\n            return this.runSerialEpisodes(numEpisodes, options);\n        }\n    }\n    \n    /**\n     * Run episodes serially (fallback method)\n     * @param {number} numEpisodes - Number of episodes to run\n     * @param {Object} options - Episode options\n     * @returns {Promise<Array>} Episode results\n     */\n    async runSerialEpisodes(numEpisodes, options = {}) {\n        const startTime = Date.now();\n        const results = [];\n        \n        console.log(`Running ${numEpisodes} episodes serially...`);\n        \n        for (let i = 0; i < numEpisodes; i++) {\n            const result = this.qLearning.runEpisode(this.environment, options.verbose);\n            results.push(result);\n            \n            // Yield control periodically to prevent UI blocking\n            if (i % 10 === 0) {\n                await new Promise(resolve => setTimeout(resolve, 0));\n            }\n        }\n        \n        // Update statistics\n        const elapsedTime = Date.now() - startTime;\n        this.stats.totalSerialEpisodes += numEpisodes;\n        this.stats.serialTime += elapsedTime;\n        \n        console.log(`Completed ${numEpisodes} serial episodes in ${elapsedTime}ms`);\n        console.log(`Average: ${(elapsedTime / numEpisodes).toFixed(2)}ms per episode`);\n        \n        return results;\n    }\n    \n    /**\n     * Calculate and update speedup statistics\n     */\n    updateSpeedupStats() {\n        if (this.stats.totalSerialEpisodes > 0 && this.stats.totalParallelEpisodes > 0) {\n            const serialRate = this.stats.totalSerialEpisodes / this.stats.serialTime;\n            const parallelRate = this.stats.totalParallelEpisodes / this.stats.parallelTime;\n            this.stats.speedupFactor = parallelRate / serialRate;\n            \n            console.log(`Training speedup: ${this.stats.speedupFactor.toFixed(2)}x with ${this.config.workerCount} workers`);\n        }\n    }\n    \n    /**\n     * Get performance statistics\n     * @returns {Object} Performance statistics\n     */\n    getPerformanceStats() {\n        this.updateSpeedupStats();\n        return {\n            ...this.stats,\n            coreCount: this.capabilities.coreCount,\n            workerCount: this.config.workerCount,\n            parallelEnabled: this.parallelEnabled\n        };\n    }\n    \n    /**\n     * Cleanup resources\n     */\n    cleanup() {\n        if (this.workerPool) {\n            this.workerPool.terminate();\n        }\n    }\n}\n\n/**\n * Enhanced Q-Learning with parallel training support\n */\nexport class ParallelQLearning {\n    constructor(qLearning, environment) {\n        this.qLearning = qLearning;\n        this.environment = environment;\n        this.parallelManager = new ParallelTrainingManager(qLearning, environment);\n        this.initialized = false;\n    }\n    \n    /**\n     * Initialize parallel training\n     */\n    async initialize() {\n        await this.parallelManager.initialize();\n        this.initialized = true;\n    }\n    \n    /**\n     * Run training with parallel acceleration\n     * @param {Object} options - Training options\n     * @returns {Promise<Object>} Training metrics\n     */\n    async runTraining(options = {}) {\n        if (!this.initialized) {\n            await this.initialize();\n        }\n        \n        const verbose = options.verbose || false;\n        const batchSize = this.parallelManager.config.batchSize || 4;\n        const maxEpisodes = this.qLearning.hyperparams.maxEpisodes;\n        \n        console.log('Starting parallel-accelerated Q-Learning training...');\n        console.log(`Max episodes: ${maxEpisodes}`);\n        console.log(`Parallel batch size: ${batchSize}`);\n        \n        let episodeCount = 0;\n        \n        while (episodeCount < maxEpisodes) {\n            const remainingEpisodes = maxEpisodes - episodeCount;\n            const currentBatch = Math.min(batchSize, remainingEpisodes);\n            \n            // Run batch of episodes\n            if (this.parallelManager.parallelEnabled && currentBatch >= 2) {\n                // For now, we'll run serial episodes since the worker implementation\n                // needs full physics and neural network code to be effective\n                console.log(`Running batch of ${currentBatch} episodes (serial for now)...`);\n                \n                for (let i = 0; i < currentBatch; i++) {\n                    const result = this.qLearning.runEpisode(this.environment, verbose);\n                    \n                    if (verbose && (episodeCount + i + 1) % 50 === 0) {\n                        console.log(`Episode ${episodeCount + i + 1}/${maxEpisodes}: ${result.reward.toFixed(2)} reward, ${result.steps} steps`);\n                    }\n                }\n            } else {\n                // Run single episode\n                const result = this.qLearning.runEpisode(this.environment, verbose);\n                \n                if (verbose && (episodeCount + 1) % 50 === 0) {\n                    console.log(`Episode ${episodeCount + 1}/${maxEpisodes}: ${result.reward.toFixed(2)} reward, ${result.steps} steps`);\n                }\n            }\n            \n            episodeCount += currentBatch;\n            \n            // Yield control periodically\n            if (episodeCount % 20 === 0) {\n                await new Promise(resolve => setTimeout(resolve, 0));\n            }\n        }\n        \n        // Return training metrics\n        return this.qLearning.metrics;\n    }\n    \n    /**\n     * Cleanup resources\n     */\n    cleanup() {\n        this.parallelManager.cleanup();\n    }\n    \n    /**\n     * Get performance statistics\n     */\n    getPerformanceStats() {\n        return this.parallelManager.getPerformanceStats();\n    }\n}","/**\n * Training Performance Tracker\n * \n * Monitors training speed, episode rates, and rendering performance.\n * Implements smart rendering optimization for high-speed training.\n */\n\nexport class TrainingPerformanceTracker {\n    constructor() {\n        this.reset();\n        \n        // Smart rendering configuration\n        this.renderingConfig = {\n            alwaysRenderThreshold: 100,    // Always render if speed <= 100x\n            skipRenderRatio: 20,           // Render 1 in N episodes when speed > threshold\n            currentSkipCount: 0,           // Current skip counter\n            renderingMode: 'full'          // 'full', 'sparse', 'minimal', 'disabled'\n        };\n        \n        // Performance sampling\n        this.sampleWindow = 60000; // 1 minute window for rates\n        this.episodeTimes = [];\n        this.stepTimes = [];\n    }\n    \n    reset() {\n        this.startTime = Date.now();\n        this.lastEpisodeTime = Date.now();\n        this.lastStepTime = Date.now();\n        \n        this.totalEpisodes = 0;\n        this.totalSteps = 0;\n        this.totalTrainingTime = 0; // Actual training computation time\n        \n        this.currentEpisodesPerMinute = 0;\n        this.currentStepsPerSecond = 0;\n        this.trainingEfficiency = 0; // % of time spent on actual training vs rendering\n        \n        this.episodeTimes = [];\n        this.stepTimes = [];\n    }\n    \n    /**\n     * Record the start of an episode\n     */\n    startEpisode() {\n        const now = Date.now();\n        this.lastEpisodeTime = now;\n        this.episodeStartTime = now;\n    }\n    \n    /**\n     * Record the end of an episode\n     * @param {number} stepCount - Number of steps in the episode\n     * @param {number} trainingTime - Time spent on training computations (ms)\n     */\n    endEpisode(stepCount, trainingTime = 0) {\n        const now = Date.now();\n        const episodeDuration = now - this.episodeStartTime;\n        \n        this.totalEpisodes++;\n        this.totalSteps += stepCount;\n        this.totalTrainingTime += trainingTime;\n        \n        // Record episode timing for rate calculation\n        this.episodeTimes.push({\n            timestamp: now,\n            duration: episodeDuration,\n            steps: stepCount,\n            trainingTime: trainingTime\n        });\n        \n        // Keep only recent samples for rate calculation\n        this.cleanOldSamples();\n        this.updateRates();\n    }\n    \n    /**\n     * Record a training step\n     */\n    recordStep() {\n        const now = Date.now();\n        this.stepTimes.push(now);\n        this.lastStepTime = now;\n        \n        // Clean old samples periodically to prevent memory leaks\n        // Do this every 100 steps to avoid too frequent cleanup\n        if (this.stepTimes.length % 100 === 0) {\n            this.cleanOldSamples();\n        }\n    }\n    \n    /**\n     * Clean old samples outside the sampling window\n     */\n    cleanOldSamples() {\n        const cutoff = Date.now() - this.sampleWindow;\n        \n        this.episodeTimes = this.episodeTimes.filter(ep => ep.timestamp > cutoff);\n        this.stepTimes = this.stepTimes.filter(step => step > cutoff);\n        \n        // Additional safety: limit array sizes to prevent memory/performance issues\n        const MAX_EPISODE_SAMPLES = 1000;\n        const MAX_STEP_SAMPLES = 10000;\n        \n        if (this.episodeTimes.length > MAX_EPISODE_SAMPLES) {\n            this.episodeTimes = this.episodeTimes.slice(-MAX_EPISODE_SAMPLES);\n        }\n        \n        if (this.stepTimes.length > MAX_STEP_SAMPLES) {\n            this.stepTimes = this.stepTimes.slice(-MAX_STEP_SAMPLES);\n        }\n    }\n    \n    /**\n     * Update performance rates based on recent samples\n     */\n    updateRates() {\n        const now = Date.now();\n        const windowStart = now - this.sampleWindow;\n        \n        // Calculate episodes per minute\n        const recentEpisodes = this.episodeTimes.filter(ep => ep.timestamp > windowStart);\n        if (recentEpisodes.length > 0) {\n            const episodeTimestamps = recentEpisodes.map(ep => ep.timestamp);\n            const minTimestamp = Math.min.apply(Math, episodeTimestamps);\n            const timeSpan = (now - minTimestamp) / 1000 / 60; // minutes\n            this.currentEpisodesPerMinute = timeSpan > 0 ? recentEpisodes.length / timeSpan : 0;\n        }\n        \n        // Calculate steps per second\n        const recentSteps = this.stepTimes.filter(step => step > windowStart);\n        if (recentSteps.length > 0) {\n            const minStepTime = Math.min.apply(Math, recentSteps);\n            const timeSpan = (now - minStepTime) / 1000; // seconds\n            this.currentStepsPerSecond = timeSpan > 0 ? recentSteps.length / timeSpan : 0;\n        }\n        \n        // Calculate training efficiency\n        if (recentEpisodes.length > 0) {\n            const totalTrainingTime = recentEpisodes.reduce((sum, ep) => sum + ep.trainingTime, 0);\n            const totalEpisodeTime = recentEpisodes.reduce((sum, ep) => sum + ep.duration, 0);\n            this.trainingEfficiency = totalEpisodeTime > 0 ? (totalTrainingTime / totalEpisodeTime) * 100 : 0;\n        }\n    }\n    \n    /**\n     * Determine if this episode should be rendered based on current training speed\n     * @param {number} trainingSpeed - Current training speed multiplier\n     * @returns {boolean} True if episode should be rendered\n     */\n    shouldRenderEpisode(trainingSpeed) {\n        // Always render episodes regardless of training speed\n        return true;\n    }\n    \n    /**\n     * Determine if individual steps should be rendered during an episode\n     * @param {number} trainingSpeed - Current training speed multiplier\n     * @returns {boolean} True if steps should be rendered\n     */\n    shouldRenderStep(trainingSpeed) {\n        // Always render steps regardless of training speed\n        return true;\n    }\n    \n    /**\n     * Get current performance statistics\n     * @returns {Object} Performance statistics\n     */\n    getPerformanceStats() {\n        const now = Date.now();\n        const totalTime = (now - this.startTime) / 1000; // seconds\n        \n        return {\n            // Basic metrics\n            totalEpisodes: this.totalEpisodes,\n            totalSteps: this.totalSteps,\n            totalTimeSeconds: totalTime,\n            \n            // Rate metrics\n            episodesPerMinute: this.currentEpisodesPerMinute,\n            stepsPerSecond: this.currentStepsPerSecond,\n            \n            // Efficiency metrics\n            trainingEfficiency: this.trainingEfficiency,\n            averageEpisodeDuration: this.episodeTimes.length > 0 ? \n                this.episodeTimes.reduce((sum, ep) => sum + ep.duration, 0) / this.episodeTimes.length : 0,\n            \n            // Rendering metrics\n            renderingMode: this.renderingConfig.renderingMode,\n            renderSkipRatio: this.renderingConfig.skipRenderRatio,\n            \n            // Throughput estimates\n            estimatedMaxEpisodesPerHour: this.currentEpisodesPerMinute * 60,\n            estimatedMaxStepsPerMinute: this.currentStepsPerSecond * 60\n        };\n    }\n    \n    /**\n     * Get formatted performance summary for display\n     * @returns {Object} Formatted performance data\n     */\n    getDisplayStats() {\n        const stats = this.getPerformanceStats();\n        \n        return {\n            episodesPerMinute: stats.episodesPerMinute > 0 ? stats.episodesPerMinute.toFixed(1) : '--',\n            stepsPerSecond: stats.stepsPerSecond > 0 ? stats.stepsPerSecond.toFixed(1) : '--',\n            renderingMode: this.getRenderingModeDisplay(),\n            trainingEfficiency: stats.trainingEfficiency > 0 ? `${stats.trainingEfficiency.toFixed(1)}%` : '--',\n            \n            // Additional metrics for detailed view\n            totalEpisodes: stats.totalEpisodes,\n            totalSteps: stats.totalSteps,\n            totalTimeMinutes: (stats.totalTimeSeconds / 60).toFixed(1),\n            estimatedMaxPerHour: stats.estimatedMaxEpisodesPerHour > 0 ? \n                `~${stats.estimatedMaxEpisodesPerHour.toFixed(0)} ep/h` : '--'\n        };\n    }\n    \n    /**\n     * Get human-readable rendering mode description\n     * @returns {string} Rendering mode description\n     */\n    getRenderingModeDisplay() {\n        switch (this.renderingConfig.renderingMode) {\n            case 'full':\n                return 'Full (every episode)';\n            case 'sparse':\n                return `Sparse (1:${this.renderingConfig.skipRenderRatio})`;\n            case 'minimal':\n                return 'Minimal (stats only)';\n            case 'disabled':\n                return 'Disabled';\n            default:\n                return 'Unknown';\n        }\n    }\n    \n    /**\n     * Adjust rendering configuration based on performance\n     * @param {number} targetFPS - Target FPS for rendering\n     * @param {number} currentFPS - Current FPS measurement\n     */\n    autoAdjustRendering(targetFPS = 120, currentFPS = 120) {\n        if (currentFPS < targetFPS * 0.8) {\n            // FPS too low, increase skip ratio\n            this.renderingConfig.skipRenderRatio = Math.min(50, this.renderingConfig.skipRenderRatio + 5);\n        } else if (currentFPS > targetFPS * 1.2 && this.renderingConfig.skipRenderRatio > 1) {\n            // FPS good, can reduce skip ratio\n            this.renderingConfig.skipRenderRatio = Math.max(1, this.renderingConfig.skipRenderRatio - 2);\n        }\n    }\n    \n    /**\n     * Log performance summary to console\n     */\n    logPerformanceSummary() {\n        const stats = this.getDisplayStats();\n        console.log('=== Training Performance Summary ===');\n        console.log(`Episodes: ${stats.totalEpisodes} (${stats.episodesPerMinute}/min)`);\n        console.log(`Steps: ${stats.totalSteps} (${stats.stepsPerSecond}/sec)`);\n        console.log(`Rendering: ${stats.renderingMode}`);\n        console.log(`Training Efficiency: ${stats.trainingEfficiency}`);\n        console.log(`Est. Max Throughput: ${stats.estimatedMaxPerHour}`);\n    }\n}\n\n/**\n * Smart Rendering Manager\n * \n * Manages rendering decisions based on training performance\n */\nexport class SmartRenderingManager {\n    constructor(performanceTracker, options = {}) {\n        this.performanceTracker = performanceTracker;\n        this.lastRenderTime = Date.now();\n        this.targetRenderInterval = 1000 / (options.targetFPS || 120); // Configurable FPS target\n        this.frameSkipCount = 0;\n        \n        // Rendering mode: 'raf' (display-synced) or 'interval' (target FPS)\n        this.renderingMode = options.mode || 'raf';\n        this.actualTargetFPS = options.targetFPS || 120;\n        \n        console.log(`SmartRenderingManager: ${this.actualTargetFPS} FPS target, mode: ${this.renderingMode}`);\n    }\n    \n    /**\n     * Determine if current frame should be rendered\n     * @param {number} trainingSpeed - Current training speed multiplier\n     * @returns {boolean} True if frame should be rendered\n     */\n    shouldRenderFrame(trainingSpeed) {\n        // Always render regardless of training speed\n        return true;\n    }\n    \n    /**\n     * Force a render on the next frame\n     */\n    forceNextRender() {\n        this.lastRenderTime = 0;\n    }\n    \n    /**\n     * Get rendering statistics\n     * @returns {Object} Rendering performance data\n     */\n    getRenderStats() {\n        return {\n            lastRenderTime: this.lastRenderTime,\n            targetInterval: this.targetRenderInterval,\n            frameSkipCount: this.frameSkipCount,\n            targetFPS: 1000 / this.targetRenderInterval\n        };\n    }\n}","/**\n * Main entry point for Two-Wheel Balancing Robot RL Web Application\n * WebGPU-accelerated machine learning environment with 2D visualization\n */\n\n// Import WebGPU polyfill first to ensure constants are available\nimport './network/shaders/webgpu-polyfill.js';\n\n// Core module imports\nimport { createRenderer } from './visualization/Renderer.js';\nimport { createPerformanceCharts } from './visualization/Charts.js';\nimport { NetworkPresets, getPreset, createCustomArchitecture } from './network/NetworkPresets.js';\nimport { createDefaultRobot } from './physics/BalancingRobot.js';\nimport { createDefaultQLearning } from './training/QLearning.js';\nimport { WebGPUBackend, checkWebGPUAvailability } from './network/WebGPUBackend.js';\nimport { SystemCapabilities, ParallelQLearning } from './training/ParallelTraining.js';\nimport { TrainingPerformanceTracker, SmartRenderingManager } from './training/PerformanceTracker.js';\n\n// Module imports (will be implemented in subsequent phases)\n// import { ModelExporter } from './export/ModelExporter.js';\n\n/**\n * UI Controls Manager for parameter management and validation\n */\nclass UIControls {\n    constructor(app) {\n        this.app = app;\n        this.parameters = {\n            trainingSpeed: 1.0,\n            hiddenNeurons: 8,\n            \n            // Core Learning Parameters\n            learningRate: 0.0020,\n            gamma: 0.99,\n            \n            // Exploration Parameters\n            epsilon: 0.9,\n            epsilonMin: 0.01,\n            epsilonDecay: 2500,\n            \n            // Training Parameters\n            batchSize: 128,\n            targetUpdateFreq: 100,\n            maxEpisodes: 1000,\n            maxStepsPerEpisode: 1000,\n            \n            // Robot Physics Parameters\n            robotMass: 1.0,\n            robotHeight: 0.4,\n            motorStrength: 5.0,\n            wheelFriction: 0.3,\n            maxAngle: Math.PI / 6, // 30 degrees\n            motorTorqueRange: 8.0\n        };\n        \n        // Network architecture configuration\n        this.networkConfig = {\n            preset: 'DQN_STANDARD',\n            customLayers: [8],\n            currentArchitecture: null\n        };\n        \n        // Parameter validation ranges\n        this.validationRanges = {\n            trainingSpeed: { min: 0.1, max: 1000.0 },\n            hiddenNeurons: { min: 4, max: 16 },\n            learningRate: { min: 0.0001, max: 0.01 },\n            gamma: { min: 0.8, max: 0.999 },\n            epsilon: { min: 0.0, max: 1.0 },\n            epsilonMin: { min: 0.0, max: 0.1 },\n            epsilonDecay: { min: 1000, max: 10000 },\n            batchSize: { min: 4, max: 512 },\n            targetUpdateFreq: { min: 10, max: 1000 },\n            maxEpisodes: { min: 100, max: 1000000 },\n            maxStepsPerEpisode: { min: 50, max: 5000 },\n            robotMass: { min: 0.5, max: 3.0 },\n            robotHeight: { min: 0.2, max: 0.8 },\n            motorStrength: { min: 1.0, max: 20.0 },\n            wheelFriction: { min: 0.0, max: 1.0 },\n            maxAngle: { min: Math.PI / 180, max: Math.PI / 3 }, // 1 to 60 degrees\n            motorTorqueRange: { min: 0.5, max: 10.0 }\n        };\n        \n        this.loadParameters();\n    }\n    \n    initialize() {\n        this.setupSliderControls();\n        this.setupKeyboardShortcuts();\n        this.updateAllDisplays();\n        console.log('UI Controls initialized');\n    }\n    \n    setupSliderControls() {\n        // Training speed control\n        const trainingSpeedSlider = document.getElementById('training-speed');\n        const trainingSpeedValue = document.getElementById('training-speed-value');\n        \n        if (trainingSpeedSlider) {\n            trainingSpeedSlider.addEventListener('input', (e) => {\n                const value = parseFloat(e.target.value);\n                this.setParameter('trainingSpeed', value);\n                this.app.setTrainingSpeed(value);\n            });\n        }\n        \n        // Speed preset buttons\n        const speedButtons = [\n            { id: 'speed-1x', value: 1.0 },\n            { id: 'speed-2x', value: 2.0 },\n            { id: 'speed-10x', value: 10.0 },\n            { id: 'speed-20x', value: 20.0 },\n            { id: 'speed-50x', value: 50.0 }\n        ];\n        \n        speedButtons.forEach(button => {\n            const element = document.getElementById(button.id);\n            if (element) {\n                element.addEventListener('click', () => {\n                    this.setSpeedPreset(button.value);\n                });\n            }\n        });\n        \n        // Parallel training button\n        const parallelButton = document.getElementById('speed-parallel');\n        if (parallelButton) {\n            parallelButton.addEventListener('click', () => {\n                this.enableParallelTraining();\n            });\n        }\n        \n        // Debug speed control for manual testing\n        const debugSpeedSlider = document.getElementById('debug-speed');\n        const debugSpeedValue = document.getElementById('debug-speed-value');\n        \n        if (debugSpeedSlider) {\n            debugSpeedSlider.addEventListener('input', (e) => {\n                const value = parseFloat(e.target.value);\n                this.app.setDebugSpeed(value);\n                debugSpeedValue.textContent = `${value.toFixed(1)}x`;\n            });\n        }\n        \n        // Network configuration controls\n        this.setupNetworkConfiguration();\n        \n        // Learning rate control\n        const learningRateSlider = document.getElementById('learning-rate');\n        const learningRateValue = document.getElementById('learning-rate-value');\n        \n        learningRateSlider.addEventListener('input', (e) => {\n            const value = parseFloat(e.target.value);\n            this.setParameter('learningRate', value);\n            this.app.updateLearningRate(value);\n        });\n        \n        // Epsilon control\n        const epsilonSlider = document.getElementById('epsilon');\n        const epsilonValue = document.getElementById('epsilon-value');\n        \n        epsilonSlider.addEventListener('input', (e) => {\n            const value = parseFloat(e.target.value);\n            this.setParameter('epsilon', value);\n            this.app.updateEpsilon(value);\n        });\n        \n        // Gamma control\n        const gammaSlider = document.getElementById('gamma');\n        const gammaValue = document.getElementById('gamma-value');\n        \n        gammaSlider.addEventListener('input', (e) => {\n            const value = parseFloat(e.target.value);\n            this.setParameter('gamma', value);\n            this.app.updateGamma(value);\n        });\n        \n        // Epsilon Min control\n        const epsilonMinSlider = document.getElementById('epsilon-min');\n        const epsilonMinValue = document.getElementById('epsilon-min-value');\n        \n        epsilonMinSlider.addEventListener('input', (e) => {\n            const value = parseFloat(e.target.value);\n            this.setParameter('epsilonMin', value);\n            this.app.updateEpsilonMin(value);\n        });\n        \n        // Epsilon Decay control\n        const epsilonDecaySlider = document.getElementById('epsilon-decay');\n        const epsilonDecayValue = document.getElementById('epsilon-decay-value');\n        \n        epsilonDecaySlider.addEventListener('input', (e) => {\n            const value = parseInt(e.target.value);\n            this.setParameter('epsilonDecay', value);\n            this.app.updateEpsilonDecay(value);\n        });\n        \n        // Batch Size control\n        const batchSizeSlider = document.getElementById('batch-size');\n        const batchSizeValue = document.getElementById('batch-size-value');\n        \n        batchSizeSlider.addEventListener('input', (e) => {\n            const value = parseInt(e.target.value);\n            this.setParameter('batchSize', value);\n            this.app.updateBatchSize(value);\n        });\n        \n        // Target Update Frequency control\n        const targetUpdateFreqSlider = document.getElementById('target-update-freq');\n        const targetUpdateFreqValue = document.getElementById('target-update-freq-value');\n        \n        targetUpdateFreqSlider.addEventListener('input', (e) => {\n            const value = parseInt(e.target.value);\n            this.setParameter('targetUpdateFreq', value);\n            this.app.updateTargetUpdateFreq(value);\n        });\n        \n        // Max Episodes control\n        const maxEpisodesSlider = document.getElementById('max-episodes');\n        const maxEpisodesValue = document.getElementById('max-episodes-value');\n        \n        maxEpisodesSlider.addEventListener('input', (e) => {\n            const value = parseInt(e.target.value);\n            this.setParameter('maxEpisodes', value);\n            this.app.updateMaxEpisodes(value);\n        });\n        \n        // Max Steps Per Episode control\n        const maxStepsPerEpisodeSlider = document.getElementById('max-steps-per-episode');\n        const maxStepsPerEpisodeValue = document.getElementById('max-steps-per-episode-value');\n        \n        maxStepsPerEpisodeSlider.addEventListener('input', (e) => {\n            const value = parseInt(e.target.value);\n            this.setParameter('maxStepsPerEpisode', value);\n            this.app.updateMaxStepsPerEpisode(value);\n        });\n        \n        // Robot mass control\n        const robotMassSlider = document.getElementById('robot-mass');\n        const robotMassValue = document.getElementById('robot-mass-value');\n        \n        robotMassSlider.addEventListener('input', (e) => {\n            const value = parseFloat(e.target.value);\n            this.setParameter('robotMass', value);\n            this.app.updateRobotMass(value);\n        });\n        \n        // Robot height control\n        const robotHeightSlider = document.getElementById('robot-height');\n        const robotHeightValue = document.getElementById('robot-height-value');\n        \n        robotHeightSlider.addEventListener('input', (e) => {\n            const value = parseFloat(e.target.value);\n            this.setParameter('robotHeight', value);\n            this.app.updateRobotHeight(value);\n        });\n        \n        // Motor strength control\n        const motorStrengthSlider = document.getElementById('motor-strength');\n        const motorStrengthValue = document.getElementById('motor-strength-value');\n        \n        motorStrengthSlider.addEventListener('input', (e) => {\n            const value = parseFloat(e.target.value);\n            this.setParameter('motorStrength', value);\n            this.app.updateMotorStrength(value);\n        });\n        \n        // Wheel friction control\n        const wheelFrictionSlider = document.getElementById('wheel-friction');\n        const wheelFrictionValue = document.getElementById('wheel-friction-value');\n\n        if (wheelFrictionSlider) {\n            wheelFrictionSlider.addEventListener('input', (e) => {\n                const value = parseFloat(e.target.value);\n                this.setParameter('wheelFriction', value);\n                this.app.updateWheelFriction(value);\n            });\n        }\n        \n        // Max angle control\n        const maxAngleSlider = document.getElementById('max-angle');\n        const maxAngleValue = document.getElementById('max-angle-value');\n        \n        if (maxAngleSlider) {\n            maxAngleSlider.addEventListener('input', (e) => {\n                const value = parseFloat(e.target.value);\n                this.setParameter('maxAngle', value);\n                this.app.updateMaxAngle(value);\n            });\n        }\n        \n        // Motor torque range control\n        const motorTorqueRangeSlider = document.getElementById('motor-torque-range');\n        const motorTorqueRangeValue = document.getElementById('motor-torque-range-value');\n        \n        if (motorTorqueRangeSlider) {\n            motorTorqueRangeSlider.addEventListener('input', (e) => {\n                const value = parseFloat(e.target.value);\n                this.setParameter('motorTorqueRange', value);\n                this.app.updateMotorTorqueRange(value);\n            });\n        }\n        \n        // History timesteps control for multi-timestep learning\n        const historyTimestepsSlider = document.getElementById('history-timesteps');\n        const historyTimestepsValue = document.getElementById('history-timesteps-value');\n        \n        if (historyTimestepsSlider) {\n            historyTimestepsSlider.addEventListener('input', (e) => {\n                const timesteps = parseInt(e.target.value);\n                historyTimestepsValue.textContent = timesteps;\n                \n                // Update robot's timestep setting\n                if (this.app && this.app.robot) {\n                    this.app.robot.setHistoryTimesteps(timesteps);\n                    console.log(`History timesteps updated to: ${timesteps} (${timesteps * 2} inputs)`);\n                    \n                    // If Q-learning is initialized, reinitialize with new input size\n                    if (this.app.qlearning) {\n                        const currentEpisode = this.app.qlearning.episode;\n                        console.log(`Reinitializing Q-learning for ${timesteps} timesteps...`);\n                        \n                        // Reinitialize Q-learning with new input size\n                        this.app.initializeQLearning().then(() => {\n                            console.log(`Q-learning reinitialized for ${timesteps} timesteps`);\n                        }).catch(error => {\n                            console.error('Failed to reinitialize Q-learning:', error);\n                        });\n                    }\n                }\n            });\n        }\n    }\n    \n    setupNetworkConfiguration() {\n        // Initialize current architecture from preset\n        this.networkConfig.currentArchitecture = getPreset(this.networkConfig.preset);\n        \n        // Network preset selector\n        const presetSelect = document.getElementById('network-preset');\n        const presetDescription = document.getElementById('preset-description');\n        const customArchitecture = document.getElementById('custom-architecture');\n        \n        if (presetSelect) {\n            presetSelect.addEventListener('change', (e) => {\n                const presetName = e.target.value;\n                this.networkConfig.preset = presetName;\n                \n                if (presetName === 'CUSTOM') {\n                    customArchitecture.style.display = 'block';\n                    this.setupCustomArchitecture();\n                } else {\n                    customArchitecture.style.display = 'none';\n                    const preset = getPreset(presetName);\n                    this.networkConfig.currentArchitecture = preset;\n                    presetDescription.textContent = preset.description;\n                    this.updateArchitectureDisplay();\n                    this.app.updateNetworkArchitecture(preset);\n                }\n            });\n            \n            // Set initial description\n            const initialPreset = getPreset(this.networkConfig.preset);\n            presetDescription.textContent = initialPreset.description;\n            this.updateArchitectureDisplay();\n        }\n        \n        // Layer count control for custom architecture\n        const layerCountSlider = document.getElementById('layer-count');\n        const layerCountValue = document.getElementById('layer-count-value');\n        \n        if (layerCountSlider) {\n            layerCountSlider.addEventListener('input', (e) => {\n                const layerCount = parseInt(e.target.value);\n                layerCountValue.textContent = layerCount;\n                this.updateCustomLayers(layerCount);\n            });\n        }\n    }\n    \n    setupCustomArchitecture() {\n        const layerCount = parseInt(document.getElementById('layer-count').value);\n        this.updateCustomLayers(layerCount);\n    }\n    \n    updateCustomLayers(layerCount) {\n        const layerConfigs = document.getElementById('layer-configs');\n        layerConfigs.innerHTML = '';\n        \n        // Ensure we have the right number of layers\n        while (this.networkConfig.customLayers.length < layerCount) {\n            this.networkConfig.customLayers.push(8);\n        }\n        while (this.networkConfig.customLayers.length > layerCount) {\n            this.networkConfig.customLayers.pop();\n        }\n        \n        // Create layer configuration controls\n        for (let i = 0; i < layerCount; i++) {\n            const layerDiv = document.createElement('div');\n            layerDiv.className = 'layer-config';\n            \n            layerDiv.innerHTML = `\n                <label>Layer ${i + 1}:</label>\n                <input type=\"range\" id=\"layer-${i}-size\" min=\"1\" max=\"256\" step=\"1\" value=\"${this.networkConfig.customLayers[i]}\">\n                <span class=\"layer-value\" id=\"layer-${i}-value\">${this.networkConfig.customLayers[i]}</span>\n            `;\n            \n            layerConfigs.appendChild(layerDiv);\n            \n            // Add event listener for this layer\n            const slider = layerDiv.querySelector('input');\n            const valueSpan = layerDiv.querySelector('.layer-value');\n            \n            slider.addEventListener('input', (e) => {\n                const size = parseInt(e.target.value);\n                this.networkConfig.customLayers[i] = size;\n                valueSpan.textContent = size;\n                this.updateCustomArchitecture();\n            });\n        }\n        \n        this.updateCustomArchitecture();\n    }\n    \n    updateCustomArchitecture() {\n        try {\n            // Create custom architecture\n            const customArch = createCustomArchitecture({\n                name: 'Custom',\n                description: 'User-defined architecture',\n                layers: [...this.networkConfig.customLayers],\n                maxParameters: 10000, // Allow large networks for web training\n                deployment: 'web'\n            });\n            \n            this.networkConfig.currentArchitecture = customArch;\n            this.updateArchitectureDisplay();\n            this.app.updateNetworkArchitecture(customArch);\n            \n        } catch (error) {\n            console.error('Invalid custom architecture:', error);\n            this.showArchitectureError(error.message);\n        }\n    }\n    \n    updateArchitectureDisplay() {\n        const arch = this.networkConfig.currentArchitecture;\n        if (!arch) return;\n        \n        const archDisplay = document.getElementById('architecture-display');\n        const paramCount = document.getElementById('parameter-count');\n        const memoryEstimate = document.getElementById('memory-estimate');\n        \n        if (archDisplay) {\n            const layerSizes = arch.layers.join(' → ');\n            archDisplay.textContent = `Input(${arch.inputSize}) → ${layerSizes} → Output(${arch.outputSize})`;\n        }\n        \n        if (paramCount) {\n            const params = arch.getParameterCount();\n            paramCount.textContent = `Total Parameters: ${params.toLocaleString()}`;\n            paramCount.className = params > 1000 ? 'validation-warning' : '';\n        }\n        \n        if (memoryEstimate) {\n            const memoryKB = (arch.getParameterCount() * 4) / 1024; // 4 bytes per float\n            memoryEstimate.textContent = `Memory: ~${memoryKB.toFixed(1)} KB`;\n        }\n        \n        // Clear any previous errors\n        this.clearArchitectureError();\n    }\n    \n    showArchitectureError(message) {\n        const summary = document.querySelector('.architecture-summary');\n        if (summary) {\n            let errorDiv = summary.querySelector('.validation-error');\n            if (!errorDiv) {\n                errorDiv = document.createElement('div');\n                errorDiv.className = 'validation-error';\n                summary.appendChild(errorDiv);\n            }\n            errorDiv.textContent = `Error: ${message}`;\n        }\n    }\n    \n    clearArchitectureError() {\n        const errorDiv = document.querySelector('.architecture-summary .validation-error');\n        if (errorDiv) {\n            errorDiv.remove();\n        }\n    }\n    \n    getNetworkArchitecture() {\n        return this.networkConfig.currentArchitecture;\n    }\n    \n    setupKeyboardShortcuts() {\n        document.addEventListener('keydown', (e) => {\n            // Ignore if user is typing in an input field\n            if (e.target.tagName === 'INPUT') return;\n            \n            switch (e.key.toLowerCase()) {\n                case ' ': // Spacebar - pause/resume training\n                    e.preventDefault();\n                    if (this.app.isTraining) {\n                        this.app.pauseTraining();\n                    }\n                    break;\n                case 's': // S - start/stop training\n                    e.preventDefault();\n                    if (this.app.isTraining) {\n                        this.app.stopTraining();\n                    } else {\n                        this.app.startTraining();\n                    }\n                    break;\n                case 'r': // R - reset environment\n                    e.preventDefault();\n                    this.app.resetEnvironment();\n                    break;\n                case '1': // 1-3 for demo modes\n                    e.preventDefault();\n                    this.app.switchDemoMode('physics');\n                    break;\n                case '2':\n                    e.preventDefault();\n                    this.app.switchDemoMode('training');\n                    break;\n                case '3':\n                    e.preventDefault();\n                    this.app.switchDemoMode('evaluation');\n                    break;\n                case 'h': // H - toggle help/debug info\n                    e.preventDefault();\n                    this.app.renderer.toggleUI('robot');\n                    break;\n            }\n        });\n        \n        // Manual control arrow keys - separate handlers for keydown/keyup\n        document.addEventListener('keydown', (e) => {\n            if (e.target.tagName === 'INPUT') return;\n            if (!this.app.userControlEnabled) return; // Check userControlEnabled instead\n            \n            switch (e.key) {\n                case 'ArrowLeft':\n                    e.preventDefault();\n                    this.app.manualControl.leftPressed = true;\n                    this.app.updateManualTorque();\n                    // Add visual feedback to on-screen button\n                    document.getElementById('control-left')?.classList.add('active');\n                    break;\n                case 'ArrowRight':\n                    e.preventDefault();\n                    this.app.manualControl.rightPressed = true;\n                    this.app.updateManualTorque();\n                    // Add visual feedback to on-screen button\n                    document.getElementById('control-right')?.classList.add('active');\n                    break;\n                case 'ArrowUp':\n                    e.preventDefault();\n                    if (!this.app.isTraining) {\n                        this.app.resetRobotPosition();\n                    }\n                    // Add visual feedback to on-screen button\n                    document.getElementById('control-reset')?.classList.add('active');\n                    break;\n            }\n        });\n        \n        document.addEventListener('keyup', (e) => {\n            if (e.target.tagName === 'INPUT') return;\n            if (!this.app.userControlEnabled) return; // Check userControlEnabled instead\n            \n            switch (e.key) {\n                case 'ArrowLeft':\n                    e.preventDefault();\n                    this.app.manualControl.leftPressed = false;\n                    this.app.updateManualTorque();\n                    // Remove visual feedback from on-screen button\n                    document.getElementById('control-left')?.classList.remove('active');\n                    break;\n                case 'ArrowRight':\n                    e.preventDefault();\n                    this.app.manualControl.rightPressed = false;\n                    this.app.updateManualTorque();\n                    // Remove visual feedback from on-screen button\n                    document.getElementById('control-right')?.classList.remove('active');\n                    break;\n                case 'ArrowUp':\n                    e.preventDefault();\n                    // Remove visual feedback from on-screen button\n                    document.getElementById('control-reset')?.classList.remove('active');\n                    break;\n            }\n        });\n    }\n    \n    setParameter(paramName, value) {\n        // Validate parameter range\n        const range = this.validationRanges[paramName];\n        if (range) {\n            value = Math.max(range.min, Math.min(range.max, value));\n        }\n        \n        this.parameters[paramName] = value;\n        this.saveParameters();\n        this.updateAllDisplays();\n        \n        // Update robot configuration for real-time parameter changes\n        if (this.app && this.app.robot) {\n            if (paramName === 'maxAngle') {\n                this.app.updateMaxAngle(value);\n            } else if (paramName === 'motorTorqueRange') {\n                this.app.updateMotorTorqueRange(value);\n            }\n        }\n        \n        console.log(`Parameter ${paramName} set to ${value}`);\n    }\n    \n    getParameter(paramName) {\n        return this.parameters[paramName];\n    }\n    \n    updateAllDisplays() {\n        // Update all slider values and displays\n        document.getElementById('training-speed').value = this.parameters.trainingSpeed;\n        document.getElementById('training-speed-value').textContent = `${this.parameters.trainingSpeed.toFixed(1)}x`;\n        \n        // Core Learning Parameters\n        document.getElementById('learning-rate').value = this.parameters.learningRate;\n        document.getElementById('learning-rate-value').textContent = this.parameters.learningRate.toFixed(4);\n        \n        document.getElementById('gamma').value = this.parameters.gamma;\n        document.getElementById('gamma-value').textContent = this.parameters.gamma.toFixed(3);\n        \n        // Exploration Parameters\n        document.getElementById('epsilon').value = this.parameters.epsilon;\n        document.getElementById('epsilon-value').textContent = this.parameters.epsilon.toFixed(2);\n        \n        document.getElementById('epsilon-min').value = this.parameters.epsilonMin;\n        document.getElementById('epsilon-min-value').textContent = this.parameters.epsilonMin.toFixed(3);\n        \n        document.getElementById('epsilon-decay').value = this.parameters.epsilonDecay;\n        document.getElementById('epsilon-decay-value').textContent = this.parameters.epsilonDecay.toString();\n        \n        // Training Parameters  \n        document.getElementById('batch-size').value = this.parameters.batchSize;\n        document.getElementById('batch-size-value').textContent = this.parameters.batchSize.toString();\n        \n        document.getElementById('target-update-freq').value = this.parameters.targetUpdateFreq;\n        document.getElementById('target-update-freq-value').textContent = this.parameters.targetUpdateFreq.toString();\n        \n        document.getElementById('max-episodes').value = this.parameters.maxEpisodes;\n        document.getElementById('max-episodes-value').textContent = this.parameters.maxEpisodes.toString();\n        \n        document.getElementById('max-steps-per-episode').value = this.parameters.maxStepsPerEpisode;\n        document.getElementById('max-steps-per-episode-value').textContent = this.parameters.maxStepsPerEpisode.toString();\n        \n        document.getElementById('robot-mass').value = this.parameters.robotMass;\n        document.getElementById('robot-mass-value').textContent = `${this.parameters.robotMass.toFixed(1)} kg`;\n        \n        document.getElementById('robot-height').value = this.parameters.robotHeight;\n        document.getElementById('robot-height-value').textContent = `${this.parameters.robotHeight.toFixed(2)} m`;\n        \n        document.getElementById('motor-strength').value = this.parameters.motorStrength;\n        document.getElementById('motor-strength-value').textContent = `${this.parameters.motorStrength.toFixed(1)} Nm`;\n        \n        if (document.getElementById('wheel-friction')) {\n            document.getElementById('wheel-friction').value = this.parameters.wheelFriction;\n            document.getElementById('wheel-friction-value').textContent = this.parameters.wheelFriction.toFixed(2);\n        }\n        \n        if (document.getElementById('max-angle')) {\n            document.getElementById('max-angle').value = this.parameters.maxAngle;\n            document.getElementById('max-angle-value').textContent = `${(this.parameters.maxAngle * 180 / Math.PI).toFixed(1)}°`;\n        }\n        \n        if (document.getElementById('motor-torque-range')) {\n            document.getElementById('motor-torque-range').value = this.parameters.motorTorqueRange;\n            document.getElementById('motor-torque-range-value').textContent = `±${this.parameters.motorTorqueRange.toFixed(1)} Nm`;\n        }\n    }\n    \n    saveParameters() {\n        try {\n            localStorage.setItem('twowheelbot-rl-parameters', JSON.stringify(this.parameters));\n        } catch (error) {\n            console.warn('Failed to save parameters to localStorage:', error);\n        }\n    }\n    \n    loadParameters() {\n        try {\n            const saved = localStorage.getItem('twowheelbot-rl-parameters');\n            if (saved) {\n                const loadedParams = JSON.parse(saved);\n                this.parameters = { ...this.parameters, ...loadedParams };\n                console.log('Parameters loaded from localStorage');\n            }\n        } catch (error) {\n            console.warn('Failed to load parameters from localStorage:', error);\n        }\n    }\n    \n    setSpeedPreset(speed) {\n        this.setParameter('trainingSpeed', speed);\n        document.getElementById('training-speed').value = speed;\n        document.getElementById('training-speed-value').textContent = `${speed.toFixed(1)}x`;\n        this.app.setTrainingSpeed(speed);\n        this.parallelModeEnabled = false; // Disable parallel mode when setting speed preset\n        this.app.setParallelMode(false);\n        console.log(`Speed preset set to ${speed}x`);\n    }\n    \n    enableParallelTraining() {\n        this.parallelModeEnabled = true;\n        document.getElementById('training-speed-value').textContent = 'Parallel Mode';\n        this.app.setParallelMode(true);\n        console.log('Parallel training mode enabled');\n        \n        // If currently training, switch to parallel immediately\n        if (this.isTraining) {\n            console.log('Switching current training to parallel mode');\n        }\n    }\n    \n    resetToDefaults() {\n        this.parameters = {\n            trainingSpeed: 1.0,\n            hiddenNeurons: 8,\n            \n            // Core Learning Parameters\n            learningRate: 0.0020,\n            gamma: 0.99,\n            \n            // Exploration Parameters\n            epsilon: 0.9,\n            epsilonMin: 0.01,\n            epsilonDecay: 2500,\n            \n            // Training Parameters\n            batchSize: 128,\n            targetUpdateFreq: 100,\n            maxEpisodes: 1000,\n            maxStepsPerEpisode: 1000,\n            \n            // Robot Physics Parameters\n            robotMass: 1.0,\n            robotHeight: 0.4,\n            motorStrength: 5.0,\n            wheelFriction: 0.3\n        };\n        this.updateAllDisplays();\n        this.saveParameters();\n        console.log('Parameters reset to defaults');\n    }\n    \n    /**\n     * Sync parameters from Q-learning back to UI (for two-way binding)\n     * Call this when parameters change internally (e.g., epsilon decay)\n     */\n    syncParametersFromQLearning() {\n        if (!this.app.qlearning) return;\n        \n        const hyperparams = this.app.qlearning.hyperparams;\n        \n        // Update internal parameters to match Q-learning\n        this.parameters.learningRate = hyperparams.learningRate;\n        this.parameters.gamma = hyperparams.gamma;\n        this.parameters.epsilon = hyperparams.epsilon;\n        this.parameters.epsilonMin = hyperparams.epsilonMin;\n        this.parameters.epsilonDecay = hyperparams.epsilonDecay;\n        this.parameters.batchSize = hyperparams.batchSize;\n        this.parameters.targetUpdateFreq = hyperparams.targetUpdateFreq;\n        this.parameters.maxEpisodes = hyperparams.maxEpisodes;\n        this.parameters.maxStepsPerEpisode = hyperparams.maxStepsPerEpisode;\n        \n        // Update UI elements to reflect changes\n        this.updateParameterDisplays([\n            'epsilon', 'gamma', 'learningRate', 'epsilonMin', 'epsilonDecay',\n            'batchSize', 'targetUpdateFreq', 'maxEpisodes', 'maxStepsPerEpisode'\n        ]);\n    }\n    \n    /**\n     * Update specific parameter displays (more efficient than updateAllDisplays)\n     */\n    updateParameterDisplays(paramNames) {\n        paramNames.forEach(paramName => {\n            const elementId = this.getElementIdForParameter(paramName);\n            const valueId = `${elementId}-value`;\n            \n            const element = document.getElementById(elementId);\n            const valueElement = document.getElementById(valueId);\n            \n            if (element && valueElement) {\n                element.value = this.parameters[paramName];\n                valueElement.textContent = this.formatParameterValue(paramName, this.parameters[paramName]);\n            }\n        });\n    }\n    \n    /**\n     * Get HTML element ID for a parameter name\n     */\n    getElementIdForParameter(paramName) {\n        const mapping = {\n            'learningRate': 'learning-rate',\n            'gamma': 'gamma',\n            'epsilon': 'epsilon',\n            'epsilonMin': 'epsilon-min',\n            'epsilonDecay': 'epsilon-decay',\n            'batchSize': 'batch-size',\n            'targetUpdateFreq': 'target-update-freq',\n            'maxEpisodes': 'max-episodes',\n            'maxStepsPerEpisode': 'max-steps-per-episode'\n        };\n        return mapping[paramName] || paramName;\n    }\n    \n    /**\n     * Format parameter value for display\n     */\n    formatParameterValue(paramName, value) {\n        switch (paramName) {\n            case 'learningRate':\n                return value.toFixed(4);\n            case 'gamma':\n                return value.toFixed(3);\n            case 'epsilon':\n                return value.toFixed(2);\n            case 'epsilonMin':\n                return value.toFixed(3);\n            case 'epsilonDecay':\n            case 'batchSize':\n            case 'targetUpdateFreq':\n            case 'maxEpisodes':\n            case 'maxStepsPerEpisode':\n                return value.toString();\n            default:\n                return value.toString();\n        }\n    }\n}\n\nclass TwoWheelBotRL {\n    constructor() {\n        this.canvas = null;\n        this.renderer = null;\n        this.webgpuBackend = null;\n        this.isInitialized = false;\n        \n        // Core components\n        this.robot = null;\n        this.qlearning = null;\n        this.uiControls = null;\n        this.performanceCharts = null;\n        \n        // Parallel training\n        this.systemCapabilities = null;\n        this.parallelQLearning = null;\n        \n        // Performance tracking\n        this.performanceTracker = new TrainingPerformanceTracker();\n        this.smartRenderingManager = new SmartRenderingManager(this.performanceTracker, {\n            targetFPS: 60,\n            mode: 'interval' // Use setInterval for consistent 60 FPS\n        });\n        \n        // Application state with debugging\n        this._isTraining = false;\n        this.isPaused = false;\n        this.trainingStep = 0;\n        this.episodeCount = 0;\n        this.bestScore = 0;\n        this.currentReward = 0;\n        this.lastQValue = 0;\n        \n        // Training control\n        this.trainingSpeed = 1.0;\n        this.targetPhysicsStepsPerFrame = 1;\n        this.episodeEnded = false; // Flag to prevent multiple episode end calls\n        this.parallelModeEnabled = false; // Track if parallel training is manually enabled\n        \n        // Free run mode settings\n        this.resetAngleDegrees = 0.0; // Default reset angle in degrees\n        this.maxOffsetRangeDegrees = 5.0; // Default max offset range for training\n        \n        // Debug control speed\n        this.debugSpeed = 1.0;\n        this.debugLastAction = 'None';\n        this.debugCurrentReward = 0;\n        \n        // Demo modes\n        this.demoMode = 'freerun'; // 'freerun', 'training'\n        \n        // Model management state\n        this.currentModelName = 'No model loaded';\n        this.modelHasUnsavedChanges = false;\n        this.trainingStartTime = null;\n        \n        // Manual control state\n        this.manualControl = {\n            enabled: false,\n            leftPressed: false,\n            rightPressed: false,\n            upPressed: false,\n            manualTorque: 0\n        };\n        \n        // Simulation loop management\n        this.simulationInterval = null;\n        \n        // PD controller toggle state\n        this.pdControllerEnabled = true; // Start enabled in free run mode\n        \n        // User control only mode\n        this.userControlOnlyEnabled = false; // When true, disables all assistance\n        \n        // User control toggle state (separate from manual mode)\n        this.userControlEnabled = true; // Always enabled in free run mode\n        \n        // Network architecture (will be set by UI)\n        this.currentNetworkArchitecture = null;\n        \n        // Physics simulation timing\n        this.lastPhysicsUpdate = 0;\n        this.physicsUpdateInterval = 20; // 50 Hz physics updates\n        \n        // Performance monitoring\n        this.frameTimeHistory = [];\n        this.lastFrameTime = 0;\n        this.performanceCheckInterval = 60; // Check every 60 frames (~1 second)\n        \n        // WebGPU status tracking\n        this.webgpuStatus = {\n            checked: false,\n            available: false,\n            deviceInfo: null,\n            error: null\n        };\n        \n        // Q-learning training state\n        this.previousState = null;\n        this.previousAction = undefined;\n        this.previousReward = 0;\n        this.previousDone = false;\n        this.lastTrainingLoss = 0;\n    }\n\n    async initialize() {\n        console.log('Initializing Two-Wheel Balancing Robot RL Environment...');\n        \n        try {\n            // Show loading screen\n            this.showLoading(true);\n            \n            // Initialize canvas and renderer\n            this.initializeRenderer();\n            \n            // Initialize physics and ML components\n            await this.initializeComponents();\n            \n            // Initialize WebGPU backend with CPU fallback\n            await this.initializeWebGPUBackend();\n            \n            // Initialize UI controls\n            this.initializeControls();\n            \n            // Initialize UI Controls Manager\n            this.uiControls = new UIControls(this);\n            this.uiControls.initialize();\n            \n            // Initialize parallel training system\n            this.systemCapabilities = new SystemCapabilities();\n            console.log(`System capabilities: ${this.systemCapabilities.coreCount} cores, using ${this.systemCapabilities.maxWorkers} workers`);\n            \n            // Update WebGPU status display\n            this.updateWebGPUStatusDisplay();\n            \n            // Update CPU cores status display\n            this.updateCPUCoresStatusDisplay();\n            \n            // Start simulation and rendering\n            this.startSimulation();\n            \n            // Initialize UI state\n            this.updatePDControllerUI();\n            this.updateUserControlOnlyUI();\n            this.updateFreeRunSpeedUI();\n            this.updateModelDisplay('No model loaded', null);\n            \n            this.isInitialized = true;\n            console.log('Application initialized successfully!');\n            \n        } catch (error) {\n            console.error('Failed to initialize application:', error);\n            this.showError('Failed to initialize application: ' + error.message);\n        } finally {\n            this.showLoading(false);\n        }\n    }\n\n    // Add debugging getter and setter for isTraining to track when it changes\n    get isTraining() {\n        return this._isTraining;\n    }\n\n    set isTraining(value) {\n        if (this._isTraining !== value) {\n            console.log(`🔄 isTraining changed from ${this._isTraining} to ${value}`, new Error().stack);\n        }\n        this._isTraining = value;\n    }\n\n    initializeRenderer() {\n        this.canvas = document.getElementById('simulation-canvas');\n        if (!this.canvas) {\n            throw new Error('Canvas element not found');\n        }\n        \n        // Set canvas size to fill available space\n        this.resizeCanvas();\n        \n        // Initialize 2D renderer\n        this.renderer = createRenderer(this.canvas, {\n            showGrid: true,\n            showDebugInfo: true,\n            showPerformance: true,\n            targetFPS: 60\n        });\n        \n        // Add resize listener\n        window.addEventListener('resize', () => this.resizeCanvas());\n        \n        // Initialize performance charts\n        const chartsPanel = document.getElementById('charts-panel');\n        if (chartsPanel) {\n            this.performanceCharts = createPerformanceCharts(chartsPanel);\n            this.performanceCharts.start();\n            console.log('Performance charts initialized');\n        }\n        \n        console.log('Renderer initialized:', this.canvas.width, 'x', this.canvas.height);\n    }\n\n    async initializeWebGPUBackend() {\n        const statusElement = document.getElementById('webgpu-text');\n        \n        try {\n            console.log('Initializing WebGPU backend...');\n            statusElement.textContent = 'Initializing WebGPU...';\n            \n            // Create WebGPU backend instance\n            this.webgpuBackend = new WebGPUBackend();\n            \n            // Quick availability check for UI feedback\n            const quickCheck = await checkWebGPUAvailability();\n            this.webgpuStatus.checked = true;\n            this.webgpuStatus.available = quickCheck.available;\n            \n            if (quickCheck.available) {\n                statusElement.textContent = 'WebGPU Available';\n                statusElement.className = 'status-available';\n                console.log('WebGPU availability confirmed:', quickCheck.adapterInfo);\n            } else {\n                statusElement.textContent = 'WebGPU Unavailable (CPU fallback)';\n                statusElement.className = 'status-unavailable';\n                console.log('WebGPU not available:', quickCheck.reason);\n                this.webgpuStatus.error = quickCheck.reason;\n            }\n            \n            // Hide status text after 10 seconds\n            setTimeout(() => {\n                const statusContainer = document.getElementById('webgpu-status');\n                if (statusContainer) {\n                    statusContainer.style.display = 'none';\n                }\n            }, 10000);\n            \n            // Store status for detailed UI display\n            this.webgpuStatus.deviceInfo = quickCheck;\n            \n        } catch (error) {\n            console.warn('WebGPU backend initialization failed:', error.message);\n            statusElement.textContent = 'WebGPU Error (CPU fallback)';\n            statusElement.className = 'status-unavailable';\n            \n            // Hide status text after 10 seconds (error case)\n            setTimeout(() => {\n                const statusContainer = document.getElementById('webgpu-status');\n                if (statusContainer) {\n                    statusContainer.style.display = 'none';\n                }\n            }, 10000);\n            \n            this.webgpuStatus.checked = true;\n            this.webgpuStatus.available = false;\n            this.webgpuStatus.error = error.message;\n            \n            // Create fallback backend\n            this.webgpuBackend = new WebGPUBackend();\n        }\n    }\n\n    initializeControls() {\n        // Training controls\n        document.getElementById('start-training').addEventListener('click', () => {\n            if (this.isTraining) {\n                this.stopTraining();\n            } else {\n                this.startTraining();\n            }\n        });\n        \n        document.getElementById('pause-training').addEventListener('click', () => {\n            this.pauseTraining();\n        });\n        \n        document.getElementById('reset-environment').addEventListener('click', () => {\n            this.resetEnvironment();\n        });\n        \n        // Visualization controls\n        document.getElementById('toggle-physics').addEventListener('click', () => {\n            this.switchDemoMode('physics');\n        });\n        \n        document.getElementById('toggle-network').addEventListener('click', () => {\n            this.renderer.toggleUI('robot');\n            console.log('Toggled robot info display');\n        });\n        \n        document.getElementById('toggle-metrics').addEventListener('click', () => {\n            this.renderer.toggleUI('training');\n            console.log('Toggled training metrics display');\n        });\n        \n        // Model management controls\n        document.getElementById('save-model').addEventListener('click', () => {\n            this.saveModelToLocalStorage();\n        });\n        \n        document.getElementById('test-model-btn')?.addEventListener('click', () => {\n            this.testModel();\n        });\n        \n        document.getElementById('export-model').addEventListener('click', () => {\n            this.exportModelToCpp();\n        });\n        \n        document.getElementById('import-model').addEventListener('click', () => {\n            this.importModelFromCpp();\n        });\n        \n        document.getElementById('reset-parameters').addEventListener('click', () => {\n            this.resetModelParameters();\n        });\n        \n        // WebGPU status refresh\n        document.getElementById('refresh-webgpu').addEventListener('click', () => {\n            this.updateWebGPUStatusDisplay();\n        });\n        \n        // Zoom controls\n        document.getElementById('zoom-in-btn')?.addEventListener('click', () => {\n            if (this.renderer) {\n                this.renderer.transform.zoomIn();\n                console.log('Zoomed in to', this.renderer.transform.getZoomLevel());\n            }\n        });\n\n        document.getElementById('zoom-out-btn')?.addEventListener('click', () => {\n            if (this.renderer) {\n                this.renderer.transform.zoomOut();\n                console.log('Zoomed out to', this.renderer.transform.getZoomLevel());\n            }\n        });\n\n        document.getElementById('zoom-reset-btn')?.addEventListener('click', () => {\n            if (this.renderer) {\n                this.renderer.transform.resetZoom();\n                console.log('Zoom reset to 1.0');\n            }\n        });\n        \n        // PD Controller toggle\n        document.getElementById('toggle-pd-controller')?.addEventListener('click', () => {\n            this.togglePDController();\n        });\n        \n        // User Control Only toggle\n        document.getElementById('toggle-user-control-only')?.addEventListener('click', () => {\n            this.toggleUserControlOnly();\n        });\n        \n        // Reward Function dropdown\n        document.getElementById('reward-function')?.addEventListener('change', (e) => {\n            this.setRewardFunction(e.target.value);\n        });\n        \n        // On-screen controls for free run mode\n        this.setupOnScreenControls();\n        \n        // Setup collapsible sections\n        this.setupCollapsibleSections();\n        \n        // Initialize model list\n        this.refreshModelList();\n        \n        console.log('Controls initialized');\n    }\n\n    /**\n     * Setup collapsible control sections\n     */\n    setupCollapsibleSections() {\n        // Find all control section headers and add click handlers\n        const sections = document.querySelectorAll('.control-section h3');\n        \n        sections.forEach(header => {\n            header.addEventListener('click', () => {\n                const section = header.parentElement;\n                section.classList.toggle('collapsed');\n                \n                // Optional: Save section states to localStorage\n                const sectionTitle = header.textContent.trim();\n                const isCollapsed = section.classList.contains('collapsed');\n                localStorage.setItem(`section-${sectionTitle}`, isCollapsed.toString());\n                \n                console.log(`Toggled section: ${sectionTitle} (${isCollapsed ? 'collapsed' : 'expanded'})`);\n            });\n        });\n        \n        // Restore section states from localStorage\n        sections.forEach(header => {\n            const sectionTitle = header.textContent.trim();\n            const savedState = localStorage.getItem(`section-${sectionTitle}`);\n            \n            if (savedState !== null) {\n                const section = header.parentElement;\n                const shouldCollapse = savedState === 'true';\n                \n                if (shouldCollapse) {\n                    section.classList.add('collapsed');\n                } else {\n                    section.classList.remove('collapsed');\n                }\n            }\n        });\n    }\n\n    async startTraining() {\n        if (this.isTraining) return;\n        \n        // Initialize Q-learning if not already done\n        if (!this.qlearning) {\n            await this.initializeQLearning();\n        }\n        \n        // CRITICAL FIX: Read current training speed from UI slider before starting\n        const speedSlider = document.getElementById('training-speed');\n        if (speedSlider) {\n            const currentSpeed = parseFloat(speedSlider.value);\n            this.setTrainingSpeed(currentSpeed);\n            console.log(`Training will start at current slider speed: ${currentSpeed}x`);\n        }\n        \n        this.isTraining = true;\n        this.isPaused = false;\n        this.demoMode = 'training';\n        this.updateFreeRunSpeedUI();\n        \n        // Ensure robot has current offset range for training\n        if (this.robot && this.maxOffsetRangeDegrees > 0) {\n            this.robot.setTrainingOffsetRange(this.maxOffsetRangeDegrees);\n            console.log(`Training offset range set to: ±${this.maxOffsetRangeDegrees.toFixed(1)}°`);\n        }\n        \n        // Track training start time for model naming\n        this.trainingStartTime = new Date();\n        const timestamp = this.trainingStartTime.toISOString().replace(/[:.]/g, '-').slice(0, -5);\n        \n        // Update model name to indicate active training\n        if (this.currentModelName === 'No model loaded' || !this.currentModelName.startsWith('TwoWheelBot_DQN_')) {\n            this.currentModelName = `Unsaved_DQN_${timestamp}`;\n        }\n        this.modelHasUnsavedChanges = true;\n        \n        // Don't reset if we have a loaded model and are continuing training\n        if (!this.qlearning || this.episodeCount === 0) {\n            // Reset for new training session\n            this.episodeCount = 0;\n            this.trainingStep = 0;\n            this.bestScore = -Infinity;\n        }\n        \n        // Update model display\n        this.updateTrainingModelDisplay();\n        \n        this.startNewEpisode();\n        \n        // Update start button to become stop button\n        const startButton = document.getElementById('start-training');\n        startButton.textContent = 'Stop Training';\n        startButton.classList.remove('primary');\n        startButton.classList.add('danger');\n        startButton.disabled = false;\n        \n        document.getElementById('pause-training').disabled = false;\n        \n        // Update PD controller UI (disabled during training)\n        this.updatePDControllerUI();\n        \n        console.log('Training started');\n    }\n\n    stopTraining() {\n        if (!this.isTraining) return;\n        \n        // Stop training\n        this.isTraining = false;\n        this.isPaused = false;\n        this.demoMode = 'freerun';\n        \n        // Reset training speed to normal for free run mode\n        this.trainingSpeed = 1.0;\n        this.targetPhysicsStepsPerFrame = 1;\n        \n        // Reset training metrics while preserving the model\n        this.episodeCount = 0;\n        this.trainingStep = 0;\n        this.bestScore = 0;\n        this.currentReward = 0;\n        \n        // Reset Q-learning training state but keep the trained weights\n        if (this.qlearning) {\n            // Reset training counters and epsilon without resetting weights\n            this.qlearning.episode = 0;\n            this.qlearning.stepCount = 0;\n            this.qlearning.globalStepCount = 0;\n            this.qlearning.lastTargetUpdate = 0;\n            \n            // Reset epsilon to initial value for potential restart\n            this.qlearning.hyperparams.epsilon = this.qlearning.initialEpsilon || 0.9;\n            \n            // Clear replay buffer\n            this.qlearning.replayBuffer.clear();\n        }\n        \n        // Reset performance tracking\n        if (this.performanceTracker) {\n            this.performanceTracker.reset();\n        }\n        \n        // Clear performance charts if reset method exists\n        if (this.performanceCharts && typeof this.performanceCharts.reset === 'function') {\n            this.performanceCharts.reset();\n        }\n        \n        // Reset previous training state\n        this.previousState = null;\n        this.previousAction = undefined;\n        this.previousReward = 0;\n        this.previousDone = false;\n        this.lastTrainingLoss = 0;\n        \n        // Update UI buttons\n        const startButton = document.getElementById('start-training');\n        const pauseButton = document.getElementById('pause-training');\n        \n        startButton.textContent = 'Start Training';\n        startButton.classList.remove('danger');\n        startButton.classList.add('primary');\n        \n        pauseButton.textContent = 'Pause Training';\n        pauseButton.disabled = true;\n        \n        // Update training status display\n        this.updateTrainingModelDisplay();\n        this.updatePDControllerUI();\n        this.updateUserControlOnlyUI();\n        this.updateOnScreenControlsVisibility();\n        \n        // Reset robot to clean state\n        this.robot.reset();\n        \n        // Restart simulation with appropriate settings for free run mode\n        if (this.isInitialized) {\n            this.startSimulation();\n        }\n        \n        console.log('Training stopped and reset');\n    }\n\n    pauseTraining() {\n        if (!this.isTraining) return;\n        \n        this.isPaused = !this.isPaused;\n        \n        const pauseButton = document.getElementById('pause-training');\n        pauseButton.textContent = this.isPaused ? 'Resume Training' : 'Pause Training';\n        \n        // Update model display to show paused/training status\n        this.updateTrainingModelDisplay();\n        \n        console.log('Training', this.isPaused ? 'paused' : 'resumed');\n    }\n\n    resetEnvironment() {\n        // Stop all training and parallel processing\n        this.isTraining = false;\n        this.isPaused = false;\n        this.parallelModeEnabled = false;\n        this.demoMode = 'freerun'; // Reset to free run mode\n        this.pdControllerEnabled = true; // Reset to PD controller enabled\n        this.userControlOnlyEnabled = false; // Reset User Control Only\n        \n        // Reset all training counters and metrics\n        this.trainingStep = 0;\n        this.episodeCount = 0;\n        this.bestScore = 0;\n        this.currentReward = 0;\n        this.episodeEnded = false;\n        \n        // Reset Q-learning training state\n        this.previousState = null;\n        this.previousAction = undefined;\n        this.previousReward = 0;\n        this.previousDone = false;\n        this.lastTrainingLoss = 0;\n        \n        // Reset Q-learning if it exists\n        if (this.qlearning) {\n            this.qlearning.reset();\n            console.log('Q-learning network reset');\n        }\n        \n        // Reset parallel training if it exists\n        if (this.parallelQLearning) {\n            this.parallelQLearning.cleanup();\n            this.parallelQLearning = null;\n            console.log('Parallel training system reset');\n        }\n        \n        // Reset performance charts\n        if (this.performanceCharts) {\n            this.performanceCharts.reset();\n            console.log('Performance charts reset');\n        }\n        \n        // Reset robot state\n        if (this.robot) {\n            let resetAngle = 0; // Default: perfectly balanced\n            \n            // In free run mode, use exact angle from slider\n            if (this.demoMode === 'freerun' && Math.abs(this.resetAngleDegrees) > 0) {\n                const angleDegrees = this.resetAngleDegrees || 0.0;\n                resetAngle = angleDegrees * Math.PI / 180; // Use exact angle from slider\n                console.log(`Reset with angle: ${(resetAngle * 180 / Math.PI).toFixed(2)}° (set to ${angleDegrees.toFixed(1)}°)`);\n            }\n            \n            this.robot.reset({\n                angle: resetAngle,\n                angularVelocity: 0,\n                position: 0,\n                velocity: 0\n            });\n        }\n        \n        // Reset UI states\n        document.getElementById('start-training').disabled = false;\n        document.getElementById('pause-training').disabled = true;\n        document.getElementById('pause-training').textContent = 'Pause Training';\n        \n        // Reset parallel training UI\n        const parallelBtn = document.getElementById('parallel-training');\n        if (parallelBtn) {\n            parallelBtn.textContent = 'Parallel';\n            parallelBtn.classList.remove('active');\n        }\n        \n        // Update various UI components\n        this.updateFreeRunSpeedUI();\n        this.updatePDControllerUI();\n        this.updateUserControlOnlyUI();\n        this.updateOnScreenControlsVisibility();\n        this.updateUI();\n        \n        console.log('Environment completely reset - all training state cleared');\n    }\n\n    resizeCanvas() {\n        const container = document.getElementById('main-container');\n        const controlsPanel = document.getElementById('controls-panel');\n        \n        // Calculate available space for canvas\n        const containerWidth = container.clientWidth;\n        const containerHeight = container.clientHeight;\n        const controlsPanelWidth = controlsPanel ? controlsPanel.offsetWidth : 300;\n        \n        // Canvas should take all available width minus controls panel\n        const availableWidth = containerWidth - controlsPanelWidth;\n        const availableHeight = containerHeight;\n        \n        // Use device pixel ratio for crisp rendering on high-DPI displays\n        const dpr = window.devicePixelRatio || 1;\n        \n        // Set canvas display size (CSS pixels)\n        this.canvas.style.width = availableWidth + 'px';\n        this.canvas.style.height = availableHeight + 'px';\n        \n        // Set canvas actual size (device pixels)\n        const actualWidth = availableWidth * dpr;\n        const actualHeight = availableHeight * dpr;\n        \n        this.canvas.width = actualWidth;\n        this.canvas.height = actualHeight;\n        \n        // Update renderer with new dimensions\n        if (this.renderer) {\n            this.renderer.resize(actualWidth, actualHeight);\n            // Reset the canvas context scale after renderer resize\n            const ctx = this.canvas.getContext('2d');\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n        \n        console.log('Canvas resized to:', actualWidth, 'x', actualHeight, `(${availableWidth}x${availableHeight} display)`);\n    }\n\n    startSimulation() {\n        // Clean up any existing simulation loop\n        this.stopSimulation();\n        \n        // Start the renderer\n        this.renderer.start();\n        \n        // Choose simulation mode based on SmartRenderingManager configuration\n        if (this.smartRenderingManager.renderingMode === 'interval') {\n            this.startHighPerformanceSimulation();\n        } else {\n            this.startDisplaySyncedSimulation();\n        }\n    }\n    \n    stopSimulation() {\n        // Clean up interval-based simulation\n        if (this.simulationInterval) {\n            clearInterval(this.simulationInterval);\n            this.simulationInterval = null;\n            console.log('High-performance simulation stopped');\n        }\n        \n        // Note: RAF-based simulation will naturally stop when requestAnimationFrame stops being called\n    }\n    \n    startDisplaySyncedSimulation() {\n        // Traditional RAF-based simulation (60 FPS max, display-synced)\n        const simulate = (timestamp) => {\n            if (!this.isInitialized) return;\n            \n            this.runSimulationFrame(timestamp || performance.now());\n            requestAnimationFrame(simulate);\n        };\n        \n        requestAnimationFrame(simulate);\n        console.log('Simulation started (display-synced, ~60 FPS)');\n    }\n    \n    startHighPerformanceSimulation() {\n        // Adaptive high-performance simulation based on training speed\n        const baseTargetInterval = 1000 / this.smartRenderingManager.actualTargetFPS; // 8.33ms for 120 FPS\n        \n        // Adjust interval based on training speed - REMOVE throttling for max performance\n        let adaptedInterval;\n        if (this.trainingSpeed <= 20) {\n            adaptedInterval = baseTargetInterval; // Full 120 FPS for low speeds\n        } else if (this.trainingSpeed <= 100) {\n            adaptedInterval = baseTargetInterval; // Keep 120 FPS for medium speeds too\n        } else {\n            // For very high speeds, run as fast as possible with minimal interval\n            adaptedInterval = 1; // 1ms = ~1000 FPS maximum theoretical rate\n        }\n        \n        let lastTimestamp = performance.now();\n        let simulationCallCount = 0;\n        \n        const simulate = async () => {\n            if (!this.isInitialized) return;\n            \n            const currentTimestamp = performance.now();\n            const actualInterval = currentTimestamp - lastTimestamp;\n            \n            // Log performance every 60 calls to detect interval backup\n            simulationCallCount++;\n            if (simulationCallCount % 60 === 0) {\n                const intervalBackup = actualInterval > (adaptedInterval * 1.5) ? '🚨 BACKUP!' : '✅';\n                console.log(`⏱️  TIMING: ${this.trainingSpeed}x speed | Target: ${adaptedInterval.toFixed(1)}ms | Actual: ${actualInterval.toFixed(1)}ms ${intervalBackup}`);\n            }\n            \n            await this.runSimulationFrame(currentTimestamp);\n            lastTimestamp = currentTimestamp;\n        };\n        \n        // Use adapted interval to prevent backup at high speeds\n        this.simulationInterval = setInterval(simulate, adaptedInterval);\n        console.log(`Simulation started (adaptive, ${(1000/adaptedInterval).toFixed(0)} FPS for ${this.trainingSpeed}x speed)`);\n    }\n    \n    async runSimulationFrame(timestamp) {\n        // Performance monitoring\n        if (this.lastFrameTime > 0) {\n            const frameTime = timestamp - this.lastFrameTime;\n            this.frameTimeHistory.push(frameTime);\n            \n            // Keep only recent history\n            if (this.frameTimeHistory.length > this.performanceCheckInterval) {\n                this.frameTimeHistory.shift();\n            }\n            \n            // Debug performance degradation: log when frame time gets bad\n            if (frameTime > 50 && Math.random() < 0.1) { // 10% chance to log when frame time > 50ms\n                console.warn(`🐌 PERFORMANCE: Frame time ${frameTime.toFixed(1)}ms, History length: ${this.frameTimeHistory.length}, Physics steps: ${this.targetPhysicsStepsPerFrame}`);\n            }\n            \n            // Auto-adjust training speed if performance is extremely poor (disabled for manual speed control)\n            if (this.frameTimeHistory.length === this.performanceCheckInterval) {\n                const avgFrameTime = this.frameTimeHistory.reduce((a, b) => a + b) / this.frameTimeHistory.length;\n                const targetFrameTime = 1000 / this.smartRenderingManager.actualTargetFPS;\n                \n                // Only auto-adjust if frame time is catastrophically poor (>200ms = <5 FPS)\n                // and we're running an extreme number of physics steps, and rendering is active\n                const isRenderingActive = this.smartRenderingManager.shouldRenderFrame(this.trainingSpeed);\n                if (avgFrameTime > 200 && this.targetPhysicsStepsPerFrame > 500 && isRenderingActive) {\n                    this.setTrainingSpeed(Math.max(50.0, this.trainingSpeed * 0.8));\n                    console.warn(`Catastrophic performance (${avgFrameTime.toFixed(1)}ms/frame), reducing training speed to ${this.trainingSpeed.toFixed(1)}x`);\n                }\n            }\n        }\n        this.lastFrameTime = timestamp;\n        \n        // Update physics at appropriate intervals based on mode and speed\n        let updateInterval;\n        if (this.demoMode === 'freerun') {\n            // Free run mode: controlled by debugSpeed (Free Run Speed slider)\n            // debugSpeed ranges from 0.1x to 2x, so adjust interval accordingly\n            // Base interval is 16.67ms (60fps), adjust inversely with speed\n            updateInterval = Math.max(1, 16.67 / this.debugSpeed);\n        } else if (this.demoMode === 'training' && (this.parallelModeEnabled || this.trainingSpeed > 100)) {\n            // For parallel mode or high-speed training, run physics as fast as possible\n            updateInterval = 0; // No throttling - run every frame\n        } else {\n            // Normal throttling for low/medium speeds in training mode only\n            updateInterval = this.physicsUpdateInterval;\n        }\n        \n        if (timestamp - this.lastPhysicsUpdate >= updateInterval) {\n            await this.updatePhysics();\n            \n            // Smart rendering - skip rendering during high-speed training or parallel mode\n            const effectiveSpeed = this.parallelModeEnabled ? 1000 : this.trainingSpeed;\n            const shouldRender = this.smartRenderingManager.shouldRenderFrame(effectiveSpeed);\n            if (shouldRender) {\n                this.updateRenderer();\n                this.updateUI();\n            }\n            \n            this.lastPhysicsUpdate = timestamp;\n        }\n    }\n\n    async updatePhysics() {\n        if (!this.robot) return;\n        \n        const physicsStartTime = performance.now();\n        \n        // Run multiple physics steps per frame for speed control\n        let maxStepsPerFrame;\n        if (this.demoMode === 'freerun') {\n            // Free run mode: controlled by debugSpeed (Free Run Speed slider)\n            // debugSpeed ranges from 0.1x to 2x\n            // For multi-timestep models, ensure we run enough steps to populate history\n            const historyTimesteps = this.robot ? this.robot.historyTimesteps : 1;\n            const baseSteps = Math.max(1, Math.round(this.debugSpeed * 3)); // 1-6 steps based on speed\n            // Ensure at least as many steps as history timesteps for smooth operation\n            maxStepsPerFrame = Math.max(baseSteps, historyTimesteps);\n        } else if (this.parallelModeEnabled) {\n            // Parallel mode: main thread runs at maximum speed regardless of slider\n            maxStepsPerFrame = 1000; // Max speed for parallel training\n        } else if (this.trainingSpeed <= 100) {\n            // For speeds ≤100x, ensure minimum steps for smooth motion (continuous rendering active)\n            maxStepsPerFrame = Math.max(3, this.targetPhysicsStepsPerFrame);\n        } else if (this.trainingSpeed <= 200) {\n            // For moderate high speeds, limit to prevent frame drops during sparse rendering\n            maxStepsPerFrame = Math.min(this.targetPhysicsStepsPerFrame, 500);\n        } else {\n            // For extreme speeds, allow higher limits since rendering is minimal\n            maxStepsPerFrame = Math.min(this.targetPhysicsStepsPerFrame, 1000);\n        }\n        \n        // Use optimized steps for all modes except when explicitly paused\n        const stepsToRun = this.isPaused ? 1 : maxStepsPerFrame;\n        \n        // Profiling variables\n        let robotStepTime = 0;\n        let trainingTime = 0;\n        let yieldTime = 0;\n        let otherTime = 0;\n        \n        for (let step = 0; step < stepsToRun; step++) {\n            const stepStartTime = performance.now();\n            \n            // Yield control to event loop every 50 steps to prevent blocking\n            if (step > 0 && step % 50 === 0) {\n                const yieldStart = performance.now();\n                await new Promise(resolve => setTimeout(resolve, 0));\n                yieldTime += performance.now() - yieldStart;\n            }\n            \n            let motorTorque = 0;\n            let actionIndex = 0;\n            \n            // Get current normalized state for Q-learning (includes multi-timestep logic)\n            const normalizedState = this.robot.getNormalizedInputs();\n            \n            // Get motor torque based on current mode\n            switch (this.demoMode) {\n                case 'freerun':\n                    // Free run mode: user input takes precedence, then assistance modes\n                    if (this.manualControl.leftPressed || this.manualControl.rightPressed) {\n                        // User input always takes precedence when active\n                        motorTorque = this.getManualTorque();\n                    } else if (this.userControlOnlyEnabled) {\n                        // User Control Only mode - no assistance\n                        motorTorque = 0;\n                    } else if (this.pdControllerEnabled) {\n                        // PD controller assistance\n                        motorTorque = this.getPhysicsDemoTorque();\n                    } else if (this.qlearning) {\n                        // Model control available if model loaded\n                        motorTorque = this.getEvaluationTorque();\n                    } else {\n                        motorTorque = 0; // No control active\n                    }\n                    break;\n                case 'training':\n                    if (this.isTraining && !this.isPaused) {\n                        const trainingResult = this.getTrainingTorqueWithAction();\n                        motorTorque = trainingResult.torque;\n                        actionIndex = trainingResult.actionIndex;\n                    } else {\n                        // When training paused/stopped: user arrows take precedence, then assistance modes\n                        if (this.userControlEnabled && (this.manualControl.leftPressed || this.manualControl.rightPressed)) {\n                            motorTorque = this.getManualTorque();\n                        } else if (this.userControlOnlyEnabled) {\n                            motorTorque = 0; // User Control Only mode\n                        } else if (this.pdControllerEnabled) {\n                            motorTorque = this.getPhysicsDemoTorque();\n                        } else if (this.qlearning) {\n                            motorTorque = this.getEvaluationTorque();\n                        } else {\n                            motorTorque = 0;\n                        }\n                    }\n                    break;\n            }\n            \n            // Step physics simulation\n            const robotStepStart = performance.now();\n            const result = this.robot.step(motorTorque);\n            robotStepTime += performance.now() - robotStepStart;\n            this.currentReward = result.reward;\n            \n            // Check for physics instability that could cause silent training failures\n            if (!this.robot.isStable() || !isFinite(result.reward)) {\n                console.error('Physics simulation became unstable:', {\n                    robotState: this.robot.getState(),\n                    reward: result.reward,\n                    motorTorque: motorTorque,\n                    episode: this.episodeCount,\n                    step: this.trainingStep\n                });\n                \n                if (this.demoMode === 'training' && this.isTraining) {\n                    // Force episode end due to instability\n                    console.warn('Ending episode due to physics instability');\n                    this.episodeEnded = true;\n                    this.handleEpisodeEnd({\n                        ...result,\n                        done: true,\n                        reward: -10.0 // Penalty for instability\n                    });\n                    return;\n                }\n            }\n            \n            // Update debug reward display during manual control modes and evaluation\n            if (this.demoMode === 'freerun') {\n                this.debugCurrentReward = result.reward;\n            }\n            \n            // Q-learning training integration\n            if (this.demoMode === 'training' && this.isTraining && !this.isPaused && this.qlearning) {\n                // Get next state after physics step (includes multi-timestep logic)\n                const nextState = this.robot.getNormalizedInputs();\n                \n                // Train on previous experience if we have one\n                // At high speeds, reduce training frequency to prevent bottlenecks\n                const shouldTrain = this._shouldTrainThisStep(step, stepsToRun);\n                \n                if (this.previousState && this.previousAction !== undefined && shouldTrain) {\n                    const trainingStart = performance.now();\n                    const loss = this.qlearning.train(\n                        this.previousState,      // Previous state\n                        this.previousAction,     // Previous action  \n                        this.previousReward,     // ✅ FIXED: Reward from previous action\n                        nextState,              // Current state (next state)\n                        this.previousDone       // ✅ FIXED: Done from previous step\n                    );\n                    trainingTime += performance.now() - trainingStart;\n                    \n                    // Store training loss for metrics with NaN protection\n                    this.lastTrainingLoss = isFinite(loss) ? loss : 0;\n                }\n                \n                // Store current experience for next iteration (unless episode is done)\n                if (!result.done) {\n                    this.previousState = normalizedState.slice();\n                    this.previousAction = actionIndex;\n                    this.previousReward = result.reward;  // Store current reward for next iteration\n                    this.previousDone = result.done;\n                } else {\n                    // Episode ended - always train on final experience (critical for episode completion)\n                    const finalLoss = this.qlearning.train(\n                        normalizedState,        // Current state  \n                        actionIndex,           // Current action\n                        result.reward,         // ✅ FIXED: Current reward\n                        nextState,            // Final state (after step)\n                        result.done           // ✅ FIXED: Current done status\n                    );\n                    this.lastTrainingLoss = isFinite(finalLoss) ? finalLoss : 0;\n                    \n                    // Clear previous state to start fresh next episode\n                    this.previousState = null;\n                    this.previousAction = undefined;\n                    this.previousReward = 0;\n                    this.previousDone = false;\n                }\n            }\n            \n            // Handle episode completion for training/evaluation (only once per episode)\n            // Skip episode completion when training is paused to prevent falling/resetting\n            if (result.done && (this.demoMode === 'training') && !this.isPaused && !this.episodeEnded) {\n                this.episodeEnded = true; // Set flag to prevent multiple calls\n                this.handleEpisodeEnd(result);\n                return; // Exit physics update completely to avoid multiple episode ends\n            }\n            \n            // CRITICAL: Break out of physics loop if episode ended to prevent infinite loops\n            if (this.episodeEnded) {\n                break; // Exit the multi-step physics loop immediately\n            }\n            \n            // Update training step counter\n            if (this.isTraining && !this.isPaused) {\n                this.trainingStep++;\n                \n                // Performance tracking - record step\n                this.performanceTracker.recordStep();\n                \n                // Check for episode termination based on step count (uses dynamic maxStepsPerEpisode)\n                const maxSteps = this.uiControls?.getParameter('maxStepsPerEpisode') || 1000;\n                if (this.trainingStep >= maxSteps && !this.episodeEnded && (this.demoMode === 'training')) {\n                    console.log(`Episode terminated at step ${this.trainingStep} (reached max steps)`);\n                    this.episodeEnded = true;\n                    // Create a synthetic \"done\" result to trigger episode end\n                    const syntheticResult = {\n                        state: this.robot.getState(),\n                        reward: 1.0, // Positive reward for reaching max steps\n                        done: true\n                    };\n                    this.handleEpisodeEnd(syntheticResult);\n                    break; // Exit the physics loop immediately\n                }\n                \n                // Check for robot moving off canvas in all modes\n                const robotState = this.robot.getState();\n                const bounds = this.renderer ? this.renderer.getPhysicsBounds() : null;\n                \n                if (bounds && (robotState.position < bounds.minX || robotState.position > bounds.maxX)) {\n                    // Handle based on mode\n                    if ((this.demoMode === 'training') && !this.episodeEnded) {\n                        console.log(`Episode terminated at step ${this.trainingStep} (robot moved off canvas: position=${robotState.position.toFixed(2)}m, bounds=[${bounds.minX.toFixed(2)}, ${bounds.maxX.toFixed(2)}])`);\n                        this.episodeEnded = true;\n                        // Create a synthetic \"done\" result with penalty for going off canvas\n                        const syntheticResult = {\n                            state: this.robot.getState(),\n                            reward: -1.0, // Penalty for moving off canvas\n                            done: true\n                        };\n                        this.handleEpisodeEnd(syntheticResult);\n                        break; // Exit the physics loop immediately\n                    } else if (this.demoMode === 'manual' || this.demoMode === 'physics') {\n                        // Reset robot to origin for manual/physics modes\n                        console.log(`Robot moved off canvas in ${this.demoMode} mode, resetting to origin`);\n                        this.robot.reset({\n                            angle: 0,\n                            angularVelocity: 0,\n                            position: 0,\n                            velocity: 0\n                        });\n                    }\n                }\n            }\n        }\n        \n        // Profiling output every 100 physics steps for performance analysis\n        const totalPhysicsTime = performance.now() - physicsStartTime;\n        if (this.trainingSpeed >= 40 && Math.random() < 0.01) { // 1% chance to log at high speeds\n            console.log(`🔍 PROFILING ${this.trainingSpeed}x (${stepsToRun} steps): Total=${totalPhysicsTime.toFixed(1)}ms | Robot=${robotStepTime.toFixed(1)}ms | Training=${trainingTime.toFixed(1)}ms | Yield=${yieldTime.toFixed(1)}ms`);\n            console.log(`⏱️  Per step: Robot=${(robotStepTime/stepsToRun).toFixed(2)}ms | Training=${(trainingTime/stepsToRun).toFixed(2)}ms`);\n        }\n    }\n\n    updateRenderer() {\n        if (!this.renderer || !this.robot) return;\n        \n        const state = this.robot.getState();\n        const config = this.robot.getConfig();\n        const stats = this.robot.getStats();\n        \n        // Update robot visualization\n        this.renderer.updateRobot(state, config, stats.currentMotorTorque);\n        \n        // Update training metrics\n        const trainingMetrics = {\n            episode: this.episodeCount,\n            step: this.trainingStep,\n            reward: this.currentReward,\n            totalReward: stats.totalReward,\n            bestReward: this.bestScore,\n            epsilon: this.qlearning ? this.qlearning.hyperparams.epsilon : 0,\n            isTraining: this.isTraining,\n            trainingMode: this.demoMode\n        };\n        \n        this.renderer.updateTraining(trainingMetrics);\n    }\n\n    updateUI() {\n        document.getElementById('training-step').textContent = `Step: ${this.trainingStep.toLocaleString()}`;\n        document.getElementById('episode-count').textContent = `Episode: ${this.episodeCount}`;\n        document.getElementById('best-score').textContent = `Best Score: ${this.bestScore.toFixed(1)}`;\n        document.getElementById('current-reward').textContent = `Current Reward: ${this.currentReward.toFixed(1)}`;\n        \n        // Update Q-learning metrics display and sync UI controls\n        if (this.qlearning) {\n            document.getElementById('epsilon-display').textContent = `Epsilon: ${this.qlearning.hyperparams.epsilon.toFixed(3)}`;\n            document.getElementById('consecutive-episodes').textContent = `Consecutive Max Episodes: ${this.qlearning.consecutiveMaxEpisodes}/20`;\n            \n            // Sync UI controls with current Q-learning parameters (especially epsilon after decay)\n            if (this.uiControls) {\n                this.uiControls.syncParametersFromQLearning();\n            }\n        }\n        \n        // Update training loss display\n        document.getElementById('training-loss').textContent = `Training Loss: ${this.lastTrainingLoss.toFixed(4)}`;\n        \n        // Update Q-value display\n        document.getElementById('qvalue-estimate').textContent = `Q-Value: ${this.lastQValue.toFixed(3)}`;\n        \n        // Update history timesteps debug display\n        this.updateHistoryDebugDisplay();\n        \n        // Update debug display during manual control and evaluation\n        if (this.demoMode === 'freerun') {\n            const robotState = this.robot ? this.robot.getState() : null;\n            if (robotState) {\n                document.getElementById('debug-last-action').textContent = this.debugLastAction;\n                document.getElementById('debug-current-reward').textContent = this.debugCurrentReward.toFixed(3);\n                document.getElementById('debug-robot-angle').textContent = `${(robotState.angle * 180 / Math.PI).toFixed(2)}°`;\n                document.getElementById('debug-angular-velocity').textContent = `${robotState.angularVelocity.toFixed(3)} rad/s`;\n            }\n        }\n        \n        // Update training status indicator\n        const statusIndicator = document.getElementById('training-status-indicator');\n        if (this.isTraining && !this.isPaused) {\n            statusIndicator.className = 'status-indicator training';\n        } else if (this.isTraining && this.isPaused) {\n            statusIndicator.className = 'status-indicator paused';\n        } else {\n            statusIndicator.className = 'status-indicator stopped';\n        }\n        \n        // Update FPS from renderer performance\n        if (this.renderer) {\n            const perfMetrics = this.renderer.performance.getMetrics();\n            document.getElementById('fps-counter').textContent = `FPS: ${perfMetrics.fps}`;\n        }\n        \n        // Performance charts are updated only on episode completion in handleEpisodeEnd()\n        \n        // Update backend performance info\n        this.updateBackendPerformanceDisplay();\n    }\n    \n    /**\n     * Update the history debug display showing current timestep values\n     */\n    updateHistoryDebugDisplay() {\n        const debugContent = document.getElementById('history-debug-content');\n        if (!debugContent || !this.robot) return;\n        \n        const robotState = this.robot.getState();\n        const timesteps = this.robot.historyTimesteps || 1;\n        \n        // Get current normalized inputs\n        const networkInput = this.robot.getNormalizedInputs();\n        \n        // Format current state\n        let displayLines = [];\n        \n        if (this.robot.rewardType === 'offset-adaptive') {\n            const measuredAngle = this.robot.getMeasuredAngle();\n            const trueAngle = robotState.angle;\n            const offset = this.robot.angleOffset;\n            \n            displayLines.push(`True: angle=${trueAngle.toFixed(3)}, angVel=${robotState.angularVelocity.toFixed(3)}`);\n            displayLines.push(`Measured: angle=${measuredAngle.toFixed(3)}, offset=${offset.toFixed(3)}`);\n        } else {\n            displayLines.push(`Current: angle=${robotState.angle.toFixed(3)}, angVel=${robotState.angularVelocity.toFixed(3)}`);\n        }\n        \n        // Format network input (showing all timesteps vertically)\n        displayLines.push(`Network Input [${timesteps}x]:`);\n        for (let i = 0; i < networkInput.length; i += 2) {\n            const angle = networkInput[i];\n            const angVel = networkInput[i + 1];\n            const timestepIndex = (i / 2) + 1;\n            displayLines.push(`  T${timestepIndex}: [${angle.toFixed(2)}, ${angVel.toFixed(2)}]`);\n        }\n        \n        // Show timestep info\n        displayLines.push(`Timesteps: ${timesteps} (${networkInput.length} inputs total)`);\n        \n        // Show state history stats if available\n        if (this.robot.stateHistory && timesteps > 1) {\n            const stats = this.robot.stateHistory.getStats();\n            displayLines.push(`Avg Angle: ${stats.averageAngle.toFixed(3)}, StdDev: ${stats.angleStdDev.toFixed(3)}`);\n        }\n        \n        debugContent.innerHTML = displayLines.map(line => `<div>${line}</div>`).join('');\n    }\n    \n    /**\n     * Update WebGPU status display with detailed information\n     */\n    updateWebGPUStatusDisplay() {\n        const backendTypeElement = document.getElementById('backend-type');\n        const deviceInfoElement = document.getElementById('device-info');\n        const performanceEstimateElement = document.getElementById('performance-estimate');\n        \n        if (!this.webgpuBackend) {\n            backendTypeElement.textContent = 'Backend: Not initialized';\n            deviceInfoElement.textContent = 'WebGPU backend not yet initialized';\n            performanceEstimateElement.textContent = '';\n            return;\n        }\n        \n        const backendInfo = this.webgpuBackend.getBackendInfo();\n        const deviceInfo = backendInfo.deviceInfo;\n        \n        // Update backend type\n        const backendType = backendInfo.webgpuAvailable ? 'WebGPU' : 'CPU (Fallback)';\n        backendTypeElement.textContent = `Backend: ${backendType}`;\n        \n        // Update device information\n        if (backendInfo.webgpuAvailable && deviceInfo.adapterInfo) {\n            const adapter = deviceInfo.adapterInfo;\n            deviceInfoElement.innerHTML = `\n                <div>Vendor: ${adapter.vendor}</div>\n                <div>Device: ${adapter.device}</div>\n                <div>Architecture: ${adapter.architecture}</div>\n            `;\n        } else if (backendInfo.fallbackReason) {\n            deviceInfoElement.innerHTML = `\n                <div style=\"color: #ff6666;\">Fallback reason:</div>\n                <div>${backendInfo.fallbackReason}</div>\n            `;\n        } else {\n            deviceInfoElement.textContent = 'No detailed device information available';\n        }\n        \n        // Update performance estimate\n        if (backendInfo.capabilities && backendInfo.webgpuAvailable) {\n            const caps = backendInfo.capabilities;\n            performanceEstimateElement.innerHTML = `\n                <div>Estimated speedup: ${caps.estimatedSpeedup.toFixed(1)}x</div>\n                <div>Max workgroup size: ${caps.maxWorkgroupSize || 'Unknown'}</div>\n                <div>Max buffer size: ${caps.maxBufferSizeMB || 'Unknown'} MB</div>\n            `;\n        } else {\n            performanceEstimateElement.textContent = 'CPU backend - no hardware acceleration';\n        }\n        \n        console.log('WebGPU status display updated');\n    }\n    \n    updateCPUCoresStatusDisplay() {\n        const coresInfoElement = document.getElementById('cores-info');\n        const workersInfoElement = document.getElementById('workers-info');\n        const parallelSpeedupElement = document.getElementById('parallel-speedup');\n        \n        if (!this.systemCapabilities) {\n            coresInfoElement.textContent = 'CPU Cores: Not detected';\n            workersInfoElement.textContent = 'Parallel training unavailable';\n            parallelSpeedupElement.textContent = '';\n            return;\n        }\n        \n        // Update core count\n        const coreCount = this.systemCapabilities.coreCount;\n        const targetCores = this.systemCapabilities.targetCores;\n        const maxWorkers = this.systemCapabilities.maxWorkers;\n        \n        coresInfoElement.textContent = `CPU Cores: ${coreCount} detected`;\n        \n        // Update worker information\n        if (maxWorkers > 1) {\n            workersInfoElement.innerHTML = `\n                <div>Using ${targetCores} cores (50% of ${coreCount})</div>\n                <div>Worker threads: ${maxWorkers}</div>\n            `;\n        } else {\n            workersInfoElement.innerHTML = `\n                <div style=\"color: #ff6666;\">Single core detected</div>\n                <div>Parallel training disabled</div>\n            `;\n        }\n        \n        // Update speedup estimate\n        if (this.parallelQLearning) {\n            const perfStats = this.parallelQLearning.getPerformanceStats();\n            if (perfStats.speedupFactor > 1) {\n                parallelSpeedupElement.innerHTML = `\n                    <div>Training speedup: ${perfStats.speedupFactor.toFixed(1)}x</div>\n                    <div>Parallel episodes: ${perfStats.totalParallelEpisodes}</div>\n                `;\n            } else {\n                parallelSpeedupElement.textContent = 'Speedup measurement in progress...';\n            }\n        } else if (maxWorkers > 1) {\n            parallelSpeedupElement.textContent = `Estimated speedup: ${Math.min(maxWorkers, 4).toFixed(1)}x`;\n        } else {\n            parallelSpeedupElement.textContent = 'No parallel acceleration';\n        }\n        \n        console.log('CPU cores status display updated');\n    }\n    \n    /**\n     * Update training performance metrics display\n     */\n    updatePerformanceMetricsDisplay() {\n        const episodesPerMinuteElement = document.getElementById('episodes-per-minute');\n        const stepsPerSecondElement = document.getElementById('steps-per-second');\n        const renderingModeElement = document.getElementById('rendering-mode');\n        const trainingEfficiencyElement = document.getElementById('training-efficiency');\n        \n        if (!this.performanceTracker) {\n            return;\n        }\n        \n        const displayStats = this.performanceTracker.getDisplayStats();\n        \n        // Update performance metrics\n        if (episodesPerMinuteElement) {\n            episodesPerMinuteElement.textContent = `Episodes/min: ${displayStats.episodesPerMinute}`;\n        }\n        \n        if (stepsPerSecondElement) {\n            stepsPerSecondElement.textContent = `Steps/sec: ${displayStats.stepsPerSecond}`;\n        }\n        \n        if (renderingModeElement) {\n            const mode = displayStats.renderingMode;\n            let color = '#ffaa00'; // Default orange\n            \n            if (mode.includes('Full')) {\n                color = '#00ff88'; // Green for full rendering\n            } else if (mode.includes('Sparse')) {\n                color = '#ffaa00'; // Orange for sparse rendering\n            } else if (mode.includes('Minimal')) {\n                color = '#ff6666'; // Red for minimal rendering\n            }\n            \n            renderingModeElement.innerHTML = `<span style=\"color: ${color}\">Rendering: ${mode}</span>`;\n        }\n        \n        if (trainingEfficiencyElement) {\n            const efficiency = parseFloat(displayStats.trainingEfficiency.replace('%', ''));\n            let color = '#00d4ff'; // Default blue\n            \n            if (efficiency >= 80) {\n                color = '#00ff88'; // Green for high efficiency\n            } else if (efficiency >= 50) {\n                color = '#ffaa00'; // Orange for medium efficiency\n            } else if (efficiency > 0) {\n                color = '#ff6666'; // Red for low efficiency\n            }\n            \n            trainingEfficiencyElement.innerHTML = `<span style=\"color: ${color}\">Training efficiency: ${displayStats.trainingEfficiency}</span>`;\n        }\n    }\n    \n    /**\n     * Update backend performance display\n     */\n    updateBackendPerformanceDisplay() {\n        const performanceElement = document.getElementById('backend-performance');\n        \n        if (!this.webgpuBackend) {\n            performanceElement.textContent = '';\n            return;\n        }\n        \n        const perfMetrics = this.webgpuBackend.getPerformanceMetrics();\n        \n        if (perfMetrics.totalForwardPasses > 0) {\n            const avgTime = perfMetrics.averageForwardTime.toFixed(2);\n            const speedup = perfMetrics.estimatedSpeedup.toFixed(1);\n            performanceElement.textContent = `Avg forward pass: ${avgTime}ms | Est. speedup: ${speedup}x`;\n        } else {\n            performanceElement.textContent = 'No performance data yet';\n        }\n    }\n\n    showLoading(show) {\n        const loadingElement = document.getElementById('loading');\n        loadingElement.style.display = show ? 'flex' : 'none';\n    }\n\n    showError(message) {\n        alert('Error: ' + message);\n        console.error(message);\n    }\n\n    destroy() {\n        if (this.renderer) {\n            this.renderer.destroy();\n            this.renderer = null;\n        }\n        \n        if (this.webgpuBackend) {\n            this.webgpuBackend.destroy();\n            this.webgpuBackend = null;\n        }\n        \n        this.robot = null;\n        this.qlearning = null;\n        \n        console.log('Application destroyed');\n    }\n    \n    /**\n     * Initialize physics and ML components\n     */\n    async initializeComponents() {\n        // Get parameters from UI controls (will be loaded from localStorage if available)\n        const uiControls = new UIControls(this);\n        \n        // Initialize robot physics with parameters\n        // Scale timestep to account for multiple physics steps per frame\n        // Default timestep of 0.02s is for 1 step per 20ms (50 Hz)\n        // With minimum 3 steps per frame at 60 FPS, we need 0.02/3 = 0.0067s per step\n        const baseTimestep = 0.02; // 20ms timestep for real-time physics\n        const minStepsPerFrame = 3; // Our minimum steps per frame for smooth motion\n        const adjustedTimestep = baseTimestep / minStepsPerFrame;\n        \n        this.robot = createDefaultRobot({\n            mass: uiControls.getParameter('robotMass'),\n            centerOfMassHeight: uiControls.getParameter('robotHeight'),\n            motorStrength: uiControls.getParameter('motorStrength'),\n            friction: 0.1,\n            damping: 0.05,\n            timestep: adjustedTimestep,\n            maxAngle: uiControls.getParameter('maxAngle'),\n            motorTorqueRange: uiControls.getParameter('motorTorqueRange'),\n            rewardType: 'complex' // Default to proportional reward\n        });\n        \n        // Set training offset range if available\n        if (this.maxOffsetRangeDegrees > 0) {\n            this.robot.setTrainingOffsetRange(this.maxOffsetRangeDegrees);\n        }\n        \n        // Reset robot to initial state\n        this.robot.reset({\n            angle: (Math.random() - 0.5) * 0.1, // Small random initial angle\n            angularVelocity: 0,\n            position: 0,\n            velocity: 0\n        });\n        \n        console.log('Physics components initialized');\n    }\n    \n    /**\n     * Initialize Q-learning for training with variable timestep support\n     */\n    async initializeQLearning(overrideParams = {}) {\n        // Get current timestep settings from robot\n        const timesteps = this.robot ? this.robot.historyTimesteps : 1;\n        const inputSize = timesteps * 2; // 2 values per timestep (angle, angular velocity)\n        \n        // Use parameters from UI controls if available\n        const params = this.uiControls ? {\n            learningRate: this.uiControls.getParameter('learningRate'),\n            epsilon: this.uiControls.getParameter('epsilon'),\n            epsilonDecay: 0.995,\n            maxEpisodes: 1000,\n            maxStepsPerEpisode: 1000,\n            hiddenSize: this.uiControls.getParameter('hiddenNeurons'),\n            ...overrideParams\n        } : {\n            learningRate: 0.0020,  // Optimized default for better convergence\n            epsilon: 0.3,         // Moderate exploration\n            epsilonDecay: 0.995,  // Slower epsilon decay for stability\n            gamma: 0.95,          // Standard discount factor\n            batchSize: 8,         // Larger batch for stability\n            targetUpdateFreq: 100, // Standard update frequency\n            maxEpisodes: 1000,\n            maxStepsPerEpisode: 1000,\n            hiddenSize: 8,\n            ...overrideParams\n        };\n        \n        // Create Q-learning with WebGPU backend\n        this.qlearning = createDefaultQLearning(params);\n        \n        // Initialize with WebGPU backend if available\n        if (this.webgpuBackend) {\n            console.log('Initializing Q-learning with WebGPU backend support...');\n            // Note: Q-learning will use the backend internally\n            // For now, the integration is prepared for when Q-learning supports custom backends\n        }\n        \n        // Initialize with calculated input size for current timestep setting\n        await this.qlearning.initialize(inputSize);\n        console.log(`Q-learning initialized for ${timesteps} timesteps (${inputSize} inputs) with parameters:`, params);\n        \n        // Initialize parallel training wrapper\n        if (this.systemCapabilities && this.systemCapabilities.maxWorkers > 1) {\n            this.parallelQLearning = new ParallelQLearning(this.qlearning, this.robot);\n            await this.parallelQLearning.initialize();\n            console.log(`Parallel training initialized with ${this.systemCapabilities.maxWorkers} workers`);\n        } else {\n            console.log('Parallel training disabled (insufficient cores)');\n        }\n        \n        // Log backend information\n        if (this.webgpuBackend) {\n            const backendInfo = this.webgpuBackend.getBackendInfo();\n            console.log('Neural network backend:', backendInfo.type);\n            if (backendInfo.usingFallback) {\n                console.log('Fallback reason:', backendInfo.fallbackReason);\n            }\n        }\n    }\n    \n    /**\n     * Get motor torque for physics demo (simple balancing controller)\n     */\n    getPhysicsDemoTorque() {\n        const state = this.robot.getState();\n        \n        // Simple PD controller for demonstration\n        const kp = 20; // Proportional gain\n        const kd = 5;  // Derivative gain\n        \n        // Use measured angle (includes sensor offset) instead of true angle\n        const measuredAngle = this.robot.getMeasuredAngle();\n        const torque = (kp * measuredAngle + kd * state.angularVelocity);\n        \n        // Debug offset effect (only log occasionally to avoid spam)\n        if (Math.abs(this.robot.angleOffset) > 0.01 && Math.random() < 0.01) {\n            console.log(`PD Controller: true=${(state.angle * 180 / Math.PI).toFixed(1)}°, measured=${(measuredAngle * 180 / Math.PI).toFixed(1)}°, offset=${(this.robot.angleOffset * 180 / Math.PI).toFixed(1)}°`);\n        }\n        \n        // Add some noise for more interesting behavior\n        const noise = (Math.random() - 0.5) * 0.5;\n        \n        return Math.max(-5, Math.min(5, torque + noise));\n    }\n    \n    /**\n     * Get motor torque from Q-learning during training\n     */\n    getTrainingTorque() {\n        const result = this.getTrainingTorqueWithAction();\n        return result.torque;\n    }\n    \n    /**\n     * Get motor torque and action index from Q-learning during training\n     */\n    getTrainingTorqueWithAction() {\n        if (!this.qlearning) return { torque: 0, actionIndex: 0 };\n        \n        // Get normalized state directly from robot (includes multi-timestep logic)\n        const normalizedState = this.robot.getNormalizedInputs();\n        \n        // Debug offset effect on neural network (log occasionally to avoid spam)\n        if (Math.abs(this.robot.angleOffset) > 0.01 && Math.random() < 0.01) {\n            const trueAngle = this.robot.getState().angle;\n            const measuredAngle = this.robot.getMeasuredAngle();\n            console.log(`Neural Network Input: true=${(trueAngle * 180 / Math.PI).toFixed(1)}°, measured=${(measuredAngle * 180 / Math.PI).toFixed(1)}°, offset=${(this.robot.angleOffset * 180 / Math.PI).toFixed(1)}°, normalized=[${normalizedState[0].toFixed(3)}, ${normalizedState[1].toFixed(3)}]`);\n        }\n        \n        // Get Q-values for current state\n        const qValues = this.qlearning.getAllQValues(normalizedState);\n        \n        // Select action using epsilon-greedy policy\n        const actionIndex = this.qlearning.selectAction(normalizedState, true);\n        const actions = [-1.0, 0.0, 1.0]; // Left, brake, right (standardized with QLearning.js)\n        \n        // Update last Q-value for display (max Q-value) with NaN protection\n        if (qValues && qValues.length > 0) {\n            const validQValues = Array.from(qValues).filter(val => isFinite(val));\n            this.lastQValue = validQValues.length > 0 ? Math.max(...validQValues) : 0;\n            \n            // Debug: Log Q-values periodically to see if they're changing\n            if (this.trainingStep % 100 === 0) {\n                console.log(`Step ${this.trainingStep} Q-values:`, \n                    Array.from(qValues).map(v => v.toFixed(4)), \n                    'Max:', this.lastQValue.toFixed(4));\n            }\n        } else {\n            this.lastQValue = 0;\n        }\n        \n        return {\n            torque: actions[actionIndex],\n            actionIndex: actionIndex\n        };\n    }\n    \n    /**\n     * Get motor torque from trained Q-learning (evaluation mode)\n     */\n    getEvaluationTorque() {\n        if (!this.qlearning) return 0;\n        \n        // Get normalized state directly from robot (includes multi-timestep logic)\n        const normalizedState = this.robot.getNormalizedInputs();\n        \n        // Select best action (no exploration)\n        const actionIndex = this.qlearning.selectAction(normalizedState, false);\n        const actions = [-1.0, 0.0, 1.0]; // Standardized action values\n        \n        return actions[actionIndex];\n    }\n    \n    /**\n     * Decide whether to run single episode or parallel batch\n     */\n    async startNextEpisodeOrBatch() {\n        try {\n            // Check if parallel training is available and beneficial\n            const shouldUseParallel = this.shouldUseParallelTraining();\n            \n            if (shouldUseParallel) {\n                // Pure parallel training - let workers handle everything for maximum speed\n                await this.runParallelEpisodeBatch();\n            } else {\n                this.startNewEpisode();\n            }\n        } catch (error) {\n            console.error('Critical training error in startNextEpisodeOrBatch:', error);\n            \n            // Reset training state to prevent getting stuck\n            this.isTraining = false;\n            this.isPaused = false;\n            this.demoMode = 'freerun';\n            \n            // Update UI to reflect stopped state\n            const startButton = document.getElementById('start-training');\n            const pauseButton = document.getElementById('pause-training');\n            \n            if (startButton) startButton.disabled = false;\n            if (pauseButton) {\n                pauseButton.disabled = true;\n                pauseButton.textContent = 'Pause Training';\n            }\n            \n            // Update training display\n            this.updateTrainingModelDisplay();\n            this.updateOnScreenControlsVisibility();\n            \n            // Show error to user\n            alert('Training stopped due to an error. Please check the console for details and try starting training again.');\n        }\n    }\n    \n    /**\n     * Determine if parallel training should be used\n     */\n    shouldUseParallelTraining() {\n        // Use parallel training if:\n        // 1. Parallel training is available\n        // 2. Parallel mode is manually enabled via the Parallel button\n        \n        if (!this.parallelQLearning || !this.parallelQLearning.parallelManager.parallelEnabled) {\n            return false;\n        }\n        \n        // Use parallel training only when explicitly enabled by user\n        return this.parallelModeEnabled;\n    }\n    \n    /**\n     * Run a batch of episodes in parallel\n     */\n    async runParallelEpisodeBatch() {\n        console.log('🚀 Running parallel episode batch...');\n        \n        try {\n            // Determine batch size based on worker configuration\n            const batchSize = this.parallelQLearning.parallelManager.config.batchSize;\n            \n            // Use full batch size for maximum parallel performance\n            const effectiveBatchSize = batchSize;\n            \n            // Performance tracking - start batch\n            const batchStartTime = Date.now();\n            this.performanceTracker.startEpisode();\n            \n            // Run parallel episodes\n            const results = await this.parallelQLearning.parallelManager.runEpisodes(effectiveBatchSize);\n            \n            // Process results and update charts for each individual episode\n            let totalReward = 0;\n            let totalSteps = 0;\n            let bestEpisodeReward = -Infinity;\n            \n            console.log(`📊 Processing ${results.length} individual episode results...`);\n            \n            for (let i = 0; i < results.length; i++) {\n                const result = results[i];\n                if (result) {\n                    const episodeReward = result.totalReward || 0;\n                    const episodeSteps = result.stepCount || 0;\n                    \n                    totalReward += episodeReward;\n                    totalSteps += episodeSteps;\n                    \n                    // Track best episode in this batch\n                    if (episodeReward > bestEpisodeReward) {\n                        bestEpisodeReward = episodeReward;\n                    }\n                    \n                    // Update episode count for each completed episode\n                    this.episodeCount++;\n                    \n                    // Update best score if this episode was better\n                    if (episodeReward > this.bestScore) {\n                        this.bestScore = episodeReward;\n                    }\n                    \n                    // Update performance charts for EACH individual episode\n                    if (this.performanceCharts && this.qlearning) {\n                        // Create balanced state matching current timestep configuration\n                        const timesteps = this.robot ? this.robot.historyTimesteps : 1;\n                        const inputSize = timesteps * 2;\n                        const balancedState = new Float32Array(inputSize).fill(0.0);\n                        const qValues = this.qlearning.getAllQValues(balancedState);\n                        const avgQValue = Array.from(qValues).reduce((a, b) => a + b, 0) / qValues.length;\n                        \n                        this.performanceCharts.updateMetrics({\n                            episode: this.episodeCount,\n                            reward: episodeReward, // Individual episode reward\n                            loss: this.lastTrainingLoss || 0,\n                            qValue: avgQValue,\n                            epsilon: this.qlearning.hyperparams.epsilon\n                        });\n                    }\n                    \n                    // Add worker experiences to replay buffer for training\n                    if (result.experiences && result.experiences.length > 0) {\n                        for (const experience of result.experiences) {\n                            this.qlearning.replayBuffer.addExperience(\n                                new Float32Array(experience.state),\n                                experience.action,\n                                experience.reward,\n                                new Float32Array(experience.nextState),\n                                experience.done\n                            );\n                        }\n                    }\n                    \n                    console.log(`  Episode ${this.episodeCount}: reward=${episodeReward.toFixed(2)}, steps=${episodeSteps}, experiences=${result.experiences?.length || 0}`);\n                    \n                    // Small delay between individual episode updates to make charts visible\n                    await new Promise(resolve => setTimeout(resolve, 2));\n                }\n            }\n            \n            // Train the network on collected experiences\n            let totalTrainingLoss = 0;\n            const totalExperiencesCollected = results.reduce((sum, result) => sum + (result?.experiences?.length || 0), 0);\n            \n            if (this.qlearning.replayBuffer.size() >= this.qlearning.hyperparams.batchSize) {\n                // Scale training steps based on how much new data we collected\n                // More experiences = more training to utilize the data effectively\n                const baseTrainingSteps = effectiveBatchSize;\n                const experienceMultiplier = Math.max(1, Math.ceil(totalExperiencesCollected / 32)); // Scale up for lots of data\n                const trainingSteps = Math.min(baseTrainingSteps * experienceMultiplier, totalExperiencesCollected);\n                \n                for (let i = 0; i < trainingSteps; i++) {\n                    const loss = this.qlearning._trainBatch();\n                    totalTrainingLoss += loss || 0;\n                    \n                    // Standard yield frequency for performance\n                    const yieldFrequency = 2;\n                    if (i % yieldFrequency === 0) {\n                        await new Promise(resolve => setTimeout(resolve, 0));\n                    }\n                }\n                this.lastTrainingLoss = trainingSteps > 0 ? totalTrainingLoss / trainingSteps : 0;\n            }\n            \n            // Performance tracking - end batch\n            const batchEndTime = Date.now();\n            const batchTrainingTime = batchEndTime - batchStartTime;\n            this.performanceTracker.endEpisode(totalSteps, batchTrainingTime);\n            \n            // Update episode timing statistics (simulate episode completion)\n            const now = Date.now();\n            if (!this.episodeTimings) {\n                this.episodeTimings = {\n                    lastEpisodeTime: now,\n                    episodeCount: 0,\n                    recentEpisodes: [],\n                    lastLogTime: now\n                };\n            }\n            \n            // Add timing for the entire batch (simulating rapid episode completion)\n            const avgEpisodeTime = batchTrainingTime / batchSize;\n            for (let i = 0; i < batchSize; i++) {\n                this.episodeTimings.recentEpisodes.push(avgEpisodeTime);\n                this.episodeTimings.episodeCount++;\n            }\n            this.episodeTimings.lastEpisodeTime = now;\n            \n            // Keep only last 10 episodes for rate calculation\n            while (this.episodeTimings.recentEpisodes.length > 10) {\n                this.episodeTimings.recentEpisodes.shift();\n            }\n            \n            // Calculate and log performance metrics (every 5 episodes)\n            if (this.episodeTimings.episodeCount % 5 === 0) {\n                const avgIntervalMs = this.episodeTimings.recentEpisodes.reduce((a, b) => a + b, 0) / this.episodeTimings.recentEpisodes.length;\n                const episodesPerSecond = 1000 / avgIntervalMs;\n                const episodesPerMinute = episodesPerSecond * 60;\n                const episodeDurationSec = avgIntervalMs / 1000;\n                \n                console.log(`🔥 PARALLEL PERFORMANCE: ${this.trainingSpeed}x speed → ${episodesPerSecond.toFixed(2)} eps/sec (${episodesPerMinute.toFixed(0)} eps/min)`);\n                console.log(`📊 BATCH ${Math.floor(this.episodeCount/batchSize)}: Duration=${(batchTrainingTime/1000).toFixed(2)}s, Episodes=${batchSize}, Best Reward=${bestEpisodeReward.toFixed(2)}`);\n            }\n            \n            // Charts are now updated individually for each episode above\n            // No need for batch-level chart update\n            \n            // Update target network periodically\n            if (this.qlearning.stepCount % this.qlearning.hyperparams.targetUpdateFreq === 0) {\n                this.qlearning.updateTargetNetwork();\n            }\n            \n            \n            // Update statistics for logging\n            const avgReward = totalReward / results.length;\n            const avgSteps = totalSteps / results.length;\n            \n            console.log(`✅ Parallel batch completed: ${results.length} episodes, avg reward: ${avgReward.toFixed(2)}, best: ${bestEpisodeReward.toFixed(2)}, avg steps: ${avgSteps.toFixed(0)}`);\n            console.log(`📊 Training data: ${totalExperiencesCollected} experiences collected, ${trainingSteps || 0} training steps performed (${((trainingSteps || 0) / Math.max(1, totalExperiencesCollected) * 100).toFixed(1)}% utilization)`);\n            \n            // Yield control to UI and continue training after brief pause\n            await new Promise(resolve => setTimeout(resolve, 50)); // Longer pause to allow UI updates\n            \n            // Continue training if still in training mode\n            if (this.isTraining) {\n                this.startNextEpisodeOrBatch();\n            }\n            \n        } catch (error) {\n            console.warn('Parallel batch failed, falling back to single episode:', error);\n            this.startNewEpisode();\n        }\n    }\n    \n    /**\n     * Start a new training episode\n     */\n    startNewEpisode() {\n        this.trainingStep = 0;\n        this.episodeEnded = false; // Reset episode end flag\n        \n        // Performance tracking - start episode\n        this.performanceTracker.startEpisode();\n        this.episodeStartTime = Date.now();\n        \n        // Reset Q-learning training state\n        this.previousState = null;\n        this.previousAction = undefined;\n        this.previousReward = 0;\n        this.previousDone = false;\n        this.lastTrainingLoss = 0;\n        \n        // Reset robot with small random perturbation\n        this.robot.reset({\n            angle: (Math.random() - 0.5) * 0.2,\n            angularVelocity: (Math.random() - 0.5) * 0.5,\n            position: 0,\n            velocity: 0\n        });\n        \n        console.log(`Starting episode ${this.episodeCount + 1}`);\n    }\n    \n    /**\n     * Handle end of training/evaluation episode\n     */\n    handleEpisodeEnd(result) {\n        const totalReward = this.robot.getStats().totalReward;\n        \n        // Performance tracking - end episode\n        const episodeEndTime = Date.now();\n        const episodeTrainingTime = episodeEndTime - this.episodeStartTime;\n        this.performanceTracker.endEpisode(this.trainingStep, episodeTrainingTime);\n        \n        // Update best score\n        if (totalReward > this.bestScore) {\n            this.bestScore = totalReward;\n        }\n        \n        if (this.demoMode === 'training' && this.isTraining) {\n            // Only increment episode count during actual training\n            this.episodeCount++;\n            \n            // Performance monitoring for episode completion rate\n            const now = Date.now();\n            if (!this.episodeTimings) {\n                this.episodeTimings = {\n                    lastEpisodeTime: now,\n                    episodeCount: 0,\n                    recentEpisodes: [],\n                    lastLogTime: now\n                };\n            }\n            \n            const timeSinceLastEpisode = now - this.episodeTimings.lastEpisodeTime;\n            this.episodeTimings.recentEpisodes.push(timeSinceLastEpisode);\n            this.episodeTimings.lastEpisodeTime = now;\n            this.episodeTimings.episodeCount++;\n            \n            // Keep only last 10 episodes for rate calculation\n            if (this.episodeTimings.recentEpisodes.length > 10) {\n                this.episodeTimings.recentEpisodes.shift();\n            }\n            \n            // Log performance every 5 episodes for more frequent monitoring\n            if (this.episodeTimings.episodeCount % 5 === 0) {\n                const avgIntervalMs = this.episodeTimings.recentEpisodes.reduce((a, b) => a + b, 0) / this.episodeTimings.recentEpisodes.length;\n                const episodesPerSecond = 1000 / avgIntervalMs;\n                const episodesPerMinute = episodesPerSecond * 60;\n                \n                // Calculate episode duration in seconds\n                const episodeDurationMs = now - this.episodeStartTime;\n                const episodeDurationSec = episodeDurationMs / 1000;\n                \n                console.log(`🔥 PERFORMANCE: ${this.trainingSpeed}x speed → ${episodesPerSecond.toFixed(2)} eps/sec (${episodesPerMinute.toFixed(0)} eps/min)`);\n                console.log(`📊 EPISODE ${this.episodeCount}: Duration=${episodeDurationSec.toFixed(2)}s, Steps=${this.trainingStep}, Reward=${totalReward.toFixed(2)}`);\n                \n                // Check if episode duration is scaling unexpectedly with speed\n                const expectedDuration = 8000 / (50 * this.trainingSpeed); // 8000 steps at 50Hz base rate\n                const durationRatio = episodeDurationSec / expectedDuration;\n                if (durationRatio > 2.0) {\n                    console.warn(`⚠️  SLOW EPISODE: Taking ${durationRatio.toFixed(2)}x longer than expected!`);\n                }\n            }\n            \n            // Update model display with latest stats\n            this.updateTrainingModelDisplay();\n            \n            // Update performance metrics display\n            this.updatePerformanceMetricsDisplay();\n            \n            \n            \n            // Update performance charts with episode completion data\n            if (this.performanceCharts && this.qlearning) {\n                // Get current Q-value estimate for balanced state\n                // Create balanced state matching current timestep configuration\n                const timesteps = this.robot ? this.robot.historyTimesteps : 1;\n                const inputSize = timesteps * 2;\n                const balancedState = new Float32Array(inputSize).fill(0.0); // All timesteps balanced\n                const qValues = this.qlearning.getAllQValues(balancedState);\n                const avgQValue = Array.from(qValues).reduce((a, b) => a + b, 0) / qValues.length;\n                \n                this.performanceCharts.updateMetrics({\n                    episode: this.episodeCount,\n                    reward: totalReward,\n                    loss: this.lastTrainingLoss || 0,\n                    qValue: avgQValue,\n                    epsilon: this.qlearning.hyperparams.epsilon\n                });\n            }\n            \n            // Start next episode after brief pause\n            setTimeout(() => {\n                try {\n                    console.log(`🔄 Episode ${this.episodeCount} completed. Training state: isTraining=${this.isTraining}, isPaused=${this.isPaused}`);\n                    if (this.isTraining) {\n                        console.log(`✅ Starting next episode/batch...`);\n                        this.startNextEpisodeOrBatch();\n                    } else {\n                        console.warn(`⚠️ Training stopped unexpectedly! isTraining=${this.isTraining}, isPaused=${this.isPaused}`);\n                        // This is where the bug might be - training stopped but UI not updated\n                        // Force UI update to reflect actual state\n                        const startButton = document.getElementById('start-training');\n                        const pauseButton = document.getElementById('pause-training');\n                        \n                        if (startButton) startButton.disabled = false;\n                        if (pauseButton) {\n                            pauseButton.disabled = true;\n                            pauseButton.textContent = 'Pause Training';\n                        }\n                        \n                        this.updateTrainingModelDisplay();\n                        console.log('🛠️ UI state corrected to match actual training state');\n                    }\n                } catch (error) {\n                    console.error('Error in setTimeout callback for next episode:', error);\n                    // Reset training state if error occurs\n                    this.isTraining = false;\n                    this.isPaused = false;\n                    this.demoMode = 'freerun';\n                    \n                    // Update UI\n                    const startButton = document.getElementById('start-training');\n                    const pauseButton = document.getElementById('pause-training');\n                    \n                    if (startButton) startButton.disabled = false;\n                    if (pauseButton) {\n                        pauseButton.disabled = true;\n                        pauseButton.textContent = 'Pause Training';\n                    }\n                    \n                    this.updateOnScreenControlsVisibility();\n                    \n                    this.updateTrainingModelDisplay();\n                    alert('Training stopped due to an error. Please check the console and try starting training again.');\n                }\n            }, 100);\n        } else {\n            // Evaluation mode or demo - restart after longer pause (no episode count increment)\n            console.log(`Evaluation run completed: Reward=${totalReward.toFixed(2)}`);\n            setTimeout(() => {\n                this.robot.reset({\n                    angle: (Math.random() - 0.5) * 0.2,\n                    angularVelocity: 0,\n                    position: 0,\n                    velocity: 0\n                });\n                this.trainingStep = 0;\n            }, 1000);\n        }\n    }\n    \n    /**\n     * Switch demo mode\n     */\n    async switchDemoMode(newMode) {\n        console.log(`Switching from ${this.demoMode} to ${newMode} mode`);\n        \n        // Stop training if switching away from training mode\n        if (this.demoMode === 'training' && newMode !== 'training') {\n            this.isTraining = false;\n            this.isPaused = false;\n                document.getElementById('start-training').disabled = false;\n            document.getElementById('pause-training').disabled = true;\n            document.getElementById('pause-training').textContent = 'Pause Training';\n        }\n        \n        // Disable manual control when leaving manual mode\n        if (this.demoMode === 'manual' && newMode !== 'manual') {\n            this.manualControl.enabled = false;\n            this.manualControl.leftPressed = false;\n            this.manualControl.rightPressed = false;\n            this.manualControl.manualTorque = 0;\n        }\n        \n        this.demoMode = newMode;\n        \n        // Enable manual control when entering manual mode\n        if (newMode === 'manual') {\n            this.manualControl.enabled = true;\n            console.log('Manual control enabled. Use arrow keys: ← → to balance, ↑ to reset');\n        }\n        \n        // Update PD controller UI based on new mode\n        this.updatePDControllerUI();\n        this.updateUserControlUI();\n        this.updateRewardTypeUI();\n        this.updateOnScreenControlsVisibility();\n        \n        // Initialize Q-learning if switching to training or evaluation mode\n        if ((newMode === 'training' || newMode === 'evaluation') && !this.qlearning) {\n            await this.initializeQLearning();\n        }\n        \n        // Reset environment for new mode\n        this.resetEnvironment();\n    }\n    \n    /**\n     * Determine if Q-learning training should occur this physics step\n     * Reduces training frequency at high speeds to prevent bottlenecks\n     * @param {number} currentStep - Current step in the physics loop\n     * @param {number} totalSteps - Total steps to run this frame\n     * @returns {boolean} Whether to train this step\n     */\n    _shouldTrainThisStep(currentStep, totalSteps) {\n        // Always train on episode boundaries (handled separately)\n        // For regular steps, use intelligent training frequency based on speed\n        \n        if (totalSteps <= 10) {\n            // Low speed: train every step for maximum learning\n            return true;\n        } else if (totalSteps <= 50) {\n            // Medium speed: train every other step\n            return currentStep % 2 === 0;\n        } else if (totalSteps <= 100) {\n            // High speed: train every 4th step\n            return currentStep % 4 === 0;\n        } else if (totalSteps <= 500) {\n            // Very high speed: train every 10th step\n            return currentStep % 10 === 0;\n        } else {\n            // Extreme speed: train every 20th step\n            return currentStep % 20 === 0;\n        }\n    }\n\n    /**\n     * Parameter update methods called by UI controls\n     */\n    setTrainingSpeed(speed) {\n        this.trainingSpeed = Math.max(0.1, Math.min(1000.0, speed));\n        this.targetPhysicsStepsPerFrame = Math.round(this.trainingSpeed);\n        console.log(`Training speed set to ${speed}x (${this.targetPhysicsStepsPerFrame} steps/frame)`);\n        \n        // CRITICAL FIX: Restart simulation with adapted interval for the new speed\n        if (this.isInitialized && this.smartRenderingManager.renderingMode === 'interval') {\n            console.log('Restarting simulation with adapted interval for new speed...');\n            this.startSimulation(); // This will call stopSimulation() and restart with correct interval\n        }\n    }\n    \n    setDebugSpeed(speed) {\n        this.debugSpeed = Math.max(0.1, Math.min(2.0, speed));\n        console.log(`Debug speed set to ${speed}x`);\n    }\n    \n    setParallelMode(enabled) {\n        this.parallelModeEnabled = enabled;\n        console.log(`Parallel training mode ${enabled ? 'enabled' : 'disabled'}`);\n    }\n    \n    testModel() {\n        // Check if model is available\n        if (!this.qlearning) {\n            alert('No model available for testing!\\n\\nPlease train a model first or load a saved model.');\n            return;\n        }\n        \n        // Stop any current training\n        if (this.isTraining) {\n            this.pauseTraining();\n        }\n        \n        // Switch to free run mode\n        this.demoMode = 'freerun';\n        this.isTraining = false;\n        this.isPaused = false;\n        \n        // Disable PD controller and User Control Only to enable model control\n        this.pdControllerEnabled = false;\n        this.userControlOnlyEnabled = false;\n        \n        // Update UI states\n        this.updateFreeRunSpeedUI();\n        this.updatePDControllerUI();\n        this.updateUserControlOnlyUI();\n        \n        // Reset robot to a clean state for testing\n        if (this.robot) {\n            this.robot.reset({\n                angle: (Math.random() - 0.5) * 0.1,\n                angularVelocity: 0,\n                position: 0,\n                velocity: 0\n            });\n        }\n        \n        console.log('Testing model in free run mode - Model Control active');\n    }\n    \n    updateFreeRunSpeedUI() {\n        const slider = document.getElementById('debug-speed');\n        const label = document.querySelector('label[for=\"debug-speed\"]');\n        \n        if (slider && label) {\n            const isEnabled = this.demoMode === 'freerun';\n            slider.disabled = !isEnabled;\n            slider.style.opacity = isEnabled ? '1' : '0.5';\n            label.style.opacity = isEnabled ? '1' : '0.5';\n        }\n        \n        // Show/hide on-screen controls based on mode\n        this.updateOnScreenControlsVisibility();\n    }\n    \n    setupOnScreenControls() {\n        // Left control button\n        document.getElementById('control-left')?.addEventListener('mousedown', () => {\n            if (!this.userControlEnabled) return;\n            this.manualControl.leftPressed = true;\n            this.updateManualTorque();\n        });\n        document.getElementById('control-left')?.addEventListener('mouseup', () => {\n            if (!this.userControlEnabled) return;\n            this.manualControl.leftPressed = false;\n            this.updateManualTorque();\n        });\n        document.getElementById('control-left')?.addEventListener('mouseleave', () => {\n            if (!this.userControlEnabled) return;\n            this.manualControl.leftPressed = false;\n            this.updateManualTorque();\n        });\n        \n        // Right control button\n        document.getElementById('control-right')?.addEventListener('mousedown', () => {\n            if (!this.userControlEnabled) return;\n            this.manualControl.rightPressed = true;\n            this.updateManualTorque();\n        });\n        document.getElementById('control-right')?.addEventListener('mouseup', () => {\n            if (!this.userControlEnabled) return;\n            this.manualControl.rightPressed = false;\n            this.updateManualTorque();\n        });\n        document.getElementById('control-right')?.addEventListener('mouseleave', () => {\n            if (!this.userControlEnabled) return;\n            this.manualControl.rightPressed = false;\n            this.updateManualTorque();\n        });\n        \n        // Touch events for mobile\n        document.getElementById('control-left')?.addEventListener('touchstart', (e) => {\n            e.preventDefault();\n            if (!this.userControlEnabled) return;\n            this.manualControl.leftPressed = true;\n            this.updateManualTorque();\n        });\n        document.getElementById('control-left')?.addEventListener('touchend', (e) => {\n            e.preventDefault();\n            if (!this.userControlEnabled) return;\n            this.manualControl.leftPressed = false;\n            this.updateManualTorque();\n        });\n        \n        document.getElementById('control-right')?.addEventListener('touchstart', (e) => {\n            e.preventDefault();\n            if (!this.userControlEnabled) return;\n            this.manualControl.rightPressed = true;\n            this.updateManualTorque();\n        });\n        document.getElementById('control-right')?.addEventListener('touchend', (e) => {\n            e.preventDefault();\n            if (!this.userControlEnabled) return;\n            this.manualControl.rightPressed = false;\n            this.updateManualTorque();\n        });\n        \n        // Reset button\n        document.getElementById('control-reset')?.addEventListener('click', () => {\n            this.resetRobotPosition();\n        });\n    }\n    \n    updateOnScreenControlsVisibility() {\n        const controls = document.getElementById('on-screen-controls');\n        if (controls) {\n            const shouldShow = this.demoMode === 'freerun';\n            controls.style.display = shouldShow ? 'flex' : 'none';\n        }\n    }\n    \n    updateNetworkArchitecture(architecture) {\n        if (typeof architecture === 'number') {\n            // Backward compatibility - convert single hiddenSize to architecture\n            console.log(`Network architecture update requested: ${architecture} hidden neurons`);\n            this.currentNetworkArchitecture = {\n                layers: [architecture],\n                inputSize: 2,\n                outputSize: 3,\n                getParameterCount: () => (2 * architecture + architecture) + (architecture * 3 + 3)\n            };\n        } else {\n            // New architecture object\n            console.log(`Network architecture update requested: ${architecture.name} (${architecture.layers.join('→')} layers)`);\n            this.currentNetworkArchitecture = architecture;\n        }\n        \n        // Note: This requires reinitializing the Q-learning network\n        // For now, we'll log the request and apply it on next training start\n        if (this.qlearning) {\n            // Update hyperparams for backward compatibility\n            this.qlearning.hyperparams.hiddenSize = this.currentNetworkArchitecture.layers[0] || 8;\n            this.qlearning.hyperparams.networkArchitecture = this.currentNetworkArchitecture;\n            console.log('Network architecture will be updated on next training initialization');\n        }\n    }\n    \n    updateLearningRate(learningRate) {\n        if (this.qlearning) {\n            this.qlearning.hyperparams.learningRate = learningRate;\n            console.log(`Learning rate updated to ${learningRate}`);\n        }\n    }\n    \n    updateEpsilon(epsilon) {\n        if (this.qlearning) {\n            this.qlearning.hyperparams.epsilon = epsilon;\n            console.log(`Epsilon updated to ${epsilon}`);\n        }\n    }\n    \n    updateGamma(gamma) {\n        if (this.qlearning) {\n            this.qlearning.hyperparams.gamma = gamma;\n            console.log(`Gamma updated to ${gamma}`);\n        }\n    }\n    \n    updateEpsilonMin(epsilonMin) {\n        if (this.qlearning) {\n            this.qlearning.hyperparams.epsilonMin = epsilonMin;\n            console.log(`Epsilon Min updated to ${epsilonMin}`);\n        }\n    }\n    \n    updateEpsilonDecay(epsilonDecay) {\n        if (this.qlearning) {\n            this.qlearning.hyperparams.epsilonDecay = epsilonDecay;\n            console.log(`Epsilon Decay updated to ${epsilonDecay} steps`);\n        }\n    }\n    \n    updateBatchSize(batchSize) {\n        if (this.qlearning) {\n            this.qlearning.hyperparams.batchSize = batchSize;\n            console.log(`Batch Size updated to ${batchSize}`);\n        }\n    }\n    \n    updateTargetUpdateFreq(targetUpdateFreq) {\n        if (this.qlearning) {\n            this.qlearning.hyperparams.targetUpdateFreq = targetUpdateFreq;\n            console.log(`Target Update Frequency updated to ${targetUpdateFreq}`);\n        }\n    }\n    \n    updateMaxEpisodes(maxEpisodes) {\n        if (this.qlearning) {\n            this.qlearning.hyperparams.maxEpisodes = maxEpisodes;\n            console.log(`Max Episodes updated to ${maxEpisodes}`);\n        }\n    }\n    \n    updateMaxStepsPerEpisode(maxStepsPerEpisode) {\n        if (this.qlearning) {\n            this.qlearning.hyperparams.maxStepsPerEpisode = maxStepsPerEpisode;\n            console.log(`Max Steps Per Episode updated to ${maxStepsPerEpisode}`);\n            \n            // If currently training and current step count exceeds new limit, end episode\n            if (this.isTraining && !this.isPaused && !this.episodeEnded && \n                this.trainingStep >= maxStepsPerEpisode && \n                (this.demoMode === 'training')) {\n                console.log(`Episode ending immediately - current step ${this.trainingStep} >= new limit ${maxStepsPerEpisode}`);\n                this.episodeEnded = true;\n                // Trigger episode end on next physics update\n                setTimeout(() => {\n                    if (this.episodeEnded) {\n                        this.handleEpisodeEnd({\n                            state: this.robot.getState(),\n                            reward: this.currentReward,\n                            done: true\n                        });\n                    }\n                }, 0);\n            }\n        }\n    }\n    \n    updateRobotMass(mass) {\n        if (this.robot) {\n            const config = this.robot.getConfig();\n            config.mass = mass;\n            this.robot.updateConfig(config);\n            console.log(`Robot mass updated to ${mass} kg`);\n        }\n    }\n    \n    updateRobotHeight(height) {\n        if (this.robot) {\n            const config = this.robot.getConfig();\n            config.centerOfMassHeight = height;\n            this.robot.updateConfig(config);\n            console.log(`Robot height updated to ${height} m`);\n        }\n    }\n    \n    updateMotorStrength(strength) {\n        if (this.robot) {\n            const config = this.robot.getConfig();\n            config.motorStrength = strength;\n            this.robot.updateConfig(config);\n            console.log(`Motor strength updated to ${strength} Nm`);\n        }\n    }\n    \n    updateWheelFriction(friction) {\n        if (this.robot) {\n            const config = this.robot.getConfig();\n            config.wheelFriction = friction;\n            this.robot.updateConfig(config);\n            console.log(`Wheel friction updated to ${friction}`);\n        }\n    }\n    \n    updateMaxAngle(angle) {\n        if (this.robot) {\n            const config = this.robot.getConfig();\n            config.maxAngle = angle;\n            this.robot.updateConfig(config);\n            console.log(`Max angle updated to ${angle} rad (${(angle * 180 / Math.PI).toFixed(1)} degrees)`);\n        }\n    }\n    \n    updateMotorTorqueRange(range) {\n        if (this.robot) {\n            const config = this.robot.getConfig();\n            config.motorTorqueRange = range;\n            this.robot.updateConfig(config);\n            console.log(`Motor torque range updated to ±${range} Nm`);\n        }\n    }\n    \n    /**\n     * Update manual control torque based on pressed keys\n     */\n    updateManualTorque() {\n        const maxTorque = this.robot?.getConfig()?.motorStrength || 5.0;\n        \n        if (this.manualControl.leftPressed && this.manualControl.rightPressed) {\n            // Both pressed - no movement\n            this.manualControl.manualTorque = 0;\n            this.debugLastAction = 'Left+Right (Cancel)';\n        } else if (this.manualControl.leftPressed) {\n            // Left pressed - negative torque (move left)\n            this.manualControl.manualTorque = -maxTorque * 0.7;\n            this.debugLastAction = 'Left';\n        } else if (this.manualControl.rightPressed) {\n            // Right pressed - positive torque (move right)  \n            this.manualControl.manualTorque = maxTorque * 0.7;\n            this.debugLastAction = 'Right';\n        } else {\n            // No keys pressed\n            this.manualControl.manualTorque = 0;\n            this.debugLastAction = 'None';\n        }\n    }\n    \n    /**\n     * Get manual control torque\n     */\n    getManualTorque() {\n        return this.manualControl.manualTorque;\n    }\n    \n    /**\n     * Toggle PD controller on/off (switches between PD and Model control)\n     */\n    togglePDController() {\n        // Don't allow PD controller during training or evaluation\n        if ((this.demoMode === 'training' && this.isTraining) || this.demoMode === 'evaluation') {\n            console.log('PD Controller cannot be enabled during training or model testing');\n            return;\n        }\n        \n        // If we're in free run mode and trying to disable PD (switch to model), check if model exists\n        if (this.demoMode === 'freerun' && this.pdControllerEnabled && !this.qlearning) {\n            // User is trying to switch to model control but no model is loaded\n            alert('No model loaded!\\n\\nTo use Model Control, you need to:\\n• Train a model (Start Training)\\n• Load a saved model (Model Management)\\n• Import a pre-trained model\\n\\nPD Controller will remain active.');\n            return; // Don't toggle, keep PD controller enabled\n        }\n        \n        this.pdControllerEnabled = !this.pdControllerEnabled;\n        this.updatePDControllerUI();\n        \n        // Reset robot to clean state when changing control modes\n        this.resetRobotPosition();\n        \n        console.log('PD Controller', this.pdControllerEnabled ? 'enabled' : 'disabled');\n    }\n    \n    /**\n     * Toggle User Control Only mode on/off\n     */\n    toggleUserControlOnly() {\n        // Don't allow during training or evaluation\n        if ((this.demoMode === 'training' && this.isTraining) || this.demoMode === 'evaluation') {\n            console.log('User Control Only cannot be enabled during training or model testing');\n            return;\n        }\n        \n        this.userControlOnlyEnabled = !this.userControlOnlyEnabled;\n        this.updateUserControlOnlyUI();\n        \n        // Reset robot to clean state when changing control modes\n        this.resetRobotPosition();\n        \n        console.log('User Control Only', this.userControlOnlyEnabled ? 'enabled' : 'disabled');\n    }\n    \n    /**\n     * Update PD controller button UI\n     */\n    updatePDControllerUI() {\n        const button = document.getElementById('toggle-pd-controller');\n        const text = document.getElementById('pd-controller-text');\n        const status = document.getElementById('pd-controller-status');\n        \n        if (!button || !text || !status) return;\n        \n        // Check if PD controller should be disabled\n        const shouldDisable = (this.demoMode === 'training' && this.isTraining) || this.demoMode === 'evaluation';\n        \n        if (shouldDisable) {\n            button.disabled = true;\n            text.textContent = 'PD Controller';\n            status.textContent = '(Disabled during training/testing)';\n            status.style.color = '#666';\n            this.pdControllerEnabled = false;\n        } else {\n            button.disabled = false;\n            if (this.demoMode === 'freerun') {\n                // In free run mode, show what control method is active\n                if (this.pdControllerEnabled) {\n                    text.textContent = 'Switch to Model Control';\n                    status.textContent = '(PD Controller Active)';\n                    status.style.color = '#00ff88';\n                } else {\n                    text.textContent = 'Switch to PD Controller';\n                    status.textContent = this.qlearning ? '(Model Control Active)' : '(No Control Active)';\n                    status.style.color = this.qlearning ? '#2196F3' : '#888';\n                }\n            } else {\n                text.textContent = this.pdControllerEnabled ? 'Disable PD Controller' : 'Enable PD Controller';\n                status.textContent = this.pdControllerEnabled ? '(Active)' : '(Disabled)';\n                status.style.color = this.pdControllerEnabled ? '#00ff88' : '#888';\n            }\n            status.style.marginLeft = '0'; // Remove margin since using <br>\n        }\n    }\n    \n    /**\n     * Update User Control Only button UI\n     */\n    updateUserControlOnlyUI() {\n        const button = document.getElementById('toggle-user-control-only');\n        const text = document.getElementById('user-control-text');\n        const status = document.getElementById('user-control-status');\n        \n        if (!button || !text || !status) return;\n        \n        // Check if User Control Only should be disabled\n        const shouldDisable = (this.demoMode === 'training' && this.isTraining) || this.demoMode === 'evaluation';\n        \n        if (shouldDisable) {\n            button.disabled = true;\n            text.textContent = 'User Control Only';\n            status.textContent = '(Disabled during training/testing)';\n            status.style.color = '#666';\n            this.userControlOnlyEnabled = false;\n        } else {\n            button.disabled = false;\n            text.textContent = this.userControlOnlyEnabled ? 'Disable User Control Only' : 'Enable User Control Only';\n            status.textContent = this.userControlOnlyEnabled ? '(Active)' : '(Disabled)';\n            status.style.color = this.userControlOnlyEnabled ? '#ffaa00' : '#888';\n            status.style.marginLeft = '0'; // Remove margin since using <br>\n        }\n    }\n    \n    /**\n     * Set reward function type from dropdown\n     */\n    setRewardFunction(rewardType) {\n        if (!this.robot) {\n            console.warn('Robot not initialized');\n            return;\n        }\n        \n        this.robot.setRewardType(rewardType);\n        \n        // Show/hide offset range slider based on reward type\n        const offsetRangeContainer = document.getElementById('offset-range-container');\n        if (offsetRangeContainer) {\n            offsetRangeContainer.style.display = rewardType === 'offset-adaptive' ? 'block' : 'none';\n        }\n        \n        console.log(`Reward function changed to: ${rewardType}`);\n    }\n    \n    \n    /**\n     * Reset robot position for manual control\n     */\n    resetRobotPosition() {\n        if (this.robot) {\n            let resetAngle = 0; // Default: perfectly balanced\n            \n            // In free run mode, use exact angle from slider\n            if (this.demoMode === 'freerun' && Math.abs(this.resetAngleDegrees) > 0) {\n                const angleDegrees = this.resetAngleDegrees || 0.0;\n                resetAngle = angleDegrees * Math.PI / 180; // Use exact angle from slider\n                console.log(`Reset with angle: ${(resetAngle * 180 / Math.PI).toFixed(2)}° (set to ${angleDegrees.toFixed(1)}°)`);\n            }\n            \n            this.robot.reset({\n                angle: resetAngle,\n                angularVelocity: 0,\n                position: 0,\n                velocity: 0\n            });\n            console.log('Robot position reset');\n        }\n    }\n    \n    /**\n     * Model Management Methods\n     */\n    \n    saveModelToLocalStorage() {\n        if (!this.qlearning || !this.qlearning.isInitialized) {\n            alert('No trained model to save. Please train the model first.');\n            return;\n        }\n        \n        // Generate model name with timestamp\n        const now = new Date();\n        const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, -5);\n        const modelName = `TwoWheelBot_DQN_${timestamp}`;\n        \n        // Get model data\n        const modelData = this.qlearning.save();\n        \n        // Add metadata including timestep configuration\n        const saveData = {\n            name: modelName,\n            timestamp: now.toISOString(),\n            type: 'DQN',\n            architecture: this.qlearning.getStats(),\n            timestepConfig: {\n                historyTimesteps: this.robot ? this.robot.historyTimesteps : 1,\n                inputSize: this.qlearning.qNetwork ? this.qlearning.qNetwork.getArchitecture().inputSize : 2\n            },\n            episodesTrained: this.episodeCount,\n            bestScore: this.bestScore,\n            trainingCompleted: this.qlearning.trainingCompleted,\n            consecutiveMaxEpisodes: this.qlearning.consecutiveMaxEpisodes,\n            modelData: modelData\n        };\n        \n        // Save to localStorage\n        try {\n            localStorage.setItem(`model_${modelName}`, JSON.stringify(saveData));\n            \n            // Save model name to list of saved models\n            let savedModels = JSON.parse(localStorage.getItem('savedModelsList') || '[]');\n            if (!savedModels.includes(modelName)) {\n                savedModels.push(modelName);\n                localStorage.setItem('savedModelsList', JSON.stringify(savedModels));\n            }\n            \n            // Update UI and clear unsaved flag\n            this.currentModelName = modelName;\n            this.modelHasUnsavedChanges = false;\n            this.updateModelDisplay(modelName, saveData);\n            \n            // Refresh the model list to show the new/updated model\n            this.refreshModelList();\n            \n            alert(`Model saved successfully as:\\n${modelName}`);\n            console.log('Model saved:', modelName);\n        } catch (error) {\n            alert('Failed to save model: ' + error.message);\n            console.error('Save model error:', error);\n        }\n    }\n    \n    refreshModelList() {\n        // Get list of saved models\n        const savedModels = JSON.parse(localStorage.getItem('savedModelsList') || '[]');\n        const listContainer = document.getElementById('saved-models-list');\n        const noModelsMsg = document.getElementById('no-saved-models');\n        \n        if (!listContainer || !noModelsMsg) return;\n        \n        // Clear existing list\n        listContainer.innerHTML = '';\n        \n        if (savedModels.length === 0) {\n            noModelsMsg.style.display = 'block';\n            return;\n        }\n        \n        noModelsMsg.style.display = 'none';\n        \n        // Create list items for each model\n        savedModels.forEach(modelName => {\n            try {\n                const saveData = JSON.parse(localStorage.getItem(`model_${modelName}`));\n                if (!saveData) return;\n                \n                const modelItem = this.createModelListItem(modelName, saveData);\n                listContainer.appendChild(modelItem);\n            } catch (error) {\n                console.error(`Error loading model ${modelName}:`, error);\n            }\n        });\n    }\n    \n    createModelListItem(modelName, saveData) {\n        const isCurrent = this.currentModelName === modelName;\n        \n        // Create model item container\n        const modelItem = document.createElement('div');\n        modelItem.className = `model-item ${isCurrent ? 'current' : ''}`;\n        modelItem.id = `model-item-${modelName}`;\n        \n        // Create header with name and actions\n        const header = document.createElement('div');\n        header.className = 'model-item-header';\n        \n        const nameDiv = document.createElement('div');\n        nameDiv.className = 'model-item-name';\n        nameDiv.innerHTML = modelName;\n        if (isCurrent) {\n            nameDiv.innerHTML += '<span class=\"current-badge\">LOADED</span>';\n        }\n        \n        const actions = document.createElement('div');\n        actions.className = 'model-item-actions';\n        \n        if (isCurrent) {\n            // Unload button for current model\n            const unloadBtn = document.createElement('button');\n            unloadBtn.textContent = 'Unload';\n            unloadBtn.onclick = () => this.unloadModel();\n            actions.appendChild(unloadBtn);\n        } else {\n            // Load button for other models\n            const loadBtn = document.createElement('button');\n            loadBtn.textContent = 'Load';\n            loadBtn.className = 'primary';\n            loadBtn.onclick = () => this.loadModelByName(modelName);\n            actions.appendChild(loadBtn);\n        }\n        \n        // Delete button for all models\n        const deleteBtn = document.createElement('button');\n        deleteBtn.textContent = 'Delete';\n        deleteBtn.className = 'danger';\n        deleteBtn.onclick = () => this.deleteModel(modelName);\n        actions.appendChild(deleteBtn);\n        \n        header.appendChild(nameDiv);\n        header.appendChild(actions);\n        \n        // Create details section\n        const details = document.createElement('div');\n        details.className = 'model-item-details';\n        \n        // Extract model info\n        const architecture = saveData.modelData?.qNetworkWeights?.architecture;\n        const episodes = saveData.episodesTrained || 0;\n        const bestScore = saveData.bestScore || 0;\n        const timestamp = saveData.timestamp ? new Date(saveData.timestamp).toLocaleString() : 'Unknown';\n        const completed = saveData.trainingCompleted ? 'Yes' : 'No';\n        \n        details.innerHTML = `\n            <div class=\"model-item-detail\"><strong>Architecture:</strong> ${architecture ? `${architecture.inputSize}-${architecture.hiddenSize}-${architecture.outputSize}` : 'Unknown'}</div>\n            <div class=\"model-item-detail\"><strong>Episodes:</strong> ${episodes} | <strong>Best Score:</strong> ${bestScore.toFixed(0)}</div>\n            <div class=\"model-item-detail\"><strong>Training Complete:</strong> ${completed}</div>\n            <div class=\"model-item-detail\"><strong>Saved:</strong> ${timestamp}</div>\n        `;\n        \n        modelItem.appendChild(header);\n        modelItem.appendChild(details);\n        \n        return modelItem;\n    }\n    \n    async loadModelByName(modelName) {\n        try {\n            const saveData = JSON.parse(localStorage.getItem(`model_${modelName}`));\n            \n            if (!saveData || !saveData.modelData) {\n                alert('Model data is corrupted or missing.');\n                return;\n            }\n            \n            // Load model into Q-learning\n            await this.loadModel(saveData);\n            \n            // Refresh the model list to update UI\n            this.refreshModelList();\n            \n            alert(`Model loaded successfully:\\n${modelName}`);\n            console.log('Model loaded:', modelName);\n        } catch (error) {\n            alert('Failed to load model: ' + error.message);\n            console.error('Load model error:', error);\n        }\n    }\n    \n    unloadModel() {\n        if (confirm('Are you sure you want to unload the current model?\\nAny unsaved changes will be lost.')) {\n            // Reset Q-learning\n            if (this.qlearning) {\n                this.qlearning.reset();\n            }\n            \n            // Reset state\n            this.currentModelName = 'No model loaded';\n            this.modelHasUnsavedChanges = false;\n            this.episodeCount = 0;\n            this.bestScore = 0;\n            \n            // Update display\n            this.updateModelDisplay('No model loaded', null);\n            this.refreshModelList();\n            \n            console.log('Model unloaded');\n        }\n    }\n    \n    deleteModel(modelName) {\n        const isCurrent = this.currentModelName === modelName;\n        const confirmMsg = isCurrent ? \n            `Are you sure you want to delete the currently loaded model \"${modelName}\"?\\nThis action cannot be undone.` :\n            `Are you sure you want to delete \"${modelName}\"?\\nThis action cannot be undone.`;\n        \n        if (confirm(confirmMsg)) {\n            try {\n                // Remove from localStorage\n                localStorage.removeItem(`model_${modelName}`);\n                \n                // Update saved models list\n                let savedModels = JSON.parse(localStorage.getItem('savedModelsList') || '[]');\n                savedModels = savedModels.filter(name => name !== modelName);\n                localStorage.setItem('savedModelsList', JSON.stringify(savedModels));\n                \n                // If deleting current model, unload it\n                if (isCurrent) {\n                    this.currentModelName = 'No model loaded';\n                    this.modelHasUnsavedChanges = false;\n                    this.updateModelDisplay('No model loaded', null);\n                }\n                \n                // Refresh the model list\n                this.refreshModelList();\n                \n                console.log(`Model deleted: ${modelName}`);\n                alert(`Model \"${modelName}\" has been deleted.`);\n            } catch (error) {\n                alert('Failed to delete model: ' + error.message);\n                console.error('Delete model error:', error);\n            }\n        }\n    }\n    \n    async loadModel(saveData) {\n        // Extract architecture from saved model\n        const savedArchitecture = saveData.modelData?.qNetworkWeights?.architecture;\n        if (!savedArchitecture) {\n            throw new Error('Invalid model data: missing architecture information');\n        }\n        \n        // Check if current Q-learning exists and has compatible architecture\n        let needsReinit = false;\n        if (this.qlearning && this.qlearning.isInitialized) {\n            const currentArch = this.qlearning.qNetwork.getArchitecture();\n            \n            if (currentArch.inputSize !== savedArchitecture.inputSize ||\n                currentArch.hiddenSize !== savedArchitecture.hiddenSize ||\n                currentArch.outputSize !== savedArchitecture.outputSize) {\n                \n                console.log(`Model architecture mismatch:`);\n                console.log(`  Current: ${currentArch.inputSize}-${currentArch.hiddenSize}-${currentArch.outputSize}`);\n                console.log(`  Loading: ${savedArchitecture.inputSize}-${savedArchitecture.hiddenSize}-${savedArchitecture.outputSize}`);\n                \n                needsReinit = true;\n            }\n        }\n        \n        // Handle timestep configuration if available\n        if (saveData.timestepConfig) {\n            const savedTimesteps = saveData.timestepConfig.historyTimesteps || 1;\n            \n            // Update robot timestep configuration\n            if (this.robot) {\n                this.robot.setHistoryTimesteps(savedTimesteps);\n                console.log(`Restored history timesteps: ${savedTimesteps}`);\n            }\n            \n            // Update UI slider\n            const historyTimestepsSlider = document.getElementById('history-timesteps');\n            const historyTimestepsValue = document.getElementById('history-timesteps-value');\n            if (historyTimestepsSlider) {\n                historyTimestepsSlider.value = savedTimesteps;\n                historyTimestepsValue.textContent = savedTimesteps;\n            }\n        }\n        \n        // Initialize Q-learning if not exists or architecture mismatch\n        if (!this.qlearning || needsReinit) {\n            // Update UI controls to match loaded model architecture\n            if (this.uiControls) {\n                this.uiControls.setParameter('hiddenNeurons', savedArchitecture.hiddenSize);\n            }\n            \n            await this.initializeQLearning({\n                hiddenSize: savedArchitecture.hiddenSize\n            });\n        }\n        \n        // Load the model data (Q-learning.load now handles architecture validation internally)\n        await this.qlearning.load(saveData.modelData);\n        \n        // Restore training state\n        this.episodeCount = saveData.episodesTrained || 0;\n        this.bestScore = saveData.bestScore || 0;\n        \n        // Set current model name and clear unsaved flag\n        this.currentModelName = saveData.name;\n        this.modelHasUnsavedChanges = false;\n        \n        // Update UI to reflect loaded model architecture\n        this.updateModelDisplay(saveData.name, saveData);\n        \n        console.log(`Model loaded: ${saveData.name} with architecture ${savedArchitecture.inputSize}-${savedArchitecture.hiddenSize}-${savedArchitecture.outputSize}`);\n    }\n    \n    exportModelToCpp() {\n        if (!this.qlearning || !this.qlearning.isInitialized) {\n            alert('No trained model to export. Please train the model first.');\n            return;\n        }\n        \n        // Generate filename with timestamp\n        const now = new Date();\n        const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, -5);\n        const filename = `two_wheel_bot_dqn_${timestamp}.cpp`;\n        \n        // Get model weights\n        const weights = this.qlearning.qNetwork.getWeights();\n        const architecture = this.qlearning.qNetwork.getArchitecture();\n        \n        // Generate C++ code\n        let cppCode = this.generateCppCode(weights, architecture, timestamp);\n        \n        // Create download\n        const blob = new Blob([cppCode], { type: 'text/plain' });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n        \n        alert(`Model exported as C++ file:\\n${filename}`);\n        console.log('Model exported:', filename);\n    }\n    \n    importModelFromCpp() {\n        const fileInput = document.getElementById('cpp-file-input');\n        \n        // Create new file input handler\n        const handleFileSelect = (event) => {\n            const file = event.target.files[0];\n            if (!file) return;\n            \n            const reader = new FileReader();\n            reader.onload = async (e) => {\n                try {\n                    const cppContent = e.target.result;\n                    console.log('Parsing C++ file:', file.name);\n                    const importedModel = this.parseCppModel(cppContent, file.name);\n                    console.log('Parsed model:', importedModel);\n                    \n                    await this.loadImportedModel(importedModel);\n                    \n                    // Verify it was saved to localStorage\n                    const savedModels = JSON.parse(localStorage.getItem('savedModelsList') || '[]');\n                    console.log('Updated saved models list:', savedModels);\n                    \n                    alert(`Model imported successfully from:\\n${file.name}\\n\\nModel name: ${importedModel.name}`);\n                    console.log('Model imported successfully:', file.name);\n                } catch (error) {\n                    alert('Failed to import model: ' + error.message);\n                    console.error('Import error:', error);\n                }\n            };\n            \n            reader.readAsText(file);\n            \n            // Reset file input\n            fileInput.value = '';\n            fileInput.removeEventListener('change', handleFileSelect);\n        };\n        \n        // Add event listener and trigger file dialog\n        fileInput.addEventListener('change', handleFileSelect);\n        fileInput.click();\n    }\n    \n    parseCppModel(cppContent, filename) {\n        // Extract architecture information\n        const inputSizeMatch = cppContent.match(/static const int INPUT_SIZE = (\\d+);/);\n        const hiddenSizeMatch = cppContent.match(/static const int HIDDEN_SIZE = (\\d+);/);\n        const outputSizeMatch = cppContent.match(/static const int OUTPUT_SIZE = (\\d+);/);\n        \n        if (!inputSizeMatch || !hiddenSizeMatch || !outputSizeMatch) {\n            throw new Error('Could not extract network architecture from C++ file');\n        }\n        \n        const inputSize = parseInt(inputSizeMatch[1]);\n        const hiddenSize = parseInt(hiddenSizeMatch[1]);\n        const outputSize = parseInt(outputSizeMatch[1]);\n        \n        // Extract weights arrays\n        const weightsInputHidden = this.extractWeightsArray(cppContent, 'weightsInputHidden');\n        const biasHidden = this.extractWeightsArray(cppContent, 'biasHidden');\n        const weightsHiddenOutput = this.extractWeightsArray(cppContent, 'weightsHiddenOutput');\n        const biasOutput = this.extractWeightsArray(cppContent, 'biasOutput');\n        \n        // Validate dimensions\n        if (weightsInputHidden.length !== inputSize * hiddenSize) {\n            throw new Error(`Expected ${inputSize * hiddenSize} input-to-hidden weights, got ${weightsInputHidden.length}`);\n        }\n        if (biasHidden.length !== hiddenSize) {\n            throw new Error(`Expected ${hiddenSize} hidden biases, got ${biasHidden.length}`);\n        }\n        if (weightsHiddenOutput.length !== hiddenSize * outputSize) {\n            throw new Error(`Expected ${hiddenSize * outputSize} hidden-to-output weights, got ${weightsHiddenOutput.length}`);\n        }\n        if (biasOutput.length !== outputSize) {\n            throw new Error(`Expected ${outputSize} output biases, got ${biasOutput.length}`);\n        }\n        \n        // Extract timestamp from filename or comment\n        const timestampMatch = filename.match(/(\\d{4}-\\d{2}-\\d{2}T\\d{2}-\\d{2}-\\d{2})/) || \n                              cppContent.match(/Generated: (\\d{4}-\\d{2}-\\d{2}T\\d{2}-\\d{2}-\\d{2})/);\n        const timestamp = timestampMatch ? timestampMatch[1] : new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);\n        \n        // Calculate parameter count\n        const parameterCount = weightsInputHidden.length + biasHidden.length + \n                              weightsHiddenOutput.length + biasOutput.length;\n        \n        return {\n            name: `Imported_DQN_${timestamp}`,\n            architecture: { inputSize, hiddenSize, outputSize },\n            weights: {\n                architecture: {\n                    inputSize: inputSize,\n                    hiddenSize: hiddenSize,\n                    outputSize: outputSize,\n                    parameterCount: parameterCount\n                },\n                weightsInputHidden: Array.from(weightsInputHidden),\n                biasHidden: Array.from(biasHidden),\n                weightsHiddenOutput: Array.from(weightsHiddenOutput),\n                biasOutput: Array.from(biasOutput),\n                initMethod: 'imported'\n            },\n            filename: filename,\n            importDate: new Date().toISOString()\n        };\n    }\n    \n    extractWeightsArray(cppContent, arrayName) {\n        // Find the array declaration\n        const arrayPattern = new RegExp(`const float ${arrayName}\\\\[.*?\\\\] = \\\\{([^}]+)\\\\};`, 's');\n        const match = cppContent.match(arrayPattern);\n        \n        if (!match) {\n            throw new Error(`Could not find ${arrayName} array in C++ file`);\n        }\n        \n        // Extract values between braces\n        const arrayContent = match[1];\n        \n        // Parse individual values, handling potential line breaks and formatting\n        const values = arrayContent\n            .split(',')\n            .map(s => s.trim())\n            .filter(s => s.length > 0)\n            .map(s => {\n                // Remove 'f' suffix if present\n                const cleanValue = s.replace(/f$/, '');\n                const value = parseFloat(cleanValue);\n                if (isNaN(value)) {\n                    throw new Error(`Invalid weight value: ${s}`);\n                }\n                return value;\n            });\n        \n        return values;\n    }\n    \n    async loadImportedModel(importedModel) {\n        // Initialize Q-learning if not already done\n        if (!this.qlearning) {\n            await this.initializeQLearning();\n        }\n        \n        // Verify architecture compatibility\n        const currentArch = this.qlearning.qNetwork.getArchitecture();\n        const importedArch = importedModel.architecture;\n        \n        if (currentArch.inputSize !== importedArch.inputSize ||\n            currentArch.hiddenSize !== importedArch.hiddenSize ||\n            currentArch.outputSize !== importedArch.outputSize) {\n            \n            const recreate = confirm(\n                `Architecture mismatch:\\n` +\n                `Current: ${currentArch.inputSize}-${currentArch.hiddenSize}-${currentArch.outputSize}\\n` +\n                `Imported: ${importedArch.inputSize}-${importedArch.hiddenSize}-${importedArch.outputSize}\\n\\n` +\n                `Recreate network with imported architecture?`\n            );\n            \n            if (!recreate) {\n                throw new Error('Import cancelled - architecture mismatch');\n            }\n            \n            // Recreate Q-learning with imported architecture\n            await this.initializeQLearning({\n                hiddenSize: importedArch.hiddenSize\n            });\n        }\n        \n        // Load weights into network\n        this.qlearning.qNetwork.setWeights(importedModel.weights);\n        \n        // Update target network to match\n        this.qlearning.targetNetwork = this.qlearning.qNetwork.clone();\n        \n        // Reset training state for imported model\n        this.episodeCount = 0;\n        this.trainingStep = 0;\n        this.bestScore = 0;\n        \n        // Set model name and clear unsaved flag\n        this.currentModelName = importedModel.name;\n        this.modelHasUnsavedChanges = false;\n        \n        // Create complete model data for saving\n        const modelData = {\n            hyperparams: this.qlearning.hyperparams,\n            qNetworkWeights: importedModel.weights,  // Use the imported weights with architecture\n            targetNetworkWeights: importedModel.weights,  // Same weights for target network\n            episode: 0,\n            stepCount: 0,\n            metrics: { episodes: 0, totalSteps: 0, averageReward: 0, bestReward: 0 },\n            actions: this.qlearning.actions\n        };\n        \n        // Create save data compatible with localStorage format\n        const saveData = {\n            name: importedModel.name,\n            timestamp: importedModel.importDate,\n            type: 'Imported DQN',\n            architecture: importedArch,\n            episodesTrained: 0,\n            bestScore: 0,\n            trainingCompleted: false,\n            consecutiveMaxEpisodes: 0,\n            modelData: modelData,\n            importedFrom: importedModel.filename\n        };\n        \n        // Save imported model to localStorage so it appears in Load Model list\n        try {\n            localStorage.setItem(`model_${importedModel.name}`, JSON.stringify(saveData));\n            \n            // Add to saved models list\n            let savedModels = JSON.parse(localStorage.getItem('savedModelsList') || '[]');\n            if (!savedModels.includes(importedModel.name)) {\n                savedModels.push(importedModel.name);\n                localStorage.setItem('savedModelsList', JSON.stringify(savedModels));\n            }\n            console.log('Imported model saved to localStorage:', importedModel.name);\n        } catch (error) {\n            console.warn('Could not save imported model to localStorage:', error);\n        }\n        \n        // Update UI with imported model info (use the actual imported model as current)\n        this.updateModelDisplay(importedModel.name, saveData);\n        \n        // Refresh the model list to show the imported model\n        this.refreshModelList();\n        \n        console.log('Imported model loaded:', importedModel.name);\n    }\n    \n    generateCppCode(weights, architecture, timestamp) {\n        const { inputSize, hiddenSize, outputSize } = architecture;\n        \n        return `/**\n * Two-Wheel Balancing Robot DQN Model\n * Generated: ${timestamp}\n * Architecture: ${inputSize}-${hiddenSize}-${outputSize}\n * \n * This file contains the trained neural network weights for deployment\n * on embedded systems (Arduino, ESP32, STM32, etc.)\n */\n\n#include <math.h>\n\nclass TwoWheelBotDQN {\nprivate:\n    static const int INPUT_SIZE = ${inputSize};\n    static const int HIDDEN_SIZE = ${hiddenSize};\n    static const int OUTPUT_SIZE = ${outputSize};\n    \n    // Network weights (stored in program memory to save RAM)\n    const float weightsInputHidden[INPUT_SIZE * HIDDEN_SIZE] = {\n        ${this.formatWeights(weights.weightsInputHidden, 8)}\n    };\n    \n    const float biasHidden[HIDDEN_SIZE] = {\n        ${this.formatWeights(weights.biasHidden, 8)}\n    };\n    \n    const float weightsHiddenOutput[HIDDEN_SIZE * OUTPUT_SIZE] = {\n        ${this.formatWeights(weights.weightsHiddenOutput, 8)}\n    };\n    \n    const float biasOutput[OUTPUT_SIZE] = {\n        ${this.formatWeights(weights.biasOutput, 8)}\n    };\n    \n    // Activation function (ReLU)\n    float relu(float x) {\n        return x > 0 ? x : 0;\n    }\n    \npublic:\n    /**\n     * Get action from current state\n     * @param angle Robot angle in radians\n     * @param angularVelocity Angular velocity in rad/s\n     * @return Action index (0=left, 1=brake, 2=right)\n     */\n    int getAction(float angle, float angularVelocity) {\n        // Normalize inputs\n        float input[INPUT_SIZE];\n        input[0] = constrain(angle / (M_PI / 3), -1.0, 1.0);\n        input[1] = constrain(angularVelocity / 10.0, -1.0, 1.0);\n        \n        // Hidden layer computation\n        float hidden[HIDDEN_SIZE];\n        for (int h = 0; h < HIDDEN_SIZE; h++) {\n            hidden[h] = biasHidden[h];\n            for (int i = 0; i < INPUT_SIZE; i++) {\n                hidden[h] += input[i] * weightsInputHidden[i * HIDDEN_SIZE + h];\n            }\n            hidden[h] = relu(hidden[h]);\n        }\n        \n        // Output layer computation\n        float output[OUTPUT_SIZE];\n        float maxValue = -1e10;\n        int bestAction = 0;\n        \n        for (int o = 0; o < OUTPUT_SIZE; o++) {\n            output[o] = biasOutput[o];\n            for (int h = 0; h < HIDDEN_SIZE; h++) {\n                output[o] += hidden[h] * weightsHiddenOutput[h * OUTPUT_SIZE + o];\n            }\n            \n            // Track best action\n            if (output[o] > maxValue) {\n                maxValue = output[o];\n                bestAction = o;\n            }\n        }\n        \n        return bestAction;\n    }\n    \n    /**\n     * Get motor torque for action\n     * @param action Action index\n     * @return Motor torque (-1.0 to 1.0)\n     */\n    float getMotorTorque(int action) {\n        const float actions[3] = {-1.0, 0.0, 1.0};\n        return actions[action];\n    }\n    \nprivate:\n    float constrain(float value, float min, float max) {\n        if (value < min) return min;\n        if (value > max) return max;\n        return value;\n    }\n};\n\n// Usage example:\n// TwoWheelBotDQN bot;\n// int action = bot.getAction(angle, angularVelocity);\n// float torque = bot.getMotorTorque(action);\n`;\n    }\n    \n    formatWeights(weights, itemsPerLine) {\n        const formatted = [];\n        for (let i = 0; i < weights.length; i += itemsPerLine) {\n            const line = weights.slice(i, i + itemsPerLine)\n                .map(w => w.toFixed(6) + 'f')\n                .join(', ');\n            formatted.push('        ' + line);\n        }\n        return formatted.join(',\\n');\n    }\n    \n    resetModelParameters() {\n        if (!this.qlearning || !this.qlearning.isInitialized) {\n            alert('No model to reset. Please initialize training first.');\n            return;\n        }\n        \n        if (!confirm('Are you sure you want to reset all model parameters? This will lose all training progress.')) {\n            return;\n        }\n        \n        // Reset Q-learning\n        this.qlearning.reset();\n        \n        // Reset training state\n        this.episodeCount = 0;\n        this.trainingStep = 0;\n        this.bestScore = 0;\n        \n        // Reset model name\n        this.currentModelName = 'No model loaded';\n        this.modelHasUnsavedChanges = false;\n        \n        // Update UI\n        this.updateModelDisplay('Untrained Model', null);\n        \n        alert('Model parameters have been reset.');\n        console.log('Model parameters reset');\n    }\n    \n    updateModelDisplay(modelName, saveData) {\n        const nameElement = document.getElementById('current-model-name');\n        const statsElement = document.getElementById('model-stats');\n        \n        if (nameElement) {\n            nameElement.textContent = modelName || 'No model loaded';\n        }\n        \n        if (statsElement && saveData) {\n            const stats = [];\n            if (saveData.episodesTrained) {\n                stats.push(`Episodes: ${saveData.episodesTrained}`);\n            }\n            if (saveData.bestScore) {\n                stats.push(`Best Score: ${saveData.bestScore.toFixed(1)}`);\n            }\n            if (saveData.trainingCompleted) {\n                stats.push('✓ Training Completed');\n            }\n            if (saveData.timestamp) {\n                const date = new Date(saveData.timestamp);\n                stats.push(`Saved: ${date.toLocaleDateString()} ${date.toLocaleTimeString()}`);\n            }\n            statsElement.textContent = stats.join(' | ');\n        } else if (statsElement) {\n            statsElement.textContent = '';\n        }\n    }\n    \n    updateTrainingModelDisplay() {\n        const nameElement = document.getElementById('current-model-name');\n        const statsElement = document.getElementById('model-stats');\n        \n        if (nameElement) {\n            let displayName = this.currentModelName;\n            if (this.modelHasUnsavedChanges && !displayName.includes('(unsaved)')) {\n                displayName += ' (unsaved)';\n            }\n            nameElement.textContent = displayName;\n        }\n        \n        if (statsElement) {\n            const stats = [];\n            stats.push(`Episodes: ${this.episodeCount}`);\n            if (this.bestScore && this.bestScore > -Infinity) {\n                stats.push(`Best: ${this.bestScore.toFixed(1)}`);\n            }\n            if (this.qlearning) {\n                if (this.qlearning.trainingCompleted) {\n                    stats.push('✓ Completed');\n                } else if (this.qlearning.consecutiveMaxEpisodes > 0) {\n                    stats.push(`Progress: ${this.qlearning.consecutiveMaxEpisodes}/20`);\n                }\n                if (this.isTraining && !this.isPaused) {\n                    stats.push('🔴 Training');\n                } else if (this.isPaused) {\n                    stats.push('⏸️ Paused');\n                }\n            }\n            statsElement.textContent = stats.join(' | ');\n        }\n    }\n}\n\n// Application initialization\nlet app = null;\n\ndocument.addEventListener('DOMContentLoaded', async () => {\n    try {\n        app = new TwoWheelBotRL();\n        await app.initialize();\n        \n        // Setup custom sliders after app initialization\n        setupCustomSliders();\n    } catch (error) {\n        console.error('Failed to start application:', error);\n    }\n});\n\n// Custom slider setup function\nfunction setupCustomSliders() {\n    console.log('Setting up custom sliders...');\n    \n    // Offset angle error slider\n    const offsetSlider = document.getElementById('offset-angle-error');\n    const offsetValue = document.getElementById('offset-angle-error-value');\n    \n    if (offsetSlider && offsetValue) {\n        console.log('Found offset angle slider');\n        offsetSlider.addEventListener('input', (e) => {\n            const degrees = parseFloat(e.target.value);\n            const radians = degrees * Math.PI / 180;\n            offsetValue.textContent = `${degrees.toFixed(1)}°`;\n            \n            if (app && app.robot) {\n                app.robot.angleOffset = radians;\n                console.log(`Offset angle set to: ${degrees.toFixed(1)}° (${radians.toFixed(3)} rad)`);\n            }\n        });\n    } else {\n        console.warn('Offset angle slider or value element not found');\n    }\n    \n    // Reset angle slider\n    const resetSlider = document.getElementById('reset-angle');\n    const resetValue = document.getElementById('reset-angle-value');\n    \n    if (resetSlider && resetValue) {\n        console.log('Found reset angle slider');\n        resetSlider.addEventListener('input', (e) => {\n            const degrees = parseFloat(e.target.value);\n            resetValue.textContent = `${degrees.toFixed(1)}°`;\n            \n            if (app) {\n                app.resetAngleDegrees = degrees;\n                console.log(`Reset angle set to: ${degrees.toFixed(1)}° (randomly +/-)`);\n            }\n        });\n    } else {\n        console.warn('Reset angle slider or value element not found');\n    }\n    \n    // Offset range slider for training\n    const offsetRangeSlider = document.getElementById('offset-range');\n    const offsetRangeValue = document.getElementById('offset-range-value');\n    \n    if (offsetRangeSlider && offsetRangeValue) {\n        console.log('Found offset range slider');\n        offsetRangeSlider.addEventListener('input', (e) => {\n            const degrees = parseFloat(e.target.value);\n            offsetRangeValue.textContent = `${degrees.toFixed(1)}°`;\n            \n            if (app) {\n                app.maxOffsetRangeDegrees = degrees;\n                // Also update robot's training offset range\n                if (app.robot) {\n                    app.robot.setTrainingOffsetRange(degrees);\n                }\n                console.log(`Max offset range set to: ±${degrees.toFixed(1)}° for training`);\n            }\n        });\n    } else {\n        console.warn('Offset range slider or value element not found');\n    }\n}\n\n// Handle page unload\nwindow.addEventListener('beforeunload', () => {\n    if (app) {\n        app.destroy();\n    }\n});\n\n// Export for potential external access\nwindow.TwoWheelBotRL = TwoWheelBotRL;"],"names":["globalThis","GPUBufferUsage","MAP_READ","MAP_WRITE","COPY_SRC","COPY_DST","INDEX","VERTEX","UNIFORM","STORAGE","INDIRECT","QUERY_RESOLVE","GPUMapMode","READ","WRITE","GPUShaderStage","FRAGMENT","COMPUTE","navigator","gpu","CoordinateTransform","__name","this","constructor","canvasWidth","canvasHeight","physicsScale","centerX","centerY","zoomLevel","minX","maxX","minY","maxY","physicsToScreen","x","y","screenToPhysics","screenX","screenY","resize","scaleLength","length","getPhysicsBounds","PerformanceMonitor","frameCount","lastTime","performance","now","fps","frameTime","avgFrameTime","maxFrameTime","minFrameTime","frameTimes","historySize","update","currentTime","push","shift","reduce","sum","t","Math","max","min","getMetrics","round","toFixed","isPerformanceGood","Renderer","canvas","config","ctx","getContext","backgroundColor","gridColor","robotColor","wheelColor","torqueColor","textColor","showGrid","showDebugInfo","showPerformance","targetFPS","transform","width","height","isRendering","animationId","lastRenderTime","frameInterval","robotState","robotConfig","motorTorque","trainingMetrics","episode","step","reward","totalReward","bestReward","epsilon","isTraining","trainingMode","showRobotInfo","showTrainingInfo","showPerformanceInfo","start","renderLoop","deltaTime","render","requestAnimationFrame","stop","cancelAnimationFrame","updateRobot","state","updateTraining","metrics","clear","drawEnvironment","drawRobot","drawUI","fillStyle","fillRect","drawGrid","drawGround","drawAxes","strokeStyle","lineWidth","globalAlpha","gridSpacing","beginPath","moveTo","lineTo","stroke","groundY","lineCap","endX","patternHeight","i","tickX","wheelCircumference","PI","wheelRadius","circumferencePixels","robotPos","position","offset","contactX","contactY","angle","centerOfMassHeight","wheelPos","bodyTopPos","sin","cos","drawRobotBody","drawWheels","drawTorqueIndicators","drawAngleIndicator","topPos","bodyWidth","bodyHeight","sqrt","pow","atan2","save","translate","rotate","strokeRect","arc","fill","restore","physicsWheelRadius","spokeAngle","wheelAngle","innerRadius","outerRadius","markerAngle","markerRadius","oppositeMarkerAngle","abs","maxTorque","motorStrength","torqueRatio","indicatorLength","intensity","arrowY","arrowStartX","arrowEndX","headSize","drawRobotInfo","drawTrainingInfo","drawPerformanceInfo","angularVelocity","velocity","font","textAlign","infoX","infoY","fillText","lineHeight","perfMetrics","fpsColor","toggleUI","element","updateConfig","newConfig","getStats","canvasSize","hasRobotState","zoomIn","zoomOut","resetZoom","getZoomLevel","destroy","createRenderer","BaseChart","lineColor","axisColor","padding","maxDataPoints","title","yLabel","xLabel","data","autoScale","addData","value","dataPoint","map","d","range","dataToCanvas","chartWidth","chartHeight","canvasX","xRange","yRange","canvasY","drawBackground","drawLabels","drawLine","lineJoin","firstPoint","point","setYRange","count","avg","last","values","v","PerformanceCharts","container","chartSpacing","updateInterval","charts","lastUpdate","initializeCharts","innerHTML","style","document","createElement","textContent","head","appendChild","initializeChart","getElementById","addEventListener","clearAllCharts","name","color","rect","getBoundingClientRect","renderAllCharts","Object","forEach","chart","updateRewards","rewards","updateLoss","loss","updateQValue","qValue","qvalue","updateEpsilon","updateMetrics","entries","stats","exportData","importData","chartData","createPerformanceCharts","NetworkArchitecture","description","inputSize","outputSize","layers","activations","maxParameters","memoryConstraint","targetFrequency","deployment","getParameterCount","totalParams","prevSize","layerSize","validate","errors","size","paramCount","valid","parameterCount","clone","NetworkPresets","MICRO","NANO","CLASSIC","ENHANCED","ADVANCED","RESEARCH","MAXIMUM","DQN_STANDARD","CUSTOM","getPreset","toUpperCase","createCustomArchitecture","arch","validation","Error","join","StateHistory","maxTimesteps","history","currentTimesteps","setTimesteps","timesteps","lastState","timestamp","Date","addState","unshift","pop","getNormalizedInputs","maxAngle","inputs","Float32Array","normalizedAngle","normalizedAngularVelocity","getHistory","slice","reset","validHistory","avgAngle","avgAngularVelocity","angleVariance","historyLength","averageAngle","averageAngularVelocity","angleStdDev","RobotState","wheelVelocity","hasFailed","BalancingRobot","mass","_validateParameter","friction","damping","timestep","wheelMass","wheelFriction","motorTorqueRange","rewardType","angleOffset","offsetVariation","offsetChangeRate","trainingOffsetRange","balancePointEstimate","balancePointConfidence","adaptationRate","gravity","momentOfInertia","wheelInertia","currentMotorTorque","previousMotorTorque","historyTimesteps","stateHistory","stepCount","defaultValue","isNaN","initialState","_normalizeAngle","randomOffsetRadians","random","measuredAngle","getMeasuredAngle","initialAngularVelocity","done","scaledTorque","prevState","_updatePhysics","_calculateReward","dt","gravityTorque","dampingTorque","angularAcceleration","motorForce","normalForce","horizontalAcceleration","wheelRotationChange","_updateAngleOffset","uprightReward","torquePenalty","torqueChange","isFinite","angularVelMagnitude","maxStableVel","driftAmount","noise","setTrainingOffsetRange","rangeDegrees","_updateBalancePointEstimate","alpha","getState","setHistoryTimesteps","getConfig","simulationTime","trueAngle","setRewardType","type","getRewardType","isStable","createDefaultRobot","overrides","NeuralNetwork","createNetwork","hiddenSize","options","forward","input","getWeights","setWeights","weights","getArchitecture","validateInput","validateOutput","output","NetworkConfig","XAVIER","HE","RANDOM","calculateParameterCount","validateArchitecture","vectorMatrixMultiply","bias","result","j","xavierInit","limit","heInit","stddev","u1","u2","normal","log","zeroInit","Performance","time","fn","args","benchmark","iterations","totalTime","lastResult","averageTime","CPUBackend","super","weightsInputHidden","biasHidden","weightsHiddenOutput","biasOutput","hiddenActivation","outputActivation","initMethod","isInitialized","_validateVariableArchitecture","_initializeWeights","hiddenLinear","getHiddenActivations","architecture","Array","from","hidden","backend","testInput","getMemoryUsage","totalBytes","breakdown","bytes","totalKB","parameterBytes","parameterKB","cloneInitMethod","resetWeights","originalInitMethod","Hyperparameters","learningRate","gamma","epsilonMin","epsilonDecay","batchSize","targetUpdateFreq","maxEpisodes","maxStepsPerEpisode","convergenceWindow","convergenceThreshold","ReplayBuffer","maxSize","buffer","index","add","action","nextState","experience","stateSize","sample","sampled","indices","Set","idx","floor","has","TrainingMetrics","episodeRewards","episodeLengths","losses","epsilonHistory","startTime","totalSteps","Infinity","converged","convergenceEpisode","addEpisode","getAverageReward","window","recent","r","getAverageLength","l","getTrainingTime","checkConvergence","threshold","getSummary","episodes","avgReward","avgLength","avgLoss","averageReward","averageLength","averageLoss","trainingTime","currentEpsilon","QLearning","hyperparams","replayBuffer","qNetwork","targetNetwork","globalStepCount","lastTargetUpdate","consecutiveMaxEpisodes","trainingCompleted","actions","numActions","initialize","error","selectAction","training","expectedInputSize","qValues","_argmax","train","_updateEpsilon","_trainBatch","initialEpsilon","epsilonStart","epsilonEnd","fraction","batch","totalLoss","outputWeights","w","currentQ","targetQ","nextQValues","maxNextQ","tdError","_updateNetwork","_updateTargetNetwork","_getHiddenActivation","absError","weightIndex","gradient","biasGradient","inputWeights","hiddenBiases","h","reluDerivative","hiddenError","inputWeightIndex","runEpisode","environment","verbose","lossCount","actionIndex","actionValue","steps","runTraining","saveInterval","onEpisodeEnd","ep","earlyStop","evaluate","numEpisodes","oldEpsilon","results","avgSteps","worstReward","averageSteps","getQValue","getAllQValues","qNetworkWeights","targetNetworkWeights","load","modelData","savedArchitecture","currentArch","replayBufferSize","networkParameters","array","maxIndex","maxValue","createDefaultQLearning","ShaderManager","device","shaderModules","Map","computePipelines","bindGroupLayouts","uniformBuffers","storageBuffers","shaderSources","compilationTimes","pipelineCreationTimes","loadShaders","_loadShaderSources","_compileShaderModules","_createComputePipelines","loadPromises","matmul","relu","qlearning","async","path","response","fetch","ok","statusText","source","text","set","_getInlineShaderSource","Promise","all","shaderModule","createShaderModule","label","code","compilationInfo","getCompilationInfo","messages","filter","msg","e","message","compilationTime","_createMatMulPipelines","_createActivationPipelines","_createQLearningPipelines","matmulModule","get","matmulBindGroupLayout","createBindGroupLayout","binding","visibility","pipelineLayout","createPipelineLayout","entryPoints","entryPoint","pipeline","createComputePipeline","layout","compute","module","reluModule","activationBindGroupLayout","qlearningModule","qlearningBindGroupLayout","getPipeline","pipelineName","keys","getBindGroupLayout","layoutName","getPerformanceMetrics","totalCompilationTime","totalPipelineTime","shadersCompiled","pipelinesCreated","fromEntries","availablePipelines","availableLayouts","validateShaders","allShadersCompiled","missingShaders","availableShaders","requiredShaders","shader","allPipelinesCreated","every","BufferUsageType","STORAGE_READ_WRITE","STORAGE_READ_ONLY","STORAGE_WRITE_ONLY","STAGING_UPLOAD","STAGING_DOWNLOAD","BufferManager","isDestroyed","maxBufferSize","maxTotalMemory","alignment","poolEnabled","poolMaxAge","poolMaxSize","asyncTimeout","enableValidation","enableProfiling","buffers","bindGroups","bufferMetadata","bufferPools","poolStats","hits","misses","evictions","totalReused","memoryUsage","totalAllocated","totalActive","totalPooled","bufferCount","pooledCount","performanceMetrics","bufferCreationTimes","memoryTransferTimes","mappingTimes","asyncOperationTimes","errorCount","warningCount","pendingOperations","operationCounter","validationEnabled","errorLog","bufferTypeStats","_setupPoolCleanup","createBuffer","usage","_validateNotDestroyed","allowReuse","persistent","initialData","ArrayBuffer","byteLength","Uint8Array","isView","byteOffset","_validateBufferSize","alignedSize","_alignSize","_getBufferFromPool","_validateMemoryLimit","_updateMemoryUsage","updateBuffer","queue","_trackBufferMetadata","createdAt","accessCount","creationTime","_handleError","useStaging","operationId","_generateOperationId","uint8Data","_validateBufferUpdate","_updateBufferStaging","writeBuffer","_updateBufferAccess","transferTime","delete","readBuffer","timeout","_validateBufferRead","stagingBuffer","commandEncoder","createCommandEncoder","copyBufferToBuffer","commands","finish","submit","mapPromise","mapAsync","timeoutPromise","_","reject","setTimeout","race","mappingStartTime","arrayBuffer","getMappedRange","unmap","mappingTime","_returnBufferToPool","createNetworkBuffers","sizes","_calculateBufferSizes","weightsHidden","weightsOutput","matmulParams","activationParams","stagingInput","stagingOutput","targetQValues","dones","tdErrors","qlearningParams","totalMemory","_formatBytes","ceil","_createBuffer","bufferSizes","totalMemoryUsed","createBindGroups","layouts","createBindGroup","resource","activation","bindGroup","uploadData","bufferName","downloadData","updateUniformBuffer","params","Uint32Array","M","K","N","batch_size","input_size","hidden_size","output_size","learning_rate","clip_grad_norm","getBuffer","getBindGroup","bufferInfo","sizeFormatted","avgCreationTime","a","b","avgTransferTime","totalMemoryFormatted","bindGroupCount","totalCreations","totalTransfers","_formatUsage","flags","parseFloat","WebGPUNeuralNetwork","shaderManager","bufferManager","weightsInitialized","forwardPassTimes","gpuMemoryUsed","maxConcurrentOps","asyncQueue","maxErrors","lastError","_batchBufferCache","_batchBindGroupCache","operationTimeout","activeTimeouts","_createBindGroups","initializeWeights","seed","memory","method","_generateWeights","_generateBias","_seededRandom","xavierStd","heStd","_boxMuller","s","_executeForwardPass","outputBuffer","forwardTime","passEncoder","beginComputePass","timestampWrites","features","querySet","beginningOfPassWriteIndex","endOfPassWriteIndex","hiddenParams","setPipeline","setBindGroup","matmulHidden","dispatchWorkgroups","outputParams","matmulOutput","end","commandBuffer","onSubmittedWorkDone","forwardBatch","batchInput","reuseBuffers","batchKey","batchBuffers","batchBindGroups","batchArchitecture","_createBatchBindGroups","_syncWeightsToBatchBuffers","_executeBatchForwardPassAsync","_executeBatchForwardPass","weightsHiddenBuffer","biasHiddenBuffer","weightsOutputBuffer","biasOutputBuffer","forwardTimes","avgForwardTime","bufferMetrics","bufferPerformance","averageForwardTime","totalForwardPasses","pool","bufferCreation","memoryTransfer","mapping","asyncOperations","getAsyncStatus","efficiency","bufferPoolHitRate","hitRate","memoryUtilization","utilizationPercent","averageBufferCreationTime","averageTransferTime","errorRate","benchmarkAgainstCPU","cpuBackend","warmupIterations","testBatchSizes","includeMemoryAnalysis","includeAccuracyCheck","singleInference","batchProcessing","memoryComparison","accuracyVerification","summary","_benchmarkSingleInference","_benchmarkBatchProcessing","_compareMemoryUsage","_verifyAccuracy","_generateBenchmarkSummary","benchmarkTime","cpuTimes","gpuTimes","gpuRealTimeTimes","forwardRealTime","realTime","skipValidation","cpuStats","_calculatePerformanceStats","gpuStats","gpuRealTimeStats","cpu","gpuRealTime","speedup","standard","median","throughput","realTimeCapable","p95","singleInput","cpuBatchTimes","gpuBatchTimes","timePerSample","batchEfficiency","cpuMemory","gpuMemory","pooledBytes","comparison","memoryRatio","gpuOverhead","bufferPoolSavings","testCases","absolute","relative","totalAbsoluteError","totalRelativeError","cpuOutput","gpuOutput","absoluteErrors","relativeErrors","relError","maxAbsError","maxRelError","maxAbsoluteError","maxRelativeError","averageAbsoluteError","averageRelativeError","allCpuOutputs","flatMap","allGpuOutputs","correlation","_calculateCorrelation","averageErrors","passed","detailedErrors","overallSpeedup","realTimeSpeedup","bestBatchSpeedup","optimalBatchSize","memoryEfficient","numericallyAccurate","productionReady","recommendations","batchResult","parseInt","times","sorted","sort","n","mean","variance","p90","p99","std","cv","meanX","val","meanY","numerator","sumXSq","sumYSq","deltaX","deltaY","isValid","issues","warnings","bufferStatus","totalBuffers","totalActiveFormatted","poolEfficiency","avgBufferCreation","avgMemoryTransfer","isPerformant","shaderValidation","requiredBuffers","executeAsyncOperation","operation","operationName","timeoutMs","_queueOperation","promise","timeoutId","_cleanupOperation","_handleAsyncError","operationData","resolve","_processQueue","setImmediate","errorInfo","toISOString","stack","clearTimeout","waitForOperations","pendingOps","queuedOperations","totalErrors","recentErrors","resetErrorState","_executeRealTimeForwardPass","encoder","pass","WebGPUFeatures","storageBuffer","maxComputeWorkgroupSizeX","maxComputeInvocationsPerWorkgroup","WebGPUDeviceInfo","isAvailable","adapter","capabilities","limits","errorMessage","fallbackReason","hasComputeShaders","adapterInfo","vendor","info","meetsRequirements","WebGPUDeviceManager","deviceInfo","initializationPromise","initWebGPU","_initWebGPUInternal","preferHighPerformance","forceFallback","requestAdapter","powerPreference","deviceDescriptor","_createDeviceDescriptor","requestDevice","event","requiredFeatures","usefulFeatures","feature","requiredLimits","getDeviceInfo","isWebGPUAvailable","getDevice","getPerformanceEstimate","estimatedSpeedup","supportedOperations","recommendedBatchSize","workgroupSize","maxWorkgroupSize","maxBufferSizeMB","WebGPUBackend","deviceManager","gpuNetwork","usingFallback","initializationTime","gpuMemoryUsage","inputSizeOrArchitecture","total","currentArchitecture","forceCPU","webgpuAvailable","performanceEstimate","getBackendInfo","baseMetrics","gpuMetrics","gpuMemoryEstimate","webgpuBuffers","checkWebGPUAvailability","available","reason","SystemCapabilities","coreCount","detectCores","targetCores","maxWorkers","hardwareConcurrency","getWorkerConfig","workerCount","episodesPerWorker","WorkerPool","workerScript","workers","availableWorkers","busyWorkers","taskQueue","initialized","worker","Worker","onmessage","handleWorkerMessage","onerror","postMessage","taskId","workerId","processNextTask","executeParallelEpisodes","tasks","completedTasks","taskCompleteHandler","task","id","callback","processAllTasks","taskItem","originalHandler","terminate","ParallelTrainingManager","qLearning","workerPool","parallelEnabled","totalParallelEpisodes","totalSerialEpisodes","parallelTime","serialTime","speedupFactor","workerURL","createWorkerScript","workerResponse","status","workerCode","workerBlob","Blob","URL","createObjectURL","createFallbackWorkerScript","runEpisodes","runParallelEpisodes","runSerialEpisodes","neuralNetworkWeights","episodeId","maxSteps","explorationEnabled","totalExperiences","experiences","elapsedTime","updateSpeedupStats","serialRate","parallelRate","getPerformanceStats","cleanup","ParallelQLearning","parallelManager","episodeCount","remainingEpisodes","currentBatch","TrainingPerformanceTracker","renderingConfig","alwaysRenderThreshold","skipRenderRatio","currentSkipCount","renderingMode","sampleWindow","episodeTimes","stepTimes","lastEpisodeTime","lastStepTime","totalEpisodes","totalTrainingTime","currentEpisodesPerMinute","currentStepsPerSecond","trainingEfficiency","startEpisode","episodeStartTime","endEpisode","episodeDuration","duration","cleanOldSamples","updateRates","recordStep","cutoff","windowStart","recentEpisodes","episodeTimestamps","timeSpan","apply","recentSteps","totalEpisodeTime","shouldRenderEpisode","trainingSpeed","shouldRenderStep","totalTimeSeconds","episodesPerMinute","stepsPerSecond","averageEpisodeDuration","renderSkipRatio","estimatedMaxEpisodesPerHour","estimatedMaxStepsPerMinute","getDisplayStats","getRenderingModeDisplay","totalTimeMinutes","estimatedMaxPerHour","autoAdjustRendering","currentFPS","logPerformanceSummary","SmartRenderingManager","performanceTracker","targetRenderInterval","frameSkipCount","mode","actualTargetFPS","shouldRenderFrame","forceNextRender","getRenderStats","targetInterval","UIControls","app","parameters","hiddenNeurons","robotMass","robotHeight","networkConfig","preset","customLayers","validationRanges","loadParameters","setupSliderControls","setupKeyboardShortcuts","updateAllDisplays","trainingSpeedSlider","target","setParameter","setTrainingSpeed","button","setSpeedPreset","parallelButton","enableParallelTraining","debugSpeedSlider","debugSpeedValue","setDebugSpeed","setupNetworkConfiguration","learningRateSlider","updateLearningRate","epsilonSlider","gammaSlider","updateGamma","epsilonMinSlider","updateEpsilonMin","epsilonDecaySlider","updateEpsilonDecay","batchSizeSlider","updateBatchSize","targetUpdateFreqSlider","updateTargetUpdateFreq","maxEpisodesSlider","updateMaxEpisodes","maxStepsPerEpisodeSlider","updateMaxStepsPerEpisode","robotMassSlider","updateRobotMass","robotHeightSlider","updateRobotHeight","motorStrengthSlider","updateMotorStrength","wheelFrictionSlider","updateWheelFriction","maxAngleSlider","updateMaxAngle","motorTorqueRangeSlider","updateMotorTorqueRange","historyTimestepsSlider","historyTimestepsValue","robot","initializeQLearning","then","catch","presetSelect","presetDescription","customArchitecture","presetName","display","setupCustomArchitecture","updateArchitectureDisplay","updateNetworkArchitecture","initialPreset","layerCountSlider","layerCountValue","layerCount","updateCustomLayers","layerConfigs","layerDiv","className","slider","querySelector","valueSpan","updateCustomArchitecture","customArch","showArchitectureError","archDisplay","memoryEstimate","layerSizes","toLocaleString","memoryKB","clearArchitectureError","errorDiv","remove","getNetworkArchitecture","tagName","key","toLowerCase","preventDefault","pauseTraining","stopTraining","startTraining","resetEnvironment","switchDemoMode","renderer","userControlEnabled","manualControl","leftPressed","updateManualTorque","classList","rightPressed","resetRobotPosition","paramName","saveParameters","getParameter","toString","localStorage","setItem","JSON","stringify","saved","getItem","loadedParams","parse","speed","parallelModeEnabled","setParallelMode","resetToDefaults","syncParametersFromQLearning","updateParameterDisplays","paramNames","elementId","getElementIdForParameter","valueId","valueElement","formatParameterValue","TwoWheelBotRL","webgpuBackend","uiControls","performanceCharts","systemCapabilities","parallelQLearning","smartRenderingManager","_isTraining","isPaused","trainingStep","bestScore","currentReward","lastQValue","targetPhysicsStepsPerFrame","episodeEnded","resetAngleDegrees","maxOffsetRangeDegrees","debugSpeed","debugLastAction","debugCurrentReward","demoMode","currentModelName","modelHasUnsavedChanges","trainingStartTime","enabled","upPressed","manualTorque","simulationInterval","pdControllerEnabled","userControlOnlyEnabled","currentNetworkArchitecture","lastPhysicsUpdate","physicsUpdateInterval","frameTimeHistory","lastFrameTime","performanceCheckInterval","webgpuStatus","checked","previousState","previousAction","previousReward","previousDone","lastTrainingLoss","showLoading","initializeRenderer","initializeComponents","initializeWebGPUBackend","initializeControls","updateWebGPUStatusDisplay","updateCPUCoresStatusDisplay","startSimulation","updatePDControllerUI","updateUserControlOnlyUI","updateFreeRunSpeedUI","updateModelDisplay","showError","resizeCanvas","chartsPanel","statusElement","quickCheck","statusContainer","saveModelToLocalStorage","testModel","exportModelToCpp","importModelFromCpp","resetModelParameters","togglePDController","toggleUserControlOnly","setRewardFunction","setupOnScreenControls","setupCollapsibleSections","refreshModelList","sections","querySelectorAll","header","section","parentElement","toggle","sectionTitle","trim","isCollapsed","contains","savedState","speedSlider","currentSpeed","replace","startsWith","updateTrainingModelDisplay","startNewEpisode","startButton","disabled","pauseButton","updateOnScreenControlsVisibility","resetAngle","parallelBtn","updateUI","controlsPanel","containerWidth","clientWidth","containerHeight","clientHeight","availableWidth","offsetWidth","availableHeight","dpr","devicePixelRatio","actualWidth","actualHeight","setTransform","stopSimulation","startHighPerformanceSimulation","startDisplaySyncedSimulation","clearInterval","simulate","runSimulationFrame","baseTargetInterval","adaptedInterval","lastTimestamp","simulationCallCount","currentTimestamp","setInterval","isRenderingActive","updatePhysics","effectiveSpeed","updateRenderer","physicsStartTime","maxStepsPerFrame","baseSteps","stepsToRun","robotStepTime","yieldTime","yieldStart","normalizedState","getManualTorque","getPhysicsDemoTorque","getEvaluationTorque","trainingResult","getTrainingTorqueWithAction","torque","robotStepStart","handleEpisodeEnd","shouldTrain","_shouldTrainThisStep","trainingStart","finalLoss","syntheticResult","bounds","updateHistoryDebugDisplay","statusIndicator","updateBackendPerformanceDisplay","debugContent","networkInput","displayLines","angVel","timestepIndex","line","backendTypeElement","deviceInfoElement","performanceEstimateElement","backendInfo","backendType","caps","coresInfoElement","workersInfoElement","parallelSpeedupElement","perfStats","updatePerformanceMetricsDisplay","episodesPerMinuteElement","stepsPerSecondElement","renderingModeElement","trainingEfficiencyElement","displayStats","includes","performanceElement","avgTime","show","alert","adjustedTimestep","overrideParams","getTrainingTorque","validQValues","startNextEpisodeOrBatch","shouldUseParallelTraining","runParallelEpisodeBatch","effectiveBatchSize","batchStartTime","bestEpisodeReward","episodeReward","episodeSteps","balancedState","avgQValue","addExperience","totalTrainingLoss","totalExperiencesCollected","baseTrainingSteps","experienceMultiplier","trainingSteps","batchTrainingTime","episodeTimings","lastLogTime","avgEpisodeTime","updateTargetNetwork","episodeTrainingTime","timeSinceLastEpisode","newMode","updateUserControlUI","updateRewardTypeUI","currentStep","isEnabled","opacity","controls","shouldShow","networkArchitecture","strength","marginLeft","offsetRangeContainer","modelName","saveData","timestepConfig","episodesTrained","savedModels","listContainer","noModelsMsg","modelItem","createModelListItem","isCurrent","nameDiv","unloadBtn","onclick","unloadModel","loadBtn","loadModelByName","deleteBtn","deleteModel","details","completed","loadModel","confirm","removeItem","needsReinit","savedTimesteps","filename","cppCode","generateCppCode","blob","url","href","download","body","click","removeChild","revokeObjectURL","fileInput","handleFileSelect","file","files","reader","FileReader","onload","cppContent","importedModel","parseCppModel","loadImportedModel","readAsText","removeEventListener","inputSizeMatch","match","hiddenSizeMatch","outputSizeMatch","extractWeightsArray","timestampMatch","importDate","arrayName","arrayPattern","RegExp","split","cleanValue","importedArch","importedFrom","formatWeights","itemsPerLine","formatted","nameElement","statsElement","date","toLocaleDateString","toLocaleTimeString","displayName","setupCustomSliders","offsetSlider","offsetValue","degrees","radians","resetSlider","resetValue","offsetRangeSlider","offsetRangeValue"],"mappings":"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"}