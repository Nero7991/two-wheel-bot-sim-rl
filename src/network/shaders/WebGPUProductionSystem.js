/**
 * WebGPU Neural Network Production System
 * 
 * Comprehensive error handling, fallback mechanisms, and production readiness
 * for WebGPU-accelerated neural networks in critical applications.
 * 
 * Features:
 * - Multi-level error handling and recovery
 * - Intelligent fallback strategies
 * - Health monitoring and self-healing
 * - Production deployment validation
 * - Performance degradation handling
 * - Resource leak prevention
 */

import { WebGPUBackend } from '../WebGPUBackend.js';
import { CPUBackend } from '../CPUBackend.js';
import { WebGPUNeuralNetwork } from './WebGPUNeuralNetwork.js';
import { WebGPURealTimeNetwork, RealTimeMode } from './WebGPURealTime.js';
import { WebGPUVerification, quickVerify } from './WebGPUVerification.js';

/**
 * Error severity levels
 */
export const ErrorSeverity = {
    LOW: 'low',           // Minor issues, system continues normally
    MEDIUM: 'medium',     // Performance impact, degraded mode
    HIGH: 'high',         // Critical issues, fallback required
    CRITICAL: 'critical'  // System failure, emergency shutdown
};

/**
 * Recovery strategies
 */
export const RecoveryStrategy = {
    RETRY: 'retry',                    // Retry operation
    FALLBACK_CPU: 'fallback_cpu',     // Switch to CPU backend
    DEGRADE_QUALITY: 'degrade_quality', // Reduce quality for stability
    EMERGENCY_STOP: 'emergency_stop',  // Emergency shutdown
    REINITIALIZE: 'reinitialize'      // Full system restart
};

/**
 * Production-ready WebGPU neural network system with comprehensive error handling
 */
export class WebGPUProductionSystem {
    constructor(options = {}) {\n        // Core configuration\n        this.options = {\n            enableFallback: options.enableFallback !== false,\n            enableSelfHealing: options.enableSelfHealing !== false,\n            enableHealthMonitoring: options.enableHealthMonitoring !== false,\n            maxRetries: options.maxRetries || 3,\n            retryDelay: options.retryDelay || 100,\n            healthCheckInterval: options.healthCheckInterval || 5000,\n            performanceThreshold: options.performanceThreshold || 10.0, // ms\n            errorThreshold: options.errorThreshold || 0.05, // 5% error rate\n            ...options\n        };\n        \n        // System components\n        this.primaryBackend = null;\n        this.fallbackBackend = null;\n        this.currentBackend = null;\n        this.realTimeNetwork = null;\n        \n        // Error tracking and health monitoring\n        this.errorLog = [];\n        this.performanceHistory = [];\n        this.healthStatus = {\n            overall: 'unknown',\n            gpu: 'unknown',\n            cpu: 'unknown',\n            memory: 'unknown',\n            performance: 'unknown'\n        };\n        \n        // System state\n        this.isInitialized = false;\n        this.isHealthy = false;\n        this.usingFallback = false;\n        this.systemMode = 'normal'; // normal, degraded, emergency\n        \n        // Recovery state\n        this.retryCount = 0;\n        this.lastErrorTime = 0;\n        this.recoveryInProgress = false;\n        this.criticalErrorCount = 0;\n        \n        // Monitoring\n        this.healthCheckTimer = null;\n        this.performanceMonitor = null;\n        this.resourceMonitor = null;\n        \n        // Callbacks for external monitoring\n        this.errorCallback = options.onError || null;\n        this.healthCallback = options.onHealthChange || null;\n        this.performanceCallback = options.onPerformanceChange || null;\n        \n        console.log('WebGPU Production System initialized');\n    }\n\n    /**\n     * Initialize production system with comprehensive validation\n     * @param {Object} networkConfig - Network architecture configuration\n     * @param {Object} systemConfig - System-level configuration\n     * @returns {Promise<Object>} Initialization result\n     */\n    async initialize(networkConfig, systemConfig = {}) {\n        console.log('Initializing WebGPU Production System...');\n        const startTime = performance.now();\n        \n        try {\n            // Phase 1: System validation and setup\n            console.log('Phase 1: System validation...');\n            const validationResult = await this._validateSystemRequirements();\n            if (!validationResult.passed) {\n                throw new Error(`System validation failed: ${validationResult.issues.join(', ')}`);\n            }\n            \n            // Phase 2: Initialize primary backend (WebGPU)\n            console.log('Phase 2: Initializing WebGPU backend...');\n            try {\n                this.primaryBackend = new WebGPUBackend();\n                await this.primaryBackend.createNetwork(\n                    networkConfig.inputSize,\n                    networkConfig.hiddenSize,\n                    networkConfig.outputSize,\n                    networkConfig.options\n                );\n                \n                // Verify GPU functionality\n                const gpuVerification = await this._verifyGPUFunctionality();\n                if (!gpuVerification.passed) {\n                    throw new Error('GPU verification failed');\n                }\n                \n                this.currentBackend = this.primaryBackend;\n                console.log('WebGPU backend initialized successfully');\n                \n            } catch (error) {\n                console.warn('WebGPU backend initialization failed:', error.message);\n                if (!this.options.enableFallback) {\n                    throw error;\n                }\n                // Continue to fallback initialization\n            }\n            \n            // Phase 3: Initialize fallback backend (CPU)\n            if (this.options.enableFallback) {\n                console.log('Phase 3: Initializing CPU fallback...');\n                this.fallbackBackend = new CPUBackend();\n                await this.fallbackBackend.createNetwork(\n                    networkConfig.inputSize,\n                    networkConfig.hiddenSize,\n                    networkConfig.outputSize,\n                    networkConfig.options\n                );\n                \n                // If primary failed, use fallback\n                if (!this.currentBackend) {\n                    this.currentBackend = this.fallbackBackend;\n                    this.usingFallback = true;\n                    console.log('Using CPU fallback as primary backend');\n                }\n            }\n            \n            if (!this.currentBackend) {\n                throw new Error('No functional backend available');\n            }\n            \n            // Phase 4: Initialize real-time system if requested\n            if (systemConfig.enableRealTime) {\n                console.log('Phase 4: Initializing real-time system...');\n                if (this.primaryBackend && !this.usingFallback) {\n                    const device = this.primaryBackend.deviceManager.getDevice();\n                    this.realTimeNetwork = new WebGPURealTimeNetwork(device, systemConfig.realTimeOptions);\n                    await this.realTimeNetwork.initialize(\n                        networkConfig.inputSize,\n                        networkConfig.hiddenSize,\n                        networkConfig.outputSize\n                    );\n                }\n            }\n            \n            // Phase 5: Start health monitoring\n            if (this.options.enableHealthMonitoring) {\n                console.log('Phase 5: Starting health monitoring...');\n                this._startHealthMonitoring();\n            }\n            \n            // Phase 6: Performance validation\n            console.log('Phase 6: Performance validation...');\n            const performanceResult = await this._validatePerformance();\n            \n            this.isInitialized = true;\n            this.isHealthy = true;\n            this.systemMode = 'normal';\n            \n            const initTime = performance.now() - startTime;\n            console.log(`Production system initialized in ${initTime.toFixed(2)}ms`);\n            \n            return {\n                success: true,\n                initializationTime: initTime,\n                backend: this.usingFallback ? 'cpu' : 'webgpu',\n                realTimeCapable: this.realTimeNetwork !== null,\n                healthMonitoring: this.options.enableHealthMonitoring,\n                performance: performanceResult,\n                validation: validationResult\n            };\n            \n        } catch (error) {\n            console.error('Production system initialization failed:', error);\n            await this._handleCriticalError(error, 'initialization');\n            throw error;\n        }\n    }\n\n    /**\n     * Production-ready inference with comprehensive error handling\n     * @param {Float32Array} input - Input data\n     * @param {Object} options - Inference options\n     * @returns {Promise<Float32Array>} Network output\n     */\n    async infer(input, options = {}) {\n        if (!this.isInitialized) {\n            throw new Error('System not initialized');\n        }\n        \n        const operation = async () => {\n            // Use real-time network if available and requested\n            if (this.realTimeNetwork && options.realTime) {\n                return await this.realTimeNetwork.infer(input, options);\n            }\n            \n            // Standard inference\n            return await this.currentBackend.forward(input);\n        };\n        \n        return await this._executeWithErrorHandling(operation, 'inference', input);\n    }\n\n    /**\n     * Execute operation with comprehensive error handling\n     * @private\n     */\n    async _executeWithErrorHandling(operation, operationType, context = null) {\n        const startTime = performance.now();\n        let lastError = null;\n        \n        for (let attempt = 0; attempt <= this.options.maxRetries; attempt++) {\n            try {\n                // Check system health before operation\n                if (!this.isHealthy && this.systemMode === 'emergency') {\n                    throw new Error('System in emergency mode');\n                }\n                \n                // Execute operation\n                const result = await operation();\n                \n                // Record successful operation\n                this._recordPerformance(performance.now() - startTime, true);\n                \n                // Reset retry count on success\n                this.retryCount = 0;\n                \n                return result;\n                \n            } catch (error) {\n                lastError = error;\n                const severity = this._classifyError(error);\n                \n                console.warn(`${operationType} failed (attempt ${attempt + 1}/${this.options.maxRetries + 1}):`, error.message);\n                \n                // Record error\n                this._recordError(error, operationType, severity, context);\n                \n                // Determine recovery strategy\n                const strategy = this._determineRecoveryStrategy(error, severity, attempt);\n                \n                // Execute recovery strategy\n                const recovered = await this._executeRecoveryStrategy(strategy, error, operationType);\n                \n                if (recovered || attempt === this.options.maxRetries) {\n                    if (!recovered && attempt === this.options.maxRetries) {\n                        // All retries exhausted\n                        await this._handleCriticalError(lastError, operationType);\n                        throw lastError;\n                    }\n                    // Recovery successful, retry operation\n                    await this._delay(this.options.retryDelay * Math.pow(2, attempt));\n                }\n            }\n        }\n        \n        throw lastError;\n    }\n\n    /**\n     * Classify error severity\n     * @private\n     */\n    _classifyError(error) {\n        const message = error.message.toLowerCase();\n        \n        if (message.includes('device lost') || message.includes('context lost')) {\n            return ErrorSeverity.CRITICAL;\n        }\n        if (message.includes('out of memory') || message.includes('allocation failed')) {\n            return ErrorSeverity.HIGH;\n        }\n        if (message.includes('timeout') || message.includes('performance')) {\n            return ErrorSeverity.MEDIUM;\n        }\n        \n        return ErrorSeverity.LOW;\n    }\n\n    /**\n     * Determine appropriate recovery strategy\n     * @private\n     */\n    _determineRecoveryStrategy(error, severity, attempt) {\n        switch (severity) {\n            case ErrorSeverity.CRITICAL:\n                if (this.options.enableFallback && this.fallbackBackend) {\n                    return RecoveryStrategy.FALLBACK_CPU;\n                }\n                return RecoveryStrategy.EMERGENCY_STOP;\n                \n            case ErrorSeverity.HIGH:\n                if (attempt < 2) {\n                    return RecoveryStrategy.RETRY;\n                }\n                if (this.options.enableFallback && !this.usingFallback) {\n                    return RecoveryStrategy.FALLBACK_CPU;\n                }\n                return RecoveryStrategy.DEGRADE_QUALITY;\n                \n            case ErrorSeverity.MEDIUM:\n                if (attempt < 1) {\n                    return RecoveryStrategy.RETRY;\n                }\n                return RecoveryStrategy.DEGRADE_QUALITY;\n                \n            case ErrorSeverity.LOW:\n            default:\n                return RecoveryStrategy.RETRY;\n        }\n    }\n\n    /**\n     * Execute recovery strategy\n     * @private\n     */\n    async _executeRecoveryStrategy(strategy, error, operationType) {\n        this.recoveryInProgress = true;\n        \n        try {\n            switch (strategy) {\n                case RecoveryStrategy.RETRY:\n                    console.log('Recovery strategy: Retry');\n                    this.retryCount++;\n                    return true; // Allow retry\n                    \n                case RecoveryStrategy.FALLBACK_CPU:\n                    console.log('Recovery strategy: CPU Fallback');\n                    return await this._switchToCPUFallback();\n                    \n                case RecoveryStrategy.DEGRADE_QUALITY:\n                    console.log('Recovery strategy: Degrade Quality');\n                    return await this._degradeQuality();\n                    \n                case RecoveryStrategy.REINITIALIZE:\n                    console.log('Recovery strategy: Reinitialize');\n                    return await this._reinitializeSystem();\n                    \n                case RecoveryStrategy.EMERGENCY_STOP:\n                    console.log('Recovery strategy: Emergency Stop');\n                    await this._emergencyShutdown();\n                    return false;\n                    \n                default:\n                    return false;\n            }\n        } catch (recoveryError) {\n            console.error('Recovery strategy failed:', recoveryError);\n            return false;\n        } finally {\n            this.recoveryInProgress = false;\n        }\n    }\n\n    /**\n     * Switch to CPU fallback\n     * @private\n     */\n    async _switchToCPUFallback() {\n        if (!this.fallbackBackend) {\n            console.error('No CPU fallback available');\n            return false;\n        }\n        \n        try {\n            // Copy weights from primary to fallback if possible\n            if (this.primaryBackend && !this.usingFallback) {\n                const weights = await this.primaryBackend.getWeights();\n                // Convert GPU weights format to CPU format if needed\n                const cpuWeights = this._convertWeightsForCPU(weights);\n                this.fallbackBackend.setWeights(cpuWeights);\n            }\n            \n            this.currentBackend = this.fallbackBackend;\n            this.usingFallback = true;\n            this.systemMode = 'degraded';\n            \n            console.log('Successfully switched to CPU fallback');\n            this._notifyHealthChange();\n            \n            return true;\n            \n        } catch (error) {\n            console.error('Failed to switch to CPU fallback:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Degrade system quality for stability\n     * @private\n     */\n    async _degradeQuality() {\n        console.log('Degrading system quality for stability');\n        \n        this.systemMode = 'degraded';\n        \n        // Disable expensive features\n        if (this.realTimeNetwork) {\n            // Switch to lower optimization level\n            if (this.realTimeNetwork.optimizationLevel > 0) {\n                this.realTimeNetwork.optimizationLevel--;\n                console.log('Reduced real-time optimization level');\n            }\n        }\n        \n        this._notifyHealthChange();\n        return true;\n    }\n\n    /**\n     * Reinitialize the entire system\n     * @private\n     */\n    async _reinitializeSystem() {\n        console.log('Reinitializing system...');\n        \n        try {\n            // Clean up current resources\n            await this._cleanup();\n            \n            // Reinitialize with current configuration\n            // Note: This would need access to original configuration\n            // For now, mark system as needing manual reinitialization\n            this.isInitialized = false;\n            this.isHealthy = false;\n            this.systemMode = 'emergency';\n            \n            console.log('System marked for manual reinitialization');\n            return false;\n            \n        } catch (error) {\n            console.error('System reinitialization failed:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Emergency shutdown\n     * @private\n     */\n    async _emergencyShutdown() {\n        console.error('Executing emergency shutdown');\n        \n        this.systemMode = 'emergency';\n        this.isHealthy = false;\n        \n        // Stop all monitoring\n        this._stopHealthMonitoring();\n        \n        // Notify external systems\n        if (this.errorCallback) {\n            this.errorCallback({\n                type: 'emergency_shutdown',\n                timestamp: new Date().toISOString(),\n                message: 'System emergency shutdown executed'\n            });\n        }\n        \n        // Keep minimal functionality for emergency operation\n        this.currentBackend = this.fallbackBackend;\n        this.usingFallback = true;\n        \n        this._notifyHealthChange();\n    }\n\n    /**\n     * Validate system requirements\n     * @private\n     */\n    async _validateSystemRequirements() {\n        const result = { passed: true, issues: [], warnings: [] };\n        \n        try {\n            // Check WebGPU availability\n            if (!navigator.gpu) {\n                result.warnings.push('WebGPU not available, will use CPU fallback');\n            }\n            \n            // Check memory availability\n            if (navigator.deviceMemory && navigator.deviceMemory < 4) {\n                result.warnings.push('Low device memory detected');\n            }\n            \n            // Check for required features\n            const requiredFeatures = ['Float32Array', 'performance'];\n            for (const feature of requiredFeatures) {\n                if (typeof window[feature] === 'undefined') {\n                    result.issues.push(`Required feature not available: ${feature}`);\n                    result.passed = false;\n                }\n            }\n            \n        } catch (error) {\n            result.issues.push(`System validation error: ${error.message}`);\n            result.passed = false;\n        }\n        \n        return result;\n    }\n\n    /**\n     * Verify GPU functionality\n     * @private\n     */\n    async _verifyGPUFunctionality() {\n        if (!this.primaryBackend) {\n            return { passed: false, reason: 'No GPU backend available' };\n        }\n        \n        try {\n            // Quick verification using the verification system\n            const device = this.primaryBackend.deviceManager?.getDevice();\n            if (!device) {\n                return { passed: false, reason: 'No WebGPU device available' };\n            }\n            \n            const verified = await quickVerify(device, { skipStressTests: true });\n            return { passed: verified, reason: verified ? null : 'GPU verification failed' };\n            \n        } catch (error) {\n            return { passed: false, reason: error.message };\n        }\n    }\n\n    /**\n     * Validate performance requirements\n     * @private\n     */\n    async _validatePerformance() {\n        const testInput = new Float32Array([0.1, -0.05]);\n        const iterations = 100;\n        const times = [];\n        \n        // Warmup\n        for (let i = 0; i < 10; i++) {\n            await this.currentBackend.forward(testInput);\n        }\n        \n        // Performance test\n        for (let i = 0; i < iterations; i++) {\n            const start = performance.now();\n            await this.currentBackend.forward(testInput);\n            times.push(performance.now() - start);\n        }\n        \n        const stats = this._calculateStats(times);\n        const meetsThreshold = stats.p95 <= this.options.performanceThreshold;\n        \n        return {\n            passed: meetsThreshold,\n            stats,\n            threshold: this.options.performanceThreshold,\n            backend: this.usingFallback ? 'cpu' : 'webgpu'\n        };\n    }\n\n    /**\n     * Start health monitoring\n     * @private\n     */\n    _startHealthMonitoring() {\n        if (this.healthCheckTimer) {\n            clearInterval(this.healthCheckTimer);\n        }\n        \n        this.healthCheckTimer = setInterval(() => {\n            this._performHealthCheck();\n        }, this.options.healthCheckInterval);\n        \n        console.log('Health monitoring started');\n    }\n\n    /**\n     * Stop health monitoring\n     * @private\n     */\n    _stopHealthMonitoring() {\n        if (this.healthCheckTimer) {\n            clearInterval(this.healthCheckTimer);\n            this.healthCheckTimer = null;\n        }\n        \n        console.log('Health monitoring stopped');\n    }\n\n    /**\n     * Perform comprehensive health check\n     * @private\n     */\n    async _performHealthCheck() {\n        const healthUpdate = {\n            overall: 'healthy',\n            gpu: 'unknown',\n            cpu: 'healthy',\n            memory: 'healthy',\n            performance: 'healthy',\n            timestamp: new Date().toISOString()\n        };\n        \n        try {\n            // Check GPU health\n            if (this.primaryBackend && !this.usingFallback) {\n                const gpuInfo = this.primaryBackend.getBackendInfo();\n                healthUpdate.gpu = gpuInfo.webgpuAvailable ? 'healthy' : 'degraded';\n            } else {\n                healthUpdate.gpu = 'unavailable';\n            }\n            \n            // Check memory usage\n            const memoryInfo = this.currentBackend.getMemoryUsage?.();\n            if (memoryInfo && memoryInfo.totalKB > 100000) { // >100MB\n                healthUpdate.memory = 'warning';\n            }\n            \n            // Check performance trends\n            const recentPerformance = this.performanceHistory.slice(-50);\n            if (recentPerformance.length > 10) {\n                const avgTime = recentPerformance.reduce((sum, p) => sum + p.time, 0) / recentPerformance.length;\n                if (avgTime > this.options.performanceThreshold) {\n                    healthUpdate.performance = 'degraded';\n                }\n            }\n            \n            // Check error rate\n            const recentErrors = this.errorLog.slice(-100);\n            const errorRate = recentErrors.length / 100;\n            if (errorRate > this.options.errorThreshold) {\n                healthUpdate.overall = 'warning';\n            }\n            \n            // Update health status\n            const previousHealth = this.healthStatus.overall;\n            this.healthStatus = healthUpdate;\n            this.isHealthy = healthUpdate.overall === 'healthy';\n            \n            // Notify if health changed\n            if (previousHealth !== healthUpdate.overall) {\n                this._notifyHealthChange();\n            }\n            \n        } catch (error) {\n            console.error('Health check failed:', error);\n            this.healthStatus.overall = 'error';\n            this.isHealthy = false;\n        }\n    }\n\n    /**\n     * Record error for monitoring\n     * @private\n     */\n    _recordError(error, operationType, severity, context) {\n        const errorRecord = {\n            timestamp: new Date().toISOString(),\n            operation: operationType,\n            severity,\n            message: error.message,\n            stack: error.stack,\n            context,\n            systemMode: this.systemMode,\n            usingFallback: this.usingFallback\n        };\n        \n        this.errorLog.push(errorRecord);\n        \n        // Keep error log manageable\n        if (this.errorLog.length > 1000) {\n            this.errorLog.shift();\n        }\n        \n        // Track critical errors\n        if (severity === ErrorSeverity.CRITICAL) {\n            this.criticalErrorCount++;\n        }\n        \n        // Notify external systems\n        if (this.errorCallback) {\n            this.errorCallback(errorRecord);\n        }\n    }\n\n    /**\n     * Record performance metrics\n     * @private\n     */\n    _recordPerformance(time, success) {\n        const record = {\n            timestamp: Date.now(),\n            time,\n            success,\n            backend: this.usingFallback ? 'cpu' : 'webgpu',\n            systemMode: this.systemMode\n        };\n        \n        this.performanceHistory.push(record);\n        \n        // Keep performance history manageable\n        if (this.performanceHistory.length > 1000) {\n            this.performanceHistory.shift();\n        }\n        \n        // Check for performance degradation\n        if (time > this.options.performanceThreshold * 2) {\n            console.warn(`Performance degradation detected: ${time.toFixed(2)}ms`);\n        }\n        \n        // Notify external systems\n        if (this.performanceCallback) {\n            this.performanceCallback(record);\n        }\n    }\n\n    /**\n     * Notify health status change\n     * @private\n     */\n    _notifyHealthChange() {\n        if (this.healthCallback) {\n            this.healthCallback({\n                status: this.healthStatus,\n                isHealthy: this.isHealthy,\n                systemMode: this.systemMode,\n                usingFallback: this.usingFallback\n            });\n        }\n    }\n\n    /**\n     * Convert GPU weights format to CPU format\n     * @private\n     */\n    _convertWeightsForCPU(gpuWeights) {\n        // Convert from GPU format to CPU format\n        return {\n            architecture: {\n                inputSize: 2,\n                hiddenSize: gpuWeights.biasHidden.length,\n                outputSize: gpuWeights.biasOutput.length,\n                parameterCount: gpuWeights.weightsHidden.length + gpuWeights.biasHidden.length + \n                              gpuWeights.weightsOutput.length + gpuWeights.biasOutput.length\n            },\n            weightsInputHidden: gpuWeights.weightsHidden,\n            biasHidden: gpuWeights.biasHidden,\n            weightsHiddenOutput: gpuWeights.weightsOutput,\n            biasOutput: gpuWeights.biasOutput\n        };\n    }\n\n    /**\n     * Handle critical errors\n     * @private\n     */\n    async _handleCriticalError(error, context) {\n        console.error(`Critical error in ${context}:`, error);\n        \n        this.criticalErrorCount++;\n        this.systemMode = 'emergency';\n        this.isHealthy = false;\n        \n        // Record critical error\n        this._recordError(error, context, ErrorSeverity.CRITICAL, null);\n        \n        // Attempt emergency recovery if self-healing enabled\n        if (this.options.enableSelfHealing) {\n            console.log('Attempting self-healing...');\n            await this._executeRecoveryStrategy(RecoveryStrategy.FALLBACK_CPU, error, context);\n        }\n    }\n\n    /**\n     * Get comprehensive system status\n     * @returns {Object} System status and metrics\n     */\n    getSystemStatus() {\n        const recentErrors = this.errorLog.slice(-10);\n        const recentPerformance = this.performanceHistory.slice(-100);\n        \n        return {\n            system: {\n                initialized: this.isInitialized,\n                healthy: this.isHealthy,\n                mode: this.systemMode,\n                usingFallback: this.usingFallback,\n                recoveryInProgress: this.recoveryInProgress\n            },\n            health: this.healthStatus,\n            performance: {\n                recentAverage: recentPerformance.length > 0 ? \n                    (recentPerformance.reduce((sum, p) => sum + p.time, 0) / recentPerformance.length) : 0,\n                threshold: this.options.performanceThreshold,\n                totalInferences: this.performanceHistory.length\n            },\n            errors: {\n                total: this.errorLog.length,\n                critical: this.criticalErrorCount,\n                recent: recentErrors.length,\n                rate: this.performanceHistory.length > 0 ? \n                    (this.errorLog.length / this.performanceHistory.length * 100) : 0\n            },\n            backends: {\n                primary: this.primaryBackend ? 'webgpu' : null,\n                fallback: this.fallbackBackend ? 'cpu' : null,\n                current: this.usingFallback ? 'cpu' : 'webgpu',\n                realTime: this.realTimeNetwork !== null\n            },\n            options: this.options\n        };\n    }\n\n    /**\n     * Calculate statistical measures\n     * @private\n     */\n    _calculateStats(values) {\n        if (values.length === 0) return { count: 0, min: 0, max: 0, mean: 0, p95: 0 };\n        \n        const sorted = [...values].sort((a, b) => a - b);\n        const mean = values.reduce((sum, v) => sum + v, 0) / values.length;\n        \n        return {\n            count: values.length,\n            min: Math.min(...values),\n            max: Math.max(...values),\n            mean,\n            p95: sorted[Math.floor(values.length * 0.95)]\n        };\n    }\n\n    /**\n     * Delay utility\n     * @private\n     */\n    _delay(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    /**\n     * Clean up system resources\n     * @private\n     */\n    async _cleanup() {\n        this._stopHealthMonitoring();\n        \n        if (this.realTimeNetwork) {\n            this.realTimeNetwork.destroy();\n            this.realTimeNetwork = null;\n        }\n        \n        if (this.primaryBackend) {\n            this.primaryBackend.destroy();\n            this.primaryBackend = null;\n        }\n        \n        // CPU backend doesn't have destroy method\n        this.fallbackBackend = null;\n        this.currentBackend = null;\n    }\n\n    /**\n     * Destroy production system\n     */\n    destroy() {\n        this._cleanup();\n        \n        this.isInitialized = false;\n        this.isHealthy = false;\n        this.systemMode = 'shutdown';\n        \n        console.log('WebGPU Production System destroyed');\n    }\n}\n\n/**\n * Factory function for production system\n * @param {Object} options - Configuration options\n * @returns {WebGPUProductionSystem} Production system instance\n */\nexport function createProductionSystem(options = {}) {\n    return new WebGPUProductionSystem(options);\n}\n\n/**\n * Quick setup for production deployment\n * @param {Object} config - Deployment configuration\n * @returns {Promise<WebGPUProductionSystem>} Initialized production system\n */\nexport async function setupProductionDeployment(config = {}) {\n    const options = {\n        enableFallback: true,\n        enableSelfHealing: true,\n        enableHealthMonitoring: true,\n        maxRetries: 3,\n        performanceThreshold: 10.0,\n        errorThreshold: 0.05,\n        ...config.systemOptions\n    };\n    \n    const networkConfig = {\n        inputSize: 2,\n        hiddenSize: config.hiddenSize || 8,\n        outputSize: 3,\n        options: {\n            initMethod: 'he',\n            ...config.networkOptions\n        }\n    };\n    \n    const systemConfig = {\n        enableRealTime: config.enableRealTime !== false,\n        realTimeOptions: {\n            mode: config.realTimeMode || RealTimeMode.BALANCED,\n            ...config.realTimeOptions\n        }\n    };\n    \n    const system = new WebGPUProductionSystem(options);\n    const result = await system.initialize(networkConfig, systemConfig);\n    \n    console.log('Production deployment ready:', result);\n    return system;\n}\n\n/**\n * Validate production readiness\n * @param {WebGPUProductionSystem} system - Production system instance\n * @returns {Promise<Object>} Readiness assessment\n */\nexport async function validateProductionReadiness(system) {\n    const status = system.getSystemStatus();\n    \n    const readiness = {\n        ready: false,\n        score: 0,\n        issues: [],\n        recommendations: []\n    };\n    \n    // Check system health\n    if (status.system.healthy) {\n        readiness.score += 30;\n    } else {\n        readiness.issues.push('System health check failed');\n    }\n    \n    // Check error rate\n    if (status.errors.rate < 1.0) {\n        readiness.score += 25;\n    } else {\n        readiness.issues.push(`High error rate: ${status.errors.rate.toFixed(2)}%`);\n        readiness.recommendations.push('Investigate and fix recurring errors');\n    }\n    \n    // Check performance\n    if (status.performance.recentAverage < status.performance.threshold) {\n        readiness.score += 25;\n    } else {\n        readiness.issues.push('Performance below threshold');\n        readiness.recommendations.push('Optimize performance or adjust thresholds');\n    }\n    \n    // Check fallback availability\n    if (status.backends.fallback) {\n        readiness.score += 20;\n    } else {\n        readiness.issues.push('No fallback backend available');\n        readiness.recommendations.push('Enable CPU fallback for production safety');\n    }\n    \n    readiness.ready = readiness.score >= 80;\n    \n    return readiness;\n}